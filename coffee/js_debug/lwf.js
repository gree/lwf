// Copyright (c) 2012-2013 GREE, Inc - http://git.io/uvS3hQ
// Copyright (c) 2010-2012 Tween.js authors - http://git.io/tiDrNw
// Copyright (c) 2001 Robert Penner - http://goo.gl/Qjqc0
// Copyright (c) 2011 Gary Linscott
// Copyright (c) 2011-2012 Juan Mellado
// Copyright (c) 2013 C. Scott Ananian - http://git.io/vUHSG
// Copyright (c) 2012 imaya - http://git.io/cC8gDw
if (typeof global === "undefined" && typeof window !== "undefined") {
	/* Browsers */
	global = window;
} else if (typeof window === "undefined" && typeof self !== "undefined") {
	/* Workers */
	global = self;
}
// Generated by CoffeeScript 1.8.0
(function() { var __FILE__ = 'lwf.js';
  var Align, AlphaTransform, Animation, Bitmap, BitmapClip, BitmapEx, Button, ButtonEventHandlers, CanvasBitmapContext, CanvasBitmapRenderer, CanvasRenderCommand, CanvasRendererFactory, CanvasResourceCache, CanvasTextContext, CanvasTextRenderer, ClipEvent, Color, ColorTransform, Condition, Constant, ControlType, Data, EventHandlers, Format, GObjType, Graphic, HTML5TextContext, HTML5TextRenderer, IObject, LObject, LWF, LWFContainer, LWFLoader, LWFLoaderWithArray, LWFLoaderWithArrayBuffer, Loader, Matrix, Movie, MovieEventHandlers, NullRendererFactory, Particle, Point, ProgramObject, Property, SHADERS, Text, Translate, Type, TypedArray, Utility, WebGLBitmapContext, WebGLBitmapRenderer, WebGLRenderCommand, WebGLRendererContext, WebGLRendererFactory, WebGLResourceCache, WebGLShader, WebGLTextContext, WebGLTextRenderer, WebKitCSSRenderCommand, WebkitCSSBitmapContext, WebkitCSSBitmapRenderer, WebkitCSSDomElementRenderer, WebkitCSSLoader, WebkitCSSRendererFactory, WebkitCSSResourceCache, WebkitCSSTextContext, WebkitCSSTextRenderer,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  TypedArray = (function() {
    function TypedArray() {}

    TypedArray.available = typeof Float32Array !== 'undefined';

    return TypedArray;

  })();

  Point = (function() {
    function Point(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
    }

    return Point;

  })();

  Translate = (function() {
    function Translate(translateX, translateY) {
      if (translateX == null) {
        translateX = 0;
      }
      if (translateY == null) {
        translateY = 0;
      }
      this._ = TypedArray.available ? new Float32Array(2) : [];
      this._[0] = translateX;
      this._[1] = translateY;
    }

    Translate.prototype.getTranslateX = function() {
      return this._[0];
    };

    Translate.prototype.setTranslateX = function(v) {
      this._[0] = v;
    };

    Translate.prototype.getTranslateY = function() {
      return this._[1];
    };

    Translate.prototype.setTranslateY = function(v) {
      this._[1] = v;
    };

    return Translate;

  })();

  if (typeof Translate.prototype.__defineGetter__ !== "undefined") {
    Translate.prototype.__defineGetter__("translateX", function() {
      return this.getTranslateX();
    });
    Translate.prototype.__defineSetter__("translateX", function(v) {
      return this.setTranslateX(v);
    });
    Translate.prototype.__defineGetter__("translateY", function() {
      return this.getTranslateY();
    });
    Translate.prototype.__defineSetter__("translateY", function(v) {
      return this.setTranslateY(v);
    });
  } else if (typeof Object.defineProperty !== "undefined") {
    Object.defineProperty(Translate.prototype, "translateX", {
      get: function() {
        return this.getTranslateX();
      },
      set: function(v) {
        return this.setTranslateX(v);
      }
    });
    Object.defineProperty(Translate.prototype, "translateY", {
      get: function() {
        return this.getTranslateY();
      },
      set: function(v) {
        return this.setTranslateY(v);
      }
    });
  }

  Matrix = (function() {
    function Matrix(scaleX, scaleY, skew0, skew1, translateX, translateY) {
      this._ = TypedArray.available ? new Float32Array(6) : [];
      if (scaleX != null) {
        this._[0] = scaleX;
        this._[1] = skew1;
        this._[2] = skew0;
        this._[3] = scaleY;
        this._[4] = translateX;
        this._[5] = translateY;
      } else {
        this.clear();
      }
    }

    Matrix.prototype.clear = function() {
      this._[0] = 1;
      this._[1] = 0;
      this._[2] = 0;
      this._[3] = 1;
      this._[4] = 0;
      this._[5] = 0;
    };

    Matrix.prototype.set = function(m) {
      var i, _i;
      for (i = _i = 0; _i < 6; i = ++_i) {
        this._[i] = m._[i];
      }
      return this;
    };

    Matrix.prototype.setWithComparing = function(m) {
      var changed, i, _i;
      if (m === null) {
        return false;
      }
      changed = false;
      for (i = _i = 0; _i < 6; i = ++_i) {
        if (this._[i] !== m._[i]) {
          this._[i] = m._[i];
          changed = true;
        }
      }
      return changed;
    };

    Matrix.prototype.getScaleX = function() {
      return this._[0];
    };

    Matrix.prototype.setScaleX = function(v) {
      this._[0] = v;
    };

    Matrix.prototype.getSkew1 = function() {
      return this._[1];
    };

    Matrix.prototype.setSkew1 = function(v) {
      this._[1] = v;
    };

    Matrix.prototype.getSkew0 = function() {
      return this._[2];
    };

    Matrix.prototype.setSkew0 = function(v) {
      this._[2] = v;
    };

    Matrix.prototype.getScaleY = function() {
      return this._[3];
    };

    Matrix.prototype.setScaleY = function(v) {
      this._[3] = v;
    };

    Matrix.prototype.getTranslateX = function() {
      return this._[4];
    };

    Matrix.prototype.setTranslateX = function(v) {
      this._[4] = v;
    };

    Matrix.prototype.getTranslateY = function() {
      return this._[5];
    };

    Matrix.prototype.setTranslateY = function(v) {
      this._[5] = v;
    };

    return Matrix;

  })();

  if (typeof Matrix.prototype.__defineGetter__ !== "undefined") {
    Matrix.prototype.__defineGetter__("scaleX", function() {
      return this.getScaleX();
    });
    Matrix.prototype.__defineSetter__("scaleX", function(v) {
      return this.setScaleX(v);
    });
    Matrix.prototype.__defineGetter__("scaleY", function() {
      return this.getScaleY();
    });
    Matrix.prototype.__defineSetter__("scaleY", function(v) {
      return this.setScaleY(v);
    });
    Matrix.prototype.__defineGetter__("skew0", function() {
      return this.getSkew0();
    });
    Matrix.prototype.__defineSetter__("skew0", function(v) {
      return this.setSkew0(v);
    });
    Matrix.prototype.__defineGetter__("skew1", function() {
      return this.getSkew1();
    });
    Matrix.prototype.__defineSetter__("skew1", function(v) {
      return this.setSkew1(v);
    });
    Matrix.prototype.__defineGetter__("translateX", function() {
      return this.getTranslateX();
    });
    Matrix.prototype.__defineSetter__("translateX", function(v) {
      return this.setTranslateX(v);
    });
    Matrix.prototype.__defineGetter__("translateY", function() {
      return this.getTranslateY();
    });
    Matrix.prototype.__defineSetter__("translateY", function(v) {
      return this.setTranslateY(v);
    });
  } else if (typeof Object.defineProperty !== "undefined") {
    Object.defineProperty(Matrix.prototype, "scaleX", {
      get: function() {
        return this.getScaleX();
      },
      set: function(v) {
        return this.setScaleX(v);
      }
    });
    Object.defineProperty(Matrix.prototype, "scaleY", {
      get: function() {
        return this.getScaleY();
      },
      set: function(v) {
        return this.setScaleY(v);
      }
    });
    Object.defineProperty(Matrix.prototype, "skew0", {
      get: function() {
        return this.getSkew0();
      },
      set: function(v) {
        return this.setSkew0(v);
      }
    });
    Object.defineProperty(Matrix.prototype, "skew1", {
      get: function() {
        return this.getSkew1();
      },
      set: function(v) {
        return this.setSkew1(v);
      }
    });
    Object.defineProperty(Matrix.prototype, "translateX", {
      get: function() {
        return this.getTranslateX();
      },
      set: function(v) {
        return this.setTranslateX(v);
      }
    });
    Object.defineProperty(Matrix.prototype, "translateY", {
      get: function() {
        return this.getTranslateY();
      },
      set: function(v) {
        return this.setTranslateY(v);
      }
    });
  }

  Color = (function() {
    function Color(red, green, blue, alpha) {
      this._ = TypedArray.available ? new Float32Array(4) : [];
      if (red != null) {
        this._[0] = red;
        this._[1] = green;
        this._[2] = blue;
        this._[3] = alpha;
      } else {
        this._[0] = 0;
        this._[1] = 0;
        this._[2] = 0;
        this._[3] = 0;
      }
    }

    Color.prototype.set = function(r, g, b, a) {
      var c, i, _i;
      if (typeof r === "object") {
        c = r;
        for (i = _i = 0; _i < 4; i = ++_i) {
          this._[i] = c._[i];
        }
      } else {
        this._[0] = r;
        this._[1] = g;
        this._[2] = b;
        this._[3] = a;
      }
    };

    Color.prototype.isZero = function() {
      return this._[0] === 0 && this._[1] === 0 && this._[2] === 0 && this._[3] === 0;
    };

    Color.prototype.getRed = function() {
      return this._[0];
    };

    Color.prototype.setRed = function(v) {
      this._[0] = v;
    };

    Color.prototype.getGreen = function() {
      return this._[1];
    };

    Color.prototype.setGreen = function(v) {
      this._[1] = v;
    };

    Color.prototype.getBlue = function() {
      return this._[2];
    };

    Color.prototype.setBlue = function(v) {
      this._[2] = v;
    };

    Color.prototype.getAlpha = function() {
      return this._[3];
    };

    Color.prototype.setAlpha = function(v) {
      this._[3] = v;
    };

    return Color;

  })();

  if (typeof Color.prototype.__defineGetter__ !== "undefined") {
    Color.prototype.__defineGetter__("red", function() {
      return this.getRed();
    });
    Color.prototype.__defineSetter__("red", function(v) {
      return this.setRed(v);
    });
    Color.prototype.__defineGetter__("green", function() {
      return this.getGreen();
    });
    Color.prototype.__defineSetter__("green", function(v) {
      return this.setGreen(v);
    });
    Color.prototype.__defineGetter__("blue", function() {
      return this.getBlue();
    });
    Color.prototype.__defineSetter__("blue", function(v) {
      return this.setBlue(v);
    });
    Color.prototype.__defineGetter__("alpha", function() {
      return this.getAlpha();
    });
    Color.prototype.__defineSetter__("alpha", function(v) {
      return this.setAlpha(v);
    });
  } else if (typeof Object.defineProperty !== "undefined") {
    Object.defineProperty(Color.prototype, "red", {
      get: function() {
        return this.getRed();
      },
      set: function(v) {
        return this.setRed(v);
      }
    });
    Object.defineProperty(Color.prototype, "green", {
      get: function() {
        return this.getGreen();
      },
      set: function(v) {
        return this.setGreen(v);
      }
    });
    Object.defineProperty(Color.prototype, "blue", {
      get: function() {
        return this.getBlue();
      },
      set: function(v) {
        return this.setBlue(v);
      }
    });
    Object.defineProperty(Color.prototype, "alpha", {
      get: function() {
        return this.getAlpha();
      },
      set: function(v) {
        return this.setAlpha(v);
      }
    });
  }

  AlphaTransform = (function() {
    function AlphaTransform(alpha) {
      this._ = TypedArray.available ? new Float32Array(1) : [];
      this._[0] = alpha;
    }

    AlphaTransform.prototype.getAlpha = function() {
      return this._[0];
    };

    AlphaTransform.prototype.setAlpha = function(v) {
      this._[0] = v;
    };

    return AlphaTransform;

  })();

  if (typeof AlphaTransform.prototype.__defineGetter__ !== "undefined") {
    AlphaTransform.prototype.__defineGetter__("alpha", function() {
      return this.getAlpha();
    });
    AlphaTransform.prototype.__defineSetter__("alpha", function(v) {
      return this.setAlpha(v);
    });
  } else if (typeof Object.defineProperty !== "undefined") {
    Object.defineProperty(AlphaTransform.prototype, "alpha", {
      get: function() {
        return this.getAlpha();
      },
      set: function(v) {
        return this.setAlpha(v);
      }
    });
  }

  ColorTransform = (function() {
    function ColorTransform(mr, mg, mb, ma, ar, ag, ab, aa) {
      this.multi = new Color(mr, mg, mb, ma);
      this.add = new Color(ar, ag, ab, aa);
      if (mr == null) {
        this.clear();
      }
    }

    ColorTransform.prototype.clear = function() {
      this.multi.set(1, 1, 1, 1);
      this.add.set(0, 0, 0, 0);
    };

    ColorTransform.prototype.set = function(c) {
      this.multi.set(c.multi);
      this.add.set(c.add);
      return this;
    };

    ColorTransform.prototype.hasAdd = function() {
      return !this.add.isZero();
    };

    ColorTransform.prototype.setWithComparing = function(c) {
      var a, ca, changed, cm, i, m, _i, _j;
      if (c === null) {
        return false;
      }
      changed = false;
      cm = c.multi;
      m = this.multi;
      for (i = _i = 0; _i < 4; i = ++_i) {
        if (m._[i] !== cm._[i]) {
          m._[i] = cm._[i];
          changed = true;
        }
      }
      ca = c.add;
      a = this.add;
      for (i = _j = 0; _j < 4; i = ++_j) {
        if (a._[i] !== ca._[i]) {
          a._[i] = ca._[i];
          changed = true;
        }
      }
      return changed;
    };

    return ColorTransform;

  })();

  Format = (function() {
    function Format() {}

    Format.Constant = (function() {
      function Constant() {}

      Constant.HEADER_SIZE = 332;

      Constant.FORMAT_VERSION_0 = 0x14;

      Constant.FORMAT_VERSION_1 = 0x12;

      Constant.FORMAT_VERSION_2 = 0x11;

      Constant.FORMAT_VERSION_141211 = 0x141211;

      Constant.HEADER_SIZE_COMPAT0 = 324;

      Constant.FORMAT_VERSION_COMPAT0_0 = 0x13;

      Constant.FORMAT_VERSION_COMPAT0_1 = 0x12;

      Constant.FORMAT_VERSION_COMPAT0_2 = 0x11;

      Constant.HEADER_SIZE_COMPAT1 = 324;

      Constant.FORMAT_VERSION_COMPAT1_0 = 0x12;

      Constant.FORMAT_VERSION_COMPAT1_1 = 0x10;

      Constant.FORMAT_VERSION_COMPAT1_2 = 0x10;

      Constant.FORMAT_TYPE = 0;

      Constant.OPTION_OFFSET = 7;

      Constant.OPTION_USE_SCRIPT = 1 << 0;

      Constant.OPTION_USE_TEXTUREATLAS = 1 << 1;

      Constant.OPTION_COMPRESSED = 1 << 2;

      Constant.OPTION_USE_LUASCRIPT = 1 << 3;

      Constant.MATRIX_FLAG = 1 << 31;

      Constant.COLORTRANSFORM_FLAG = 1 << 31;

      Constant.TEXTUREFORMAT_NORMAL = 0;

      Constant.TEXTUREFORMAT_PREMULTIPLIEDALPHA = 1;

      Constant.BLEND_MODE_NORMAL = 0;

      Constant.BLEND_MODE_ADD = 1;

      Constant.BLEND_MODE_LAYER = 2;

      Constant.BLEND_MODE_ERASE = 3;

      Constant.BLEND_MODE_MASK = 4;

      Constant.BLEND_MODE_MULTIPLY = 5;

      Constant.BLEND_MODE_SCREEN = 6;

      Constant.BLEND_MODE_SUBTRACT = 7;

      return Constant;

    })();

    Format.StringBase = (function() {
      function StringBase(stringId) {
        this.stringId = stringId;
      }

      return StringBase;

    })();

    Format.Texture = (function() {
      function Texture(stringId, format, width, height, scale) {
        this.stringId = stringId;
        this.format = format;
        this.width = width;
        this.height = height;
        this.scale = scale;
      }

      Texture.prototype.setFilename = function(data) {
        this.filename = data.strings[this.stringId];
      };

      return Texture;

    })();

    Format.TextureReplacement = (function() {
      function TextureReplacement(filename, format, width, height, scale) {
        this.filename = filename;
        this.format = format;
        this.width = width;
        this.height = height;
        this.scale = scale;
      }

      return TextureReplacement;

    })();

    Format.TextureFragment = (function() {
      function TextureFragment(stringId, textureId, rotated, x, y, u, v, w, h, ow, oh) {
        this.stringId = stringId;
        this.textureId = textureId;
        this.rotated = rotated;
        this.x = x;
        this.y = y;
        this.u = u;
        this.v = v;
        this.w = w;
        this.h = h;
        this.ow = ow;
        this.oh = oh;
      }

      TextureFragment.prototype.setFilename = function(data) {
        this.filename = data.strings[this.stringId];
      };

      return TextureFragment;

    })();

    Format.TextureFragmentReplacement = (function() {
      function TextureFragmentReplacement(filename, textureId, rotated, x, y, u, v, w, h, ow, oh) {
        this.filename = filename;
        this.textureId = textureId;
        this.rotated = rotated;
        this.x = x;
        this.y = y;
        this.u = u;
        this.v = v;
        this.w = w;
        this.h = h;
        this.ow = ow;
        this.oh = oh;
      }

      return TextureFragmentReplacement;

    })();

    Format.Bitmap = (function() {
      function Bitmap(matrixId, textureFragmentId) {
        this.matrixId = matrixId;
        this.textureFragmentId = textureFragmentId;
      }

      return Bitmap;

    })();

    Format.BitmapEx = (function() {
      BitmapEx.Attribute = (function() {
        function Attribute() {}

        Attribute.REPEAT_S = 1 << 0;

        Attribute.REPEAT_T = 1 << 1;

        return Attribute;

      })();

      function BitmapEx(matrixId, textureFragmentId, attribute, u, v, w, h) {
        this.matrixId = matrixId;
        this.textureFragmentId = textureFragmentId;
        this.attribute = attribute;
        this.u = u;
        this.v = v;
        this.w = w;
        this.h = h;
      }

      return BitmapEx;

    })();

    Format.Font = (function() {
      function Font(stringId, letterSpacing) {
        this.stringId = stringId;
        this.letterSpacing = letterSpacing;
      }

      return Font;

    })();

    Format.TextProperty = (function() {
      TextProperty.Align = (function() {
        function Align() {}

        Align.LEFT = 0;

        Align.RIGHT = 1;

        Align.CENTER = 2;

        Align.ALIGN_MASK = 0x3;

        Align.VERTICAL_BOTTOM = 1 << 2;

        Align.VERTICAL_MIDDLE = 2 << 2;

        Align.VERTICAL_MASK = 0xc;

        return Align;

      })();

      function TextProperty(maxLength, fontId, fontHeight, align, leftMargin, rightMargin, letterSpacing, leading, strokeColorId, strokeWidth, shadowColorId, shadowOffsetX, shadowOffsetY, shadowBlur) {
        this.maxLength = maxLength;
        this.fontId = fontId;
        this.fontHeight = fontHeight;
        this.align = align;
        this.leftMargin = leftMargin;
        this.rightMargin = rightMargin;
        this.letterSpacing = letterSpacing;
        this.leading = leading;
        this.strokeColorId = strokeColorId;
        this.strokeWidth = strokeWidth;
        this.shadowColorId = shadowColorId;
        this.shadowOffsetX = shadowOffsetX;
        this.shadowOffsetY = shadowOffsetY;
        this.shadowBlur = shadowBlur;
      }

      return TextProperty;

    })();

    Format.Text = (function() {
      function Text(matrixId, nameStringId, textPropertyId, stringId, colorId, width, height) {
        this.matrixId = matrixId;
        this.nameStringId = nameStringId;
        this.textPropertyId = textPropertyId;
        this.stringId = stringId;
        this.colorId = colorId;
        this.width = width;
        this.height = height;
      }

      return Text;

    })();

    Format.ParticleData = (function() {
      function ParticleData(stringId) {
        this.stringId = stringId;
      }

      return ParticleData;

    })();

    Format.Particle = (function() {
      function Particle(matrixId, colorTransformId, particleDataId) {
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
        this.particleDataId = particleDataId;
      }

      return Particle;

    })();

    Format.ProgramObject = (function(_super) {
      __extends(ProgramObject, _super);

      function ProgramObject(stringId, width, height, matrixId, colorTransformId) {
        this.width = width;
        this.height = height;
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
        ProgramObject.__super__.constructor.call(this, stringId);
      }

      return ProgramObject;

    })(Format.StringBase);

    Format.GraphicObject = (function() {
      GraphicObject.Type = (function() {
        function Type() {}

        Type.BITMAP = 0;

        Type.BITMAPEX = 1;

        Type.TEXT = 2;

        Type.GRAPHIC_OBJECT_MAX = 3;

        return Type;

      })();

      function GraphicObject(graphicObjectType, graphicObjectId) {
        this.graphicObjectType = graphicObjectType;
        this.graphicObjectId = graphicObjectId;
      }

      return GraphicObject;

    })();

    Format.Graphic = (function() {
      function Graphic(graphicObjectId, graphicObjects) {
        this.graphicObjectId = graphicObjectId;
        this.graphicObjects = graphicObjects;
      }

      return Graphic;

    })();

    Format.LObject = (function() {
      LObject.Type = (function() {
        function Type() {}

        Type.BUTTON = 0;

        Type.GRAPHIC = 1;

        Type.MOVIE = 2;

        Type.BITMAP = 3;

        Type.BITMAPEX = 4;

        Type.TEXT = 5;

        Type.PARTICLE = 6;

        Type.PROGRAMOBJECT = 7;

        Type.ATTACHEDMOVIE = 8;

        Type.OBJECT_MAX = 9;

        return Type;

      })();

      function LObject(objectType, objectId) {
        this.objectType = objectType;
        this.objectId = objectId;
      }

      return LObject;

    })();

    Format.Animation = (function() {
      function Animation(animationOffset, animationLength) {
        this.animationOffset = animationOffset;
        this.animationLength = animationLength;
      }

      return Animation;

    })();

    Format.ButtonCondition = (function() {
      ButtonCondition.Condition = (function() {
        function Condition() {}

        Condition.ROLLOVER = 1 << 0;

        Condition.ROLLOUT = 1 << 1;

        Condition.PRESS = 1 << 2;

        Condition.RELEASE = 1 << 3;

        Condition.DRAGOUT = 1 << 4;

        Condition.DRAGOVER = 1 << 5;

        Condition.RELEASEOUTSIDE = 1 << 6;

        Condition.KEYPRESS = 1 << 7;

        return Condition;

      })();

      function ButtonCondition(condition, keyCode, animationId) {
        this.condition = condition;
        this.keyCode = keyCode;
        this.animationId = animationId;
      }

      return ButtonCondition;

    })();

    Format.Button = (function() {
      function Button(width, height, matrixId, colorTransformId, conditionId, conditions) {
        this.width = width;
        this.height = height;
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
        this.conditionId = conditionId;
        this.conditions = conditions;
      }

      return Button;

    })();

    Format.Label = (function(_super) {
      __extends(Label, _super);

      function Label(stringId, frameNo) {
        this.frameNo = frameNo;
        Label.__super__.constructor.call(this, stringId);
      }

      return Label;

    })(Format.StringBase);

    Format.InstanceName = (function(_super) {
      __extends(InstanceName, _super);

      function InstanceName(stringId) {
        InstanceName.__super__.constructor.call(this, stringId);
      }

      return InstanceName;

    })(Format.StringBase);

    Format.Event = (function(_super) {
      __extends(Event, _super);

      function Event(stringId) {
        Event.__super__.constructor.call(this, stringId);
      }

      return Event;

    })(Format.StringBase);

    Format.String = (function() {
      function String(stringOffset, stringLength) {
        this.stringOffset = stringOffset;
        this.stringLength = stringLength;
      }

      return String;

    })();

    Format.Place = (function() {
      function Place(depth, objectId, instanceId, matrixId, blendMode) {
        this.depth = depth;
        this.objectId = objectId;
        this.instanceId = instanceId;
        this.matrixId = matrixId;
        this.blendMode = blendMode;
      }

      return Place;

    })();

    Format.ControlMoveM = (function() {
      function ControlMoveM(placeId, matrixId) {
        this.placeId = placeId;
        this.matrixId = matrixId;
      }

      return ControlMoveM;

    })();

    Format.ControlMoveC = (function() {
      function ControlMoveC(placeId, colorTransformId) {
        this.placeId = placeId;
        this.colorTransformId = colorTransformId;
      }

      return ControlMoveC;

    })();

    Format.ControlMoveMC = (function() {
      function ControlMoveMC(placeId, matrixId, colorTransformId) {
        this.placeId = placeId;
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
      }

      return ControlMoveMC;

    })();

    Format.ControlMoveMCB = (function() {
      function ControlMoveMCB(placeId, matrixId, colorTransformId, blendMode) {
        this.placeId = placeId;
        this.matrixId = matrixId;
        this.colorTransformId = colorTransformId;
        this.blendMode = blendMode;
      }

      return ControlMoveMCB;

    })();

    Format.Control = (function() {
      Control.Type = (function() {
        function Type() {}

        Type.MOVE = 0;

        Type.MOVEM = 1;

        Type.MOVEC = 2;

        Type.MOVEMC = 3;

        Type.ANIMATION = 4;

        Type.MOVEMCB = 5;

        Type.CONTROL_MAX = 6;

        return Type;

      })();

      function Control(controlType, controlId) {
        this.controlType = controlType;
        this.controlId = controlId;
      }

      return Control;

    })();

    Format.Frame = (function() {
      function Frame(controlOffset, controls) {
        this.controlOffset = controlOffset;
        this.controls = controls;
      }

      return Frame;

    })();

    Format.MovieClipEvent = (function() {
      MovieClipEvent.ClipEvent = (function() {
        function ClipEvent() {}

        ClipEvent.LOAD = 1 << 0;

        ClipEvent.UNLOAD = 1 << 1;

        ClipEvent.ENTERFRAME = 1 << 2;

        return ClipEvent;

      })();

      function MovieClipEvent(clipEvent, animationId) {
        this.clipEvent = clipEvent;
        this.animationId = animationId;
      }

      return MovieClipEvent;

    })();

    Format.Movie = (function() {
      function Movie(depths, labelOffset, labels, frameOffset, frames, clipEventId, clipEvents) {
        this.depths = depths;
        this.labelOffset = labelOffset;
        this.labels = labels;
        this.frameOffset = frameOffset;
        this.frames = frames;
        this.clipEventId = clipEventId;
        this.clipEvents = clipEvents;
      }

      return Movie;

    })();

    Format.MovieLinkage = (function(_super) {
      __extends(MovieLinkage, _super);

      function MovieLinkage(stringId, movieId) {
        this.movieId = movieId;
        MovieLinkage.__super__.constructor.call(this, stringId);
      }

      return MovieLinkage;

    })(Format.StringBase);

    Format.ItemArray = (function() {
      function ItemArray(offset, length) {
        this.offset = offset;
        this.length = length;
      }

      return ItemArray;

    })();

    Format.Header = (function() {
      function Header(id0, id1, id2, id3, formatVersion0, formatVersion1, formatVersion2, formatVersion, option, width, height, frameRate, rootMovieId, nameStringId, backgroundColor, stringBytes, animationBytes, translate, matrix, color, alphaTransform, colorTransform, objectData, texture, textureFragment, bitmap, bitmapEx, font, textProperty, text, particleData, particle, programObject, graphicObject, graphic, animation, buttonCondition, button, label, instanceName, eventData, place, controlMoveM, controlMoveC, controlMoveMC, controlMoveMCB, control, frame, movieClipEvent, movie, movieLinkage, stringData, lwfLength) {
        this.id0 = id0;
        this.id1 = id1;
        this.id2 = id2;
        this.id3 = id3;
        this.formatVersion0 = formatVersion0;
        this.formatVersion1 = formatVersion1;
        this.formatVersion2 = formatVersion2;
        this.formatVersion = formatVersion;
        this.option = option;
        this.width = width;
        this.height = height;
        this.frameRate = frameRate;
        this.rootMovieId = rootMovieId;
        this.nameStringId = nameStringId;
        this.backgroundColor = backgroundColor;
        this.stringBytes = stringBytes;
        this.animationBytes = animationBytes;
        this.translate = translate;
        this.matrix = matrix;
        this.color = color;
        this.alphaTransform = alphaTransform;
        this.colorTransform = colorTransform;
        this.objectData = objectData;
        this.texture = texture;
        this.textureFragment = textureFragment;
        this.bitmap = bitmap;
        this.bitmapEx = bitmapEx;
        this.font = font;
        this.textProperty = textProperty;
        this.text = text;
        this.particleData = particleData;
        this.particle = particle;
        this.programObject = programObject;
        this.graphicObject = graphicObject;
        this.graphic = graphic;
        this.animation = animation;
        this.buttonCondition = buttonCondition;
        this.button = button;
        this.label = label;
        this.instanceName = instanceName;
        this.eventData = eventData;
        this.place = place;
        this.controlMoveM = controlMoveM;
        this.controlMoveC = controlMoveC;
        this.controlMoveMC = controlMoveMC;
        this.controlMoveMCB = controlMoveMCB;
        this.control = control;
        this.frame = frame;
        this.movieClipEvent = movieClipEvent;
        this.movie = movie;
        this.movieLinkage = movieLinkage;
        this.stringData = stringData;
        this.lwfLength = lwfLength;
      }

      return Header;

    })();

    return Format;

  })();

  Align = Format.TextProperty.Align;

  ClipEvent = Format.MovieClipEvent.ClipEvent;

  Condition = Format.ButtonCondition.Condition;

  Constant = Format.Constant;

  Type = Format.LObject.Type;

  ControlType = Format.Control.Type;

  GObjType = Format.GraphicObject.Type;

  Animation = (function() {
    function Animation() {}

    Animation.END = 0;

    Animation.PLAY = 1;

    Animation.STOP = 2;

    Animation.NEXTFRAME = 3;

    Animation.PREVFRAME = 4;

    Animation.GOTOFRAME = 5;

    Animation.GOTOLABEL = 6;

    Animation.SETTARGET = 7;

    Animation.EVENT = 8;

    Animation.CALL = 9;

    Animation.INSTANCE_TARGET_ROOT = -1;

    Animation.INSTANCE_TARGET_PARENT = -2;

    return Animation;

  })();

  Data = (function() {
    function Data(header, translates, matrices, colors, alphaTransforms, colorTransforms, objects, textures, textureFragments, bitmaps, bitmapExs, fonts, textProperties, texts, particleDatas, particles, programObjects, graphicObjects, graphics, animations, buttonConditions, buttons, labels, instanceNames, events, places, controlMoveMs, controlMoveCs, controlMoveMCs, controlMoveMCBs, controls, frames, movieClipEvents, movies, movieLinkages, strings) {
      var a, c, d, m, t;
      this.header = header;
      this.translates = translates;
      this.matrices = matrices;
      this.colors = colors;
      this.alphaTransforms = alphaTransforms;
      this.colorTransforms = colorTransforms;
      this.objects = objects;
      this.textures = textures;
      this.textureFragments = textureFragments;
      this.bitmaps = bitmaps;
      this.bitmapExs = bitmapExs;
      this.fonts = fonts;
      this.textProperties = textProperties;
      this.texts = texts;
      this.particleDatas = particleDatas;
      this.particles = particles;
      this.programObjects = programObjects;
      this.graphicObjects = graphicObjects;
      this.graphics = graphics;
      this.animations = animations;
      this.buttonConditions = buttonConditions;
      this.buttons = buttons;
      this.labels = labels;
      this.instanceNames = instanceNames;
      this.events = events;
      this.places = places;
      this.controlMoveMs = controlMoveMs;
      this.controlMoveCs = controlMoveCs;
      this.controlMoveMCs = controlMoveMCs;
      this.controlMoveMCBs = controlMoveMCBs;
      this.controls = controls;
      this.frames = frames;
      this.movieClipEvents = movieClipEvents;
      this.movies = movies;
      this.movieLinkages = movieLinkages;
      this.strings = strings;
      if (this.header.header != null) {
        d = this.header;
        this.header = d.header;
        this.translates = (function() {
          var _i, _len, _ref, _results;
          _ref = d.translates;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            t = _ref[_i];
            _results.push(new Translate(t._[0], t._[1]));
          }
          return _results;
        })();
        this.matrices = (function() {
          var _i, _len, _ref, _results;
          _ref = d.matrices;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            m = _ref[_i];
            _results.push(new Matrix(m._[0], m._[3], m._[2], m._[1], m._[4], m._[5]));
          }
          return _results;
        })();
        this.colors = (function() {
          var _i, _len, _ref, _results;
          _ref = d.colors;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(new Color(c._[0], c._[1], c._[2], c._[3]));
          }
          return _results;
        })();
        this.alphaTransforms = (function() {
          var _i, _len, _ref, _results;
          _ref = d.alphaTransforms;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            a = _ref[_i];
            _results.push(new AlphaTransform(a._[0]));
          }
          return _results;
        })();
        this.colorTransforms = (function() {
          var _i, _len, _ref, _results;
          _ref = d.colorTransforms;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(new ColorTransform(c.multi._[0], c.multi._[1], c.multi._[2], c.multi._[3], c.add._[0], c.add._[1], c.add._[2], c.add._[3]));
          }
          return _results;
        })();
        this.objects = d.objects;
        this.textures = d.textures;
        this.textureFragments = d.textureFragments;
        this.bitmaps = d.bitmaps;
        this.bitmapExs = d.bitmapExs;
        this.fonts = d.fonts;
        this.textProperties = d.textProperties;
        this.texts = d.texts;
        this.particleDatas = d.particleDatas;
        this.particles = d.particles;
        this.programObjects = d.programObjects;
        this.graphicObjects = d.graphicObjects;
        this.graphics = d.graphics;
        this.animations = d.animations;
        this.buttonConditions = d.buttonConditions;
        this.buttons = d.buttons;
        this.labels = d.labels;
        this.instanceNames = d.instanceNames;
        this.events = d.events;
        this.places = d.places;
        this.controlMoveMs = d.controlMoveMs;
        this.controlMoveCs = d.controlMoveCs;
        this.controlMoveMCs = d.controlMoveMCs;
        this.controlMoveMCBs = d.controlMoveMCBs;
        this.controls = d.controls;
        this.frames = d.frames;
        this.movieClipEvents = d.movieClipEvents;
        this.movies = d.movies;
        this.movieLinkages = d.movieLinkages;
        this.strings = d.strings;
        this.stringMap = d.stringMap;
        this.eventMap = d.eventMap;
        this.instanceNameMap = d.instanceNameMap;
        this.movieLinkageMap = d.movieLinkageMap;
        this.movieLinkageNameMap = d.movieLinkageNameMap;
        this.programObjectMap = d.programObjectMap;
        this.labelMap = d.labelMap;
        this.bitmapMap = d.bitmapMap;
        this.useScript = d.useScript;
        this.useTextureAtlas = d.useTextureAtlas;
      } else {
        this.stringMap = {};
        this.eventMap = {};
        this.instanceNameMap = {};
        this.movieLinkageMap = {};
        this.movieLinkageNameMap = {};
        this.programObjectMap = {};
        this.labelMap = [];
        this.bitmapMap = {};
        if (this.header != null) {
          this.useScript = (this.header.option & Format.Constant.OPTION_USE_SCRIPT) !== 0;
          this.useTextureAtlas = (this.header.option & Format.Constant.OPTION_USE_TEXTUREATLAS) !== 0;
        } else {
          this.useScript = false;
          this.useTextureAtlas = false;
        }
      }
    }

    Data.prototype.check = function() {
      var v0, v1, v2;
      v0 = this.header.formatVersion0;
      v1 = this.header.formatVersion1;
      v2 = this.header.formatVersion2;
      if ((this.header != null) && this.header.id0 === 'L' && this.header.id1 === 'W' && this.header.id2 === 'F' && ((v0 === Format.Constant.FORMAT_VERSION_0 && v1 === Format.Constant.FORMAT_VERSION_1 && v2 === Format.Constant.FORMAT_VERSION_2) || (v0 === Format.Constant.FORMAT_VERSION_COMPAT0_0 && v1 === Format.Constant.FORMAT_VERSION_COMPAT0_1 && v2 === Format.Constant.FORMAT_VERSION_COMPAT0_2) || (v0 === Format.Constant.FORMAT_VERSION_COMPAT1_0 && v1 === Format.Constant.FORMAT_VERSION_COMPAT1_1 && v2 === Format.Constant.FORMAT_VERSION_COMPAT1_2))) {
        return true;
      } else {
        return false;
      }
    };

    Data.prototype.name = function() {
      return this.strings[this.header.nameStringId];
    };

    Data.prototype.replaceTexture = function(index, textureReplacement) {
      if (index < 0 || index >= textures.length) {
        return false;
      }
      textures[index] = textureReplacement;
      return true;
    };

    Data.prototype.replaceTextureFragment = function(index, textureFragmentReplacement) {
      if (index < 0 || index >= textureFragments.length) {
        return false;
      }
      textureFragments[index] = textureFragmentReplacement;
      return true;
    };

    return Data;

  })();

  LWFLoader = (function() {
    function LWFLoader() {}

    LWFLoader.prototype.readByte = function() {
      return this.d.charCodeAt(this.index++) & 0xff;
    };

    LWFLoader.prototype.readChar = function() {
      return String.fromCharCode(this.readByte());
    };

    LWFLoader.prototype.readBytes = function(length) {
      var bytes;
      bytes = this.d.substr(this.index, length);
      this.index += length;
      return bytes;
    };

    LWFLoader.prototype.readInt32 = function() {
      return (this.readByte() << 0) + (this.readByte() << 8) + (this.readByte() << 16) + (this.readByte() << 24);
    };

    LWFLoader.prototype.readSingle = function() {
      var b0, b1, b2, b3, exp, sig, sign;
      b3 = this.readByte();
      b2 = this.readByte();
      b1 = this.readByte();
      b0 = this.readByte();
      sign = 1 - (2 * (b0 >> 7));
      exp = (((b0 << 1) & 0xff) | (b1 >> 7)) - 127;
      sig = ((b1 & 0x7f) << 16) | (b2 << 8) | b3;
      if (sig === 0 && exp === -127) {
        return 0.0;
      }
      return sign * (1 + sig * Math.pow(2, -23)) * Math.pow(2, exp);
    };

    LWFLoader.prototype.loadTranslate = function() {
      return new Translate(this.readSingle(), this.readSingle());
    };

    LWFLoader.prototype.loadMatrix = function() {
      return new Matrix(this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle());
    };

    LWFLoader.prototype.loadColor = function() {
      return new Color(this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle());
    };

    LWFLoader.prototype.loadAlphaTransform = function() {
      return new AlphaTransform(this.readSingle());
    };

    LWFLoader.prototype.loadColorTransform = function() {
      var add, multi;
      multi = this.loadColor();
      add = this.loadColor();
      return new ColorTransform(multi.red, multi.green, multi.blue, multi.alpha, add.red, add.green, add.blue, add.alpha);
    };

    LWFLoader.prototype.loadTexture = function() {
      return new Format.Texture(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readSingle());
    };

    LWFLoader.prototype.loadTextureFragment = function() {
      return new Format.TextureFragment(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadTextureFragmentCompat = function() {
      var h, oh, ow, rotated, stringId, textureId, u, v, w, x, y;
      stringId = this.readInt32();
      textureId = this.readInt32();
      rotated = this.readInt32();
      x = this.readInt32();
      y = this.readInt32();
      u = this.readInt32();
      v = this.readInt32();
      w = this.readInt32();
      h = this.readInt32();
      ow = w;
      oh = h;
      return new Format.TextureFragment(stringId, textureId, rotated, x, y, u, v, w, h, ow, oh);
    };

    LWFLoader.prototype.loadBitmap = function() {
      return new Format.Bitmap(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadBitmapEx = function() {
      return new Format.BitmapEx(this.readInt32(), this.readInt32(), this.readInt32(), this.readSingle(), this.readSingle(), this.readSingle(), this.readSingle());
    };

    LWFLoader.prototype.loadFont = function() {
      return new Format.Font(this.readInt32(), this.readSingle());
    };

    LWFLoader.prototype.loadTextProperty = function() {
      return new Format.TextProperty(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readSingle(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadText = function() {
      return new Format.Text(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadParticleData = function() {
      return new Format.ParticleData(this.readInt32());
    };

    LWFLoader.prototype.loadParticle = function() {
      return new Format.Particle(this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadProgramObject = function() {
      return new Format.ProgramObject(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadGraphicObject = function() {
      return new Format.GraphicObject(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadGraphic = function() {
      return new Format.Graphic(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadObject = function() {
      return new Format.LObject(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadAnimation = function() {
      return new Format.Animation(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadButtonCondition = function() {
      return new Format.ButtonCondition(this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadButton = function() {
      return new Format.Button(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadLabel = function() {
      return new Format.Label(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadInstanceName = function() {
      return new Format.InstanceName(this.readInt32());
    };

    LWFLoader.prototype.loadEvent = function() {
      return new Format.Event(this.readInt32());
    };

    LWFLoader.prototype.loadString = function() {
      return new Format.String(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadPlace = function() {
      var v0, v1, v2, v3;
      v0 = this.readInt32();
      v1 = this.readInt32();
      v2 = this.readInt32();
      v3 = this.readInt32();
      return new Format.Place(v0 & 0xffffff, v1, v2, v3, v0 >> 24);
    };

    LWFLoader.prototype.loadControlMoveM = function() {
      return new Format.ControlMoveM(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadControlMoveC = function() {
      return new Format.ControlMoveC(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadControlMoveMC = function() {
      return new Format.ControlMoveMC(this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadControlMoveMCB = function() {
      return new Format.ControlMoveMCB(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadControl = function() {
      return new Format.Control(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadFrame = function() {
      return new Format.Frame(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadMovieClipEvent = function() {
      return new Format.MovieClipEvent(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadMovie = function() {
      return new Format.Movie(this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadMovieLinkage = function() {
      return new Format.MovieLinkage(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadItemArray = function() {
      return new Format.ItemArray(this.readInt32(), this.readInt32());
    };

    LWFLoader.prototype.loadHeader = function() {
      var alphaTransform, animation, animationBytes, backgroundColor, bitmap, bitmapEx, button, buttonCondition, color, colorTransform, control, controlMoveC, controlMoveM, controlMoveMC, controlMoveMCB, eventData, font, formatVersion, formatVersion0, formatVersion1, formatVersion2, frame, frameRate, graphic, graphicObject, height, id0, id1, id2, id3, instanceName, label, lwfLength, matrix, movie, movieClipEvent, movieLinkage, nameStringId, objectData, option, particle, particleData, place, programObject, rootMovieId, stringBytes, stringData, text, textProperty, texture, textureFragment, translate, width;
      id0 = this.readChar();
      id1 = this.readChar();
      id2 = this.readChar();
      id3 = this.readChar();
      formatVersion0 = this.readByte();
      formatVersion1 = this.readByte();
      formatVersion2 = this.readByte();
      formatVersion = (formatVersion0 << 16) | (formatVersion1 << 8) | formatVersion2;
      option = this.readByte();
      width = this.readInt32();
      height = this.readInt32();
      frameRate = this.readInt32();
      rootMovieId = this.readInt32();
      nameStringId = this.readInt32();
      backgroundColor = this.readInt32();
      stringBytes = this.loadItemArray();
      animationBytes = this.loadItemArray();
      translate = this.loadItemArray();
      matrix = this.loadItemArray();
      color = this.loadItemArray();
      alphaTransform = this.loadItemArray();
      colorTransform = this.loadItemArray();
      objectData = this.loadItemArray();
      texture = this.loadItemArray();
      textureFragment = this.loadItemArray();
      bitmap = this.loadItemArray();
      bitmapEx = this.loadItemArray();
      font = this.loadItemArray();
      textProperty = this.loadItemArray();
      text = this.loadItemArray();
      particleData = this.loadItemArray();
      particle = this.loadItemArray();
      programObject = this.loadItemArray();
      graphicObject = this.loadItemArray();
      graphic = this.loadItemArray();
      animation = this.loadItemArray();
      buttonCondition = this.loadItemArray();
      button = this.loadItemArray();
      label = this.loadItemArray();
      instanceName = this.loadItemArray();
      eventData = this.loadItemArray();
      place = this.loadItemArray();
      controlMoveM = this.loadItemArray();
      controlMoveC = this.loadItemArray();
      controlMoveMC = this.loadItemArray();
      controlMoveMCB = null;
      if (formatVersion >= Format.Constant.FORMAT_VERSION_141211) {
        controlMoveMCB = this.loadItemArray();
      } else {
        controlMoveMCB = new Format.ItemArray(0, 0);
      }
      control = this.loadItemArray();
      frame = this.loadItemArray();
      movieClipEvent = this.loadItemArray();
      movie = this.loadItemArray();
      movieLinkage = this.loadItemArray();
      stringData = this.loadItemArray();
      lwfLength = this.readInt32();
      return new Format.Header(id0, id1, id2, id3, formatVersion0, formatVersion1, formatVersion2, formatVersion, option, width, height, frameRate, rootMovieId, nameStringId, backgroundColor, stringBytes, animationBytes, translate, matrix, color, alphaTransform, colorTransform, objectData, texture, textureFragment, bitmap, bitmapEx, font, textProperty, text, particleData, particle, programObject, graphicObject, graphic, animation, buttonCondition, button, label, instanceName, eventData, place, controlMoveM, controlMoveC, controlMoveMC, controlMoveMCB, control, frame, movieClipEvent, movie, movieLinkage, stringData, lwfLength);
    };

    LWFLoader.prototype.load = function(d) {
      var a, animationBytes, animations, bitmapMap, c, c2, c3, c4, code, data, eventMap, filename, header, i, instanceNameMap, l, labelMap, m, map, movieLinkageMap, movieLinkageNameMap, o, programObjectMap, s, str, stringBytes, stringDatas, stringMap, t, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _s;
      this.d = d;
      this.index = 0;
      header = this.loadHeader();
      data = new Data(header);
      if (!data.check()) {
        return null;
      }
      stringBytes = this.readBytes(header.stringBytes.length);
      animationBytes = this.readBytes(header.animationBytes.length);
      data.translates = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.translate.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadTranslate());
        }
        return _results;
      }).call(this);
      data.matrices = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.matrix.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadMatrix());
        }
        return _results;
      }).call(this);
      data.colors = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.color.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadColor());
        }
        return _results;
      }).call(this);
      data.alphaTransforms = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.alphaTransform.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadAlphaTransform());
        }
        return _results;
      }).call(this);
      data.colorTransforms = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.colorTransform.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadColorTransform());
        }
        return _results;
      }).call(this);
      data.objects = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.objectData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadObject());
        }
        return _results;
      }).call(this);
      data.textures = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.texture.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadTexture());
        }
        return _results;
      }).call(this);
      if (header.formatVersion >= Format.Constant.FORMAT_VERSION_141211) {
        data.textureFragments = (function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = header.textureFragment.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(this.loadTextureFragment());
          }
          return _results;
        }).call(this);
      } else {
        data.textureFragments = (function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = header.textureFragment.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(this.loadTextureFragmentCompat());
          }
          return _results;
        }).call(this);
      }
      data.bitmaps = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.bitmap.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadBitmap());
        }
        return _results;
      }).call(this);
      data.bitmapExs = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.bitmapEx.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadBitmapEx());
        }
        return _results;
      }).call(this);
      data.fonts = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.font.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadFont());
        }
        return _results;
      }).call(this);
      data.textProperties = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.textProperty.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadTextProperty());
        }
        return _results;
      }).call(this);
      data.texts = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadText());
        }
        return _results;
      }).call(this);
      data.particleDatas = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.particleData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadParticleData());
        }
        return _results;
      }).call(this);
      data.particles = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.particle.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadParticle());
        }
        return _results;
      }).call(this);
      data.programObjects = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.programObject.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadProgramObject());
        }
        return _results;
      }).call(this);
      data.graphicObjects = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.graphicObject.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadGraphicObject());
        }
        return _results;
      }).call(this);
      data.graphics = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.graphic.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadGraphic());
        }
        return _results;
      }).call(this);
      animations = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.animation.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadAnimation());
        }
        return _results;
      }).call(this);
      data.buttonConditions = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.buttonCondition.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadButtonCondition());
        }
        return _results;
      }).call(this);
      data.buttons = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.button.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadButton());
        }
        return _results;
      }).call(this);
      data.labels = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.label.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadLabel());
        }
        return _results;
      }).call(this);
      data.instanceNames = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.instanceName.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadInstanceName());
        }
        return _results;
      }).call(this);
      data.events = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.eventData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadEvent());
        }
        return _results;
      }).call(this);
      data.places = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.place.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadPlace());
        }
        return _results;
      }).call(this);
      data.controlMoveMs = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.controlMoveM.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControlMoveM());
        }
        return _results;
      }).call(this);
      data.controlMoveCs = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.controlMoveC.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControlMoveC());
        }
        return _results;
      }).call(this);
      data.controlMoveMCs = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.controlMoveMC.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControlMoveMC());
        }
        return _results;
      }).call(this);
      data.controlMoveMCBs = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.controlMoveMCB.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControlMoveMCB());
        }
        return _results;
      }).call(this);
      data.controls = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.control.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadControl());
        }
        return _results;
      }).call(this);
      data.frames = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.frame.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadFrame());
        }
        return _results;
      }).call(this);
      data.movieClipEvents = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.movieClipEvent.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadMovieClipEvent());
        }
        return _results;
      }).call(this);
      data.movies = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.movie.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadMovie());
        }
        return _results;
      }).call(this);
      data.movieLinkages = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.movieLinkage.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadMovieLinkage());
        }
        return _results;
      }).call(this);
      stringDatas = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = header.stringData.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.loadString());
        }
        return _results;
      }).call(this);
      data.animations = [];
      for (_i = 0, _len = animations.length; _i < _len; _i++) {
        a = animations[_i];
        o = a.animationOffset;
        data.animations.push(this.readAnimation(animationBytes.slice(o, o + a.animationLength)));
      }
      data.strings = [];
      stringMap = data.stringMap;
      for (_j = 0, _len1 = stringDatas.length; _j < _len1; _j++) {
        a = stringDatas[_j];
        o = a.stringOffset;
        s = stringBytes.slice(o, o + a.stringLength);
        str = "";
        i = 0;
        while (i < s.length) {
          c = s.charCodeAt(i) & 255;
          if (c < 128) {
            str += String.fromCharCode(c);
            ++i;
          } else if ((c >> 5) === 6) {
            c2 = s.charCodeAt(i + 1);
            str += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
          } else if ((c >> 4) === 14) {
            c2 = s.charCodeAt(i + 1);
            c3 = s.charCodeAt(i + 2);
            code = ((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63);
            str += String.fromCharCode(code);
            i += 3;
          } else {
            c2 = s.charCodeAt(i + 1);
            c3 = s.charCodeAt(i + 2);
            c4 = s.charCodeAt(i + 3);
            code = ((c & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 << 63);
            str += String.fromCharCode(code);
            i += 4;
          }
        }
        stringMap[str] = data.strings.length;
        data.strings.push(str);
      }
      instanceNameMap = data.instanceNameMap;
      for (i = _k = 0, _ref = data.instanceNames.length; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
        instanceNameMap[data.instanceNames[i].stringId] = i;
      }
      eventMap = data.eventMap;
      for (i = _l = 0, _ref1 = data.events.length; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; i = 0 <= _ref1 ? ++_l : --_l) {
        eventMap[data.events[i].stringId] = i;
      }
      movieLinkageMap = data.movieLinkageMap;
      for (i = _m = 0, _ref2 = data.movieLinkages.length; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; i = 0 <= _ref2 ? ++_m : --_m) {
        movieLinkageMap[data.movieLinkages[i].stringId] = i;
      }
      movieLinkageNameMap = data.movieLinkageNameMap;
      for (i = _n = 0, _ref3 = data.movieLinkages.length; 0 <= _ref3 ? _n < _ref3 : _n > _ref3; i = 0 <= _ref3 ? ++_n : --_n) {
        movieLinkageNameMap[data.movieLinkages[i].movieId] = data.movieLinkages[i].stringId;
      }
      programObjectMap = data.programObjectMap;
      for (i = _o = 0, _ref4 = data.programObjects.length; 0 <= _ref4 ? _o < _ref4 : _o > _ref4; i = 0 <= _ref4 ? ++_o : --_o) {
        programObjectMap[data.programObjects[i].stringId] = i;
      }
      labelMap = data.labelMap;
      _ref5 = data.movies;
      for (_p = 0, _len2 = _ref5.length; _p < _len2; _p++) {
        m = _ref5[_p];
        o = m.labelOffset;
        map = {};
        _ref6 = data.labels.slice(o, o + m.labels);
        for (_q = 0, _len3 = _ref6.length; _q < _len3; _q++) {
          l = _ref6[_q];
          map[l.stringId] = l.frameNo;
        }
        labelMap.push(map);
      }
      _ref7 = data.textures;
      for (_r = 0, _len4 = _ref7.length; _r < _len4; _r++) {
        t = _ref7[_r];
        t.setFilename(data);
      }
      bitmapMap = data.bitmapMap;
      for (i = _s = 0, _ref8 = data.textureFragments.length; 0 <= _ref8 ? _s < _ref8 : _s > _ref8; i = 0 <= _ref8 ? ++_s : --_s) {
        t = data.textureFragments[i];
        t.setFilename(data);
        filename = t.filename;
        m = filename.match(/(.+)_atlas_.+_info_.+(_.+){6}/);
        if (m != null) {
          filename = m[1];
        }
        bitmapMap[filename] = data.bitmaps.length;
        data.bitmaps.push(new Format.Bitmap(0, i));
      }
      return data;
    };

    LWFLoader.prototype.readByteFromBytes = function(bytes, index) {
      var b;
      b = bytes.charCodeAt(index++) & 0xff;
      return [index, b];
    };

    LWFLoader.prototype.readInt32FromBytes = function(bytes, index) {
      var b0, b1, b2, b3, i, _ref, _ref1, _ref2, _ref3;
      _ref = this.readByteFromBytes(bytes, index), index = _ref[0], b0 = _ref[1];
      _ref1 = this.readByteFromBytes(bytes, index), index = _ref1[0], b1 = _ref1[1];
      _ref2 = this.readByteFromBytes(bytes, index), index = _ref2[0], b2 = _ref2[1];
      _ref3 = this.readByteFromBytes(bytes, index), index = _ref3[0], b3 = _ref3[1];
      i = (b0 << 0) + (b1 << 8) + (b2 << 16) + (b3 << 24);
      return [index, i];
    };

    LWFLoader.prototype.readAnimation = function(bytes) {
      var array, code, count, i, index, target, _i, _ref, _ref1, _ref2, _ref3;
      array = [];
      index = 0;
      while (true) {
        _ref = this.readByteFromBytes(bytes, index), index = _ref[0], code = _ref[1];
        array.push(code);
        switch (code) {
          case Animation.GOTOFRAME:
          case Animation.GOTOLABEL:
          case Animation.EVENT:
          case Animation.CALL:
            _ref1 = this.readInt32FromBytes(bytes, index), index = _ref1[0], i = _ref1[1];
            array.push(i);
            break;
          case Animation.SETTARGET:
            _ref2 = this.readInt32FromBytes(bytes, index), index = _ref2[0], count = _ref2[1];
            array.push(count);
            for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
              _ref3 = this.readInt32FromBytes(bytes, index), index = _ref3[0], target = _ref3[1];
              array.push(target);
            }
            break;
          case Animation.END:
            return array;
        }
      }
    };

    return LWFLoader;

  })();

  LWFLoaderWithArray = (function(_super) {
    __extends(LWFLoaderWithArray, _super);

    function LWFLoaderWithArray() {
      return LWFLoaderWithArray.__super__.constructor.apply(this, arguments);
    }

    LWFLoaderWithArray.prototype.readByte = function() {
      return this.d[this.index++];
    };

    LWFLoaderWithArray.prototype.readBytes = function(length) {
      var bytes, i, _i;
      bytes = "";
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        bytes += String.fromCharCode(this.d[this.index++]);
      }
      return bytes;
    };

    return LWFLoaderWithArray;

  })(LWFLoader);

  LWFLoaderWithArrayBuffer = (function(_super) {
    __extends(LWFLoaderWithArrayBuffer, _super);

    function LWFLoaderWithArrayBuffer() {
      this.int32Array = new Int32Array();
      this.float32Array = new Float32Array();
    }

    LWFLoaderWithArrayBuffer.prototype.readByte = function() {
      return this.d[this.index++];
    };

    LWFLoaderWithArrayBuffer.prototype.readBytes = function(length) {
      var bytes, i, _i;
      bytes = "";
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        bytes += String.fromCharCode(this.d[this.index++]);
      }
      return bytes;
    };

    LWFLoaderWithArrayBuffer.prototype.readInt32 = function() {
      var i;
      i = this.dInt32[this.index / 4];
      this.index += 4;
      return i;
    };

    LWFLoaderWithArrayBuffer.prototype.readSingle = function() {
      var f;
      f = this.dFloat32[this.index / 4];
      this.index += 4;
      return f;
    };

    LWFLoaderWithArrayBuffer.prototype.load = function(d) {
      this.d = new Uint8Array(d);
      this.dInt32 = new Int32Array(d);
      this.dFloat32 = new Float32Array(d);
      return LWFLoaderWithArrayBuffer.__super__.load.call(this, this.d);
    };

    return LWFLoaderWithArrayBuffer;

  })(LWFLoader);

  Loader = (function() {
    function Loader() {}

    Loader.load = function(d) {
      var lwfLoader;
      if ((d == null) || typeof d !== "string") {
        return;
      }
      lwfLoader = new LWFLoader;
      return lwfLoader.load(d);
    };

    Loader.loadArray = function(d) {
      var lwfLoader;
      if (d == null) {
        return;
      }
      lwfLoader = new LWFLoaderWithArray;
      return lwfLoader.load(d);
    };

    Loader.loadArrayBuffer = function(d) {
      var lwfLoader;
      if (d == null) {
        return;
      }
      lwfLoader = new LWFLoaderWithArrayBuffer;
      return lwfLoader.load(d);
    };

    return Loader;

  })();

  Utility = (function() {
    function Utility() {}

    Utility.calcMatrixToPoint = function(sx, sy, m) {
      var dx, dy, mm;
      mm = m._;
      dx = mm[0] * sx + mm[2] * sy + mm[4];
      dy = mm[1] * sx + mm[3] * sy + mm[5];
      return [dx, dy];
    };

    Utility.getMatrixDeterminant = function(matrix) {
      var mm;
      mm = matrix._;
      return mm[0] * mm[3] - mm[2] * mm[1] < 0;
    };

    Utility.syncMatrix = function(movie) {
      var matrix, matrixId, md, mm, rotation, scaleX, scaleY, t, translate, _ref;
      matrixId = (_ref = movie.matrixId) != null ? _ref : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        translate = movie.lwf.data.translates[matrixId];
        scaleX = 1;
        scaleY = 1;
        rotation = 0;
        t = translate._;
        matrix = new Matrix(scaleX, scaleY, 0, 0, t[0], t[1]);
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        md = this.getMatrixDeterminant(matrix);
        mm = matrix._;
        scaleX = Math.sqrt(mm[0] * mm[0] + mm[1] * mm[1]);
        if (md) {
          scaleX = -scaleX;
        }
        scaleY = Math.sqrt(mm[3] * mm[3] + mm[2] * mm[2]);
        if (md) {
          rotation = Math.atan2(mm[1], -mm[0]);
        } else {
          rotation = Math.atan2(mm[1], mm[0]);
        }
        rotation = rotation / Math.PI * 180;
      }
      movie.property.setMatrix(matrix, scaleX, scaleY, rotation);
    };

    Utility.getX = function(movie) {
      var matrix, matrixId, translate, _ref;
      matrixId = (_ref = movie.matrixId) != null ? _ref : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        translate = movie.lwf.data.translates[matrixId];
        return translate._[0];
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        return matrix._[4];
      }
    };

    Utility.getY = function(movie) {
      var matrix, matrixId, translate, _ref;
      matrixId = (_ref = movie.matrixId) != null ? _ref : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        translate = movie.lwf.data.translates[matrixId];
        return translate._[1];
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        return matrix._[5];
      }
    };

    Utility.getScaleX = function(movie) {
      var matrix, matrixId, md, mm, scaleX, _ref;
      matrixId = (_ref = movie.matrixId) != null ? _ref : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        return 1;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        md = this.getMatrixDeterminant(matrix);
        mm = matrix._;
        scaleX = Math.sqrt(mm[0] * mm[0] + mm[1] * mm[1]);
        if (md) {
          scaleX = -scaleX;
        }
        return scaleX;
      }
    };

    Utility.getScaleY = function(movie) {
      var matrix, matrixId, mm, scaleY, _ref;
      matrixId = (_ref = movie.matrixId) != null ? _ref : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        return 1;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        mm = matrix._;
        scaleY = Math.sqrt(mm[3] * mm[3] + mm[2] * mm[2]);
        return scaleY;
      }
    };

    Utility.getRotation = function(movie) {
      var matrix, matrixId, md, mm, rotation, _ref;
      matrixId = (_ref = movie.matrixId) != null ? _ref : 0;
      if ((matrixId & Constant.MATRIX_FLAG) === 0) {
        return 0;
      } else {
        matrixId &= ~Constant.MATRIX_FLAG;
        matrix = movie.lwf.data.matrices[matrixId];
        md = this.getMatrixDeterminant(matrix);
        mm = matrix._;
        if (md) {
          rotation = Math.atan2(mm[1], -mm[0]);
        } else {
          rotation = Math.atan2(mm[1], mm[0]);
        }
        rotation = rotation / Math.PI * 180;
        return rotation;
      }
    };

    Utility.syncColorTransform = function(movie) {
      var alphaTransform, colorTransform, colorTransformId, _ref;
      colorTransformId = (_ref = movie.colorTransformId) != null ? _ref : 0;
      if ((colorTransformId & Constant.COLORTRANSFORM_FLAG) === 0) {
        alphaTransform = movie.lwf.data.alphaTransforms[colorTransformId];
        colorTransform = new ColorTransform(1, 1, 1, alphaTransform._[0], 0, 0, 0, 0);
      } else {
        colorTransformId = colorTransformId & ~Constant.COLORTRANSFORM_FLAG;
        colorTransform = movie.lwf.data.colorTransforms[colorTransformId];
      }
      movie.property.setColorTransform(colorTransform);
    };

    Utility.getAlpha = function(movie) {
      var alphaTransform, colorTransform, colorTransformId, _ref;
      colorTransformId = (_ref = movie.colorTransformId) != null ? _ref : 0;
      if ((colorTransformId & Constant.COLORTRANSFORM_FLAG) === 0) {
        alphaTransform = movie.lwf.data.alphaTransforms[colorTransformId];
        return alphaTransform._[0];
      } else {
        colorTransformId = colorTransformId & ~Constant.COLORTRANSFORM_FLAG;
        colorTransform = movie.lwf.data.colorTransforms[colorTransformId];
        return colorTransform._[3];
      }
    };

    Utility.calcMatrixId = function(lwf, dst, src0, src1Id) {
      var d, matrixId, s0, src1, t, translate;
      if (src1Id === 0) {
        dst.set(src0);
      } else if ((src1Id & Constant.MATRIX_FLAG) === 0) {
        translate = lwf.data.translates[src1Id];
        d = dst._;
        s0 = src0._;
        t = translate._;
        d[0] = s0[0];
        d[2] = s0[2];
        d[4] = s0[0] * t[0] + s0[2] * t[1] + s0[4];
        d[1] = s0[1];
        d[3] = s0[3];
        d[5] = s0[1] * t[0] + s0[3] * t[1] + s0[5];
      } else {
        matrixId = src1Id & ~Constant.MATRIX_FLAG;
        src1 = lwf.data.matrices[matrixId];
        this.calcMatrix(dst, src0, src1);
      }
      return dst;
    };

    Utility.calcMatrix = function(dst, src0, src1) {
      var d, s0, s1;
      d = dst._;
      s0 = src0._;
      s1 = src1._;
      d[0] = s0[0] * s1[0] + s0[2] * s1[1];
      d[2] = s0[0] * s1[2] + s0[2] * s1[3];
      d[4] = s0[0] * s1[4] + s0[2] * s1[5] + s0[4];
      d[1] = s0[1] * s1[0] + s0[3] * s1[1];
      d[3] = s0[1] * s1[2] + s0[3] * s1[3];
      d[5] = s0[1] * s1[4] + s0[3] * s1[5] + s0[5];
      return dst;
    };

    Utility.rotateMatrix = function(dst, src, scale, offsetX, offsetY) {
      var d, s;
      offsetX *= scale;
      offsetY *= scale;
      d = dst._;
      s = src._;
      d[0] = -s[2] * scale;
      d[2] = s[0] * scale;
      d[4] = s[0] * offsetX + s[2] * offsetY + s[4];
      d[1] = -s[3] * scale;
      d[3] = s[1] * scale;
      d[5] = s[1] * offsetX + s[3] * offsetY + s[5];
      return dst;
    };

    Utility.scaleMatrix = function(dst, src, scale, offsetX, offsetY) {
      var d, s;
      offsetX *= scale;
      offsetY *= scale;
      d = dst._;
      s = src._;
      d[0] = s[0] * scale;
      d[2] = s[2] * scale;
      d[4] = s[0] * offsetX + s[2] * offsetY + s[4];
      d[1] = s[1] * scale;
      d[3] = s[3] * scale;
      d[5] = s[1] * offsetX + s[3] * offsetY + s[5];
      return dst;
    };

    Utility.fitForHeight = function(lwf, stageWidth, stageHeight) {
      var scale;
      scale = stageHeight / lwf.height;
      lwf.setTextScale(scale);
      lwf.property.scale(scale, scale);
      lwf.property.move((stageWidth - lwf.width * scale) / 2, 0);
    };

    Utility.fitForWidth = function(lwf, stageWidth, stageHeight) {
      var scale;
      scale = stageWidth / lwf.width;
      lwf.setTextScale(scale);
      lwf.property.scale(scale, scale);
      lwf.property.move(0, (stageHeight - lwf.height * scale) / 2);
    };

    Utility.scaleForHeight = function(lwf, stageWidth, stageHeight) {
      var scale;
      scale = stageHeight / lwf.height;
      lwf.setTextScale(scale);
      lwf.property.scale(scale, scale);
    };

    Utility.scaleForWidth = function(lwf, stageWidth, stageHeight) {
      var scale;
      scale = stageWidth / lwf.width;
      lwf.setTextScale(scale);
      lwf.property.scale(scale, scale);
    };

    Utility.copyMatrix = function(dst, src) {
      if (src !== null) {
        dst.set(src);
      } else {
        dst.clear();
      }
      return dst;
    };

    Utility.invertMatrix = function(dst, src) {
      var d, dt, s;
      d = dst._;
      s = src._;
      dt = s[0] * s[3] - s[2] * s[1];
      if (dt !== 0) {
        d[0] = s[3] / dt;
        d[2] = -s[2] / dt;
        d[4] = (s[2] * s[5] - s[4] * s[3]) / dt;
        d[1] = -s[1] / dt;
        d[3] = s[0] / dt;
        d[5] = (s[4] * s[1] - s[0] * s[5]) / dt;
      } else {
        dst.clear();
      }
    };

    Utility.calcColorTransformId = function(lwf, dst, src0, src1Id) {
      var alphaTransform, colorTransformId, i, src1, _i;
      if (src1Id === 0) {
        if (lwf.useVertexColor) {
          dst.set(src0);
        } else {
          dst.multi._[3] = src0.multi._[3];
        }
      } else if ((src1Id & Constant.COLORTRANSFORM_FLAG) === 0) {
        alphaTransform = lwf.data.alphaTransforms[src1Id];
        if (lwf.useVertexColor) {
          for (i = _i = 0; _i < 3; i = ++_i) {
            dst.multi._[i] = src0.multi._[i];
          }
          dst.multi._[3] = src0.multi._[3] * alphaTransform._[0];
          dst.add.set(src0.add);
        } else {
          dst.multi._[3] = src0.multi._[3] * alphaTransform._[0];
        }
      } else {
        colorTransformId = src1Id & ~Constant.COLORTRANSFORM_FLAG;
        src1 = lwf.data.colorTransforms[colorTransformId];
        this.calcColorTransform(lwf, dst, src0, src1);
      }
      return dst;
    };

    Utility.calcColorTransform = function(lwf, dst, src0, src1) {
      var d, da, i, s0, s0a, s1, s1a, _i, _j;
      if (lwf.useVertexColor) {
        d = dst.multi._;
        s0 = src0.multi._;
        s1 = src1.multi._;
        for (i = _i = 0; _i < 4; i = ++_i) {
          d[i] = s0[i] * s1[i];
        }
        da = dst.add._;
        s0a = src0.add._;
        s1a = src1.add._;
        for (i = _j = 0; _j < 4; i = ++_j) {
          da[i] = s0a[i] * s1[i] + s1a[i];
        }
      } else {
        dst.multi._[3] = src0.multi._[3] * src1.multi._[3];
      }
      return dst;
    };

    Utility.copyColorTransform = function(lwf, dst, src) {
      if (lwf.useVertexColor) {
        if (src !== null) {
          dst.set(src);
        } else {
          dst.clear();
        }
      } else {
        dst.multi.alpha = src !== null ? src.multi.alpha : 1;
      }
      return dst;
    };

    Utility.calcColor = function(lwf, dst, c, t) {
      var cc, d, i, ta, tc, _i, _j;
      if (lwf.useVertexColor) {
        d = dst._;
        cc = c._;
        tc = t.multi._;
        ta = t.add._;
        for (i = _i = 0; _i < 4; i = ++_i) {
          d[i] = cc[i] * tc[i] + ta[i];
        }
      } else {
        d = dst._;
        cc = c._;
        for (i = _j = 0; _j < 3; i = ++_j) {
          d[i] = cc[i];
        }
        d[3] = cc[3] * t.multi._[3];
      }
    };

    Utility.newIntArray = function() {
      return [];
    };

    Utility.clearIntArray = function(array) {
      array.length = 0;
    };

    Utility.insertIntArray = function(array, v) {
      var i;
      if (array.length === 0 || v > array[array.length - 1]) {
        array.push(v);
        return;
      }
      i = this.locationOfIntArray(array, v, 0, array.length - 1);
      if (array[i] !== v) {
        array.splice(i, 0, v);
      }
    };

    Utility.deleteIntArray = function(array, v) {
      var i;
      i = this.locationOfIntArray(array, v, 0, array.length - 1);
      if (array[i] === v) {
        array.splice(i, 1);
      }
    };

    Utility.locationOfIntArray = function(array, v, first, last) {
      var mid;
      while (first <= last) {
        mid = ((first + last) / 2) >> 0;
        if (v > array[mid]) {
          first = mid + 1;
        } else if (v < array[mid]) {
          last = mid - 1;
        } else {
          return mid;
        }
      }
      return first;
    };

    return Utility;

  })();

  NullRendererFactory = (function() {
    function NullRendererFactory() {}

    NullRendererFactory.prototype.constructBitmap = function(lwf, objId, bitmap) {
      return null;
    };

    NullRendererFactory.prototype.constructBitmapEx = function(lwf, objId, bitmapEx) {
      return null;
    };

    NullRendererFactory.prototype.constructText = function(lwf, objId, text) {
      return null;
    };

    NullRendererFactory.prototype.constructParticle = function(lwf, objId, particle) {
      return null;
    };

    NullRendererFactory.prototype.init = function(lwf) {};

    NullRendererFactory.prototype.beginRender = function(lwf) {};

    NullRendererFactory.prototype.endRender = function(lwf) {};

    NullRendererFactory.prototype.destruct = function() {};

    return NullRendererFactory;

  })();

  LObject = (function() {
    function LObject(lwf, parent, type, objectId) {
      this.lwf = lwf;
      this.parent = parent;
      this.type = type;
      this.objectId = objectId;
      this.matrixId = null;
      this.colorTransformId = null;
      this.matrixIdChanged = true;
      this.colorTransformIdChanged = true;
      this.matrix = new Matrix(0, 0, 0, 0, 0, 0);
      this.colorTransform = new ColorTransform(0, 0, 0, 0, 0, 0, 0, 0);
      this.execCount = 0;
      this.updated = false;
      this.isButton = this.type === Type.BUTTON;
      this.isMovie = this.type === Type.MOVIE || this.type === Type.ATTACHEDMOVIE;
      this.isParticle = this.type === Type.PARTICLE;
      this.isProgramObject = this.type === Type.PROGRAMOBJECT;
      this.isText = this.type === Type.TEXT;
      this.isBitmapClip = false;
    }

    LObject.prototype.exec = function(matrixId, colorTransformId) {
      if (matrixId == null) {
        matrixId = 0;
      }
      if (colorTransformId == null) {
        colorTransformId = 0;
      }
      if (this.matrixId !== matrixId) {
        this.matrixIdChanged = true;
        this.matrixId = matrixId;
      }
      if (this.colorTransformId !== colorTransformId) {
        this.colorTransformIdChanged = true;
        this.colorTransformId = colorTransformId;
      }
    };

    LObject.prototype.update = function(m, c) {
      this.updated = true;
      if (m !== null) {
        Utility.calcMatrixId(this.lwf, this.matrix, m, this.dataMatrixId);
        this.matrixIdChanged = false;
      }
      if (c !== null) {
        Utility.copyColorTransform(this.lwf, this.colorTransform, c);
        this.colorTransformIdChanged = false;
      }
      this.lwf.renderObject();
    };

    LObject.prototype.render = function(v, rOffset) {
      var rCount, rIndex, rIndexOffsetted;
      if (this.renderer != null) {
        rIndex = this.lwf.renderingIndex;
        rIndexOffsetted = this.lwf.renderingIndexOffsetted;
        rCount = this.lwf.renderingCount;
        if (rOffset !== Number.MIN_VALUE) {
          rIndex = rIndexOffsetted - rOffset + rCount;
        }
        this.renderer.render(this.matrix, this.colorTransform, rIndex, rCount, v);
      }
      this.lwf.renderObject();
    };

    LObject.prototype.inspect = function(inspector, hierarchy, depth, rOffset) {
      var rCount, rIndex, rIndexOffsetted;
      rIndex = this.lwf.renderingIndex;
      rIndexOffsetted = this.lwf.renderingIndexOffsetted;
      rCount = this.lwf.renderingCount;
      if (rOffset !== Number.MIN_VALUE) {
        rIndex = rIndexOffsetted + rOffset + rCount;
      }
      inspector(this, hierarchy, depth, rIndex);
      this.lwf.renderObject();
    };

    LObject.prototype.destroy = function() {
      if (this.renderer) {
        this.renderer.destruct();
        this.renderer = null;
      }
      this.parent = null;
      this.lwf = null;
    };

    return LObject;

  })();

  Graphic = (function(_super) {
    __extends(Graphic, _super);

    function Graphic(lwf, parent, objId) {
      var data, gobj, graphicObjectId, graphicObjects, i, n, obj, _i;
      Graphic.__super__.constructor.call(this, lwf, parent, Type.GRAPHIC, objId);
      data = lwf.data.graphics[objId];
      n = data.graphicObjects;
      this.displayList = [];
      graphicObjects = lwf.data.graphicObjects;
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        gobj = graphicObjects[data.graphicObjectId + i];
        graphicObjectId = gobj.graphicObjectId;
        if (graphicObjectId === -1) {
          continue;
        }
        switch (gobj.graphicObjectType) {
          case GObjType.BITMAP:
            obj = new Bitmap(lwf, parent, graphicObjectId);
            break;
          case GObjType.BITMAPEX:
            obj = new BitmapEx(lwf, parent, graphicObjectId);
            break;
          case GObjType.TEXT:
            obj = new Text(lwf, parent, graphicObjectId);
        }
        obj.exec();
        this.displayList[i] = obj;
      }
    }

    Graphic.prototype.update = function(m, c) {
      var colorTransformChanged, matrixChanged, obj, objc, objm, _i, _len, _ref;
      matrixChanged = this.matrix.setWithComparing(m);
      colorTransformChanged = this.colorTransform.setWithComparing(c);
      _ref = this.displayList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        if (matrixChanged || !obj.updated || obj.matrixIdChanged) {
          objm = m;
        } else {
          objm = null;
        }
        if (colorTransformChanged || !obj.updated || obj.colorTransformIdChanged) {
          objc = c;
        } else {
          objc = null;
        }
        obj.update(objm, objc);
      }
    };

    Graphic.prototype.render = function(v, rOffset) {
      var obj, _i, _len, _ref;
      _ref = this.displayList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        obj.render(v, rOffset);
      }
    };

    Graphic.prototype.inspect = function(inspector, hierarchy, depth, rOffset) {
      var obj, _i, _len, _ref;
      Graphic.__super__.inspect.call(this, inspector, hierarchy, depth, rOffset);
      ++hierarchy;
      _ref = this.displayList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        obj.inspect(inspector, hierarchy, depth, rOffset);
      }
    };

    Graphic.prototype.destroy = function() {
      var obj, _i, _len, _ref;
      _ref = this.displayList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        obj.destroy();
      }
      this.displayList = null;
    };

    return Graphic;

  })(LObject);

  Bitmap = (function(_super) {
    __extends(Bitmap, _super);

    function Bitmap(lwf, parent, objId) {
      Bitmap.__super__.constructor.call(this, lwf, parent, Type.BITMAP, objId);
      this.dataMatrixId = lwf.data.bitmaps[objId].matrixId;
      this.renderer = lwf.rendererFactory.constructBitmap(lwf, objId, this);
    }

    return Bitmap;

  })(LObject);

  BitmapEx = (function(_super) {
    __extends(BitmapEx, _super);

    function BitmapEx(lwf, parent, objId) {
      BitmapEx.__super__.constructor.call(this, lwf, parent, Type.BITMAPEX, objId);
      this.dataMatrixId = lwf.data.bitmapExs[objId].matrixId;
      this.renderer = lwf.rendererFactory.constructBitmapEx(lwf, objId, this);
    }

    return BitmapEx;

  })(LObject);

  Text = (function(_super) {
    __extends(Text, _super);

    function Text(lwf, parent, objId, instId) {
      var stringId, text;
      if (instId == null) {
        instId = -1;
      }
      Text.__super__.constructor.call(this, lwf, parent, Type.TEXT, objId);
      text = lwf.data.texts[objId];
      this.dataMatrixId = text.matrixId;
      if (text.nameStringId !== -1) {
        this.name = lwf.data.strings[text.nameStringId];
      } else {
        if (instId >= 0 && instId < lwf.data.instanceNames.length) {
          stringId = lwf.getInstanceNameStringId(instId);
          if (stringId !== -1) {
            this.name = lwf.data.strings[stringId];
          }
        }
      }
      this.renderer = lwf.rendererFactory.constructText(lwf, objId, this);
    }

    return Text;

  })(LObject);

  Particle = (function(_super) {
    __extends(Particle, _super);

    function Particle(lwf, parent, objId) {
      Particle.__super__.constructor.call(this, lwf, parent, Type.PARTICLE, objId);
      this.dataMatrixId = lwf.data.particles[objId].matrixId;
      this.renderer = lwf.rendererFactory.constructParticle(lwf, objId, this);
    }

    Particle.prototype.update = function(m, c) {
      Particle.__super__.update.call(this, m, c);
      if (this.renderer != null) {
        this.renderer.update(this.matrix, this.colorTransform);
      }
    };

    return Particle;

  })(LObject);

  ProgramObject = (function(_super) {
    __extends(ProgramObject, _super);

    function ProgramObject(lwf, parent, objId) {
      var ctor, data;
      ProgramObject.__super__.constructor.call(this, lwf, parent, Type.PROGRAMOBJECT, objId);
      data = lwf.data.programObjects[objId];
      this.dataMatrixId = data.matrixId;
      ctor = lwf.getProgramObjectConstructor(objId);
      if (ctor != null) {
        this.renderer = ctor(this, objId, data.width, data.height);
      }
    }

    ProgramObject.prototype.update = function(m, c) {
      ProgramObject.__super__.update.call(this, m, c);
      if (this.renderer != null) {
        this.renderer.update(this.matrix, this.colorTransform);
      }
    };

    return ProgramObject;

  })(LObject);

  IObject = (function(_super) {
    __extends(IObject, _super);

    function IObject(lwf, parent, type, objId, instId) {
      var head, stringId;
      IObject.__super__.constructor.call(this, lwf, parent, type, objId);
      this.prevInstance = null;
      this.nextInstance = null;
      this.linkInstance = null;
      this.instanceId = instId >= lwf.data.instanceNames.length ? -1 : instId;
      if (this.instanceId >= 0) {
        stringId = lwf.getInstanceNameStringId(this.instanceId);
        if (stringId !== -1) {
          this.name = lwf.data.strings[stringId];
          if (parent != null) {
            parent[this.name] = this;
          }
        }
        head = this.lwf.getInstance(this.instanceId);
        if (head != null) {
          head.prevInstance = this;
        }
        this.nextInstance = head;
        this.lwf.setInstance(this.instanceId, this);
      }
    }

    IObject.prototype.destroy = function() {
      var head;
      if (this.type !== Type.ATTACHEDMOVIE && this.instanceId >= 0) {
        head = this.lwf.getInstance(this.instanceId);
        if (head === this) {
          this.lwf.setInstance(this.instanceId, this.nextInstance);
        }
        if (this.nextInstance != null) {
          this.nextInstance.prevInstance = this.prevInstance;
        }
        if (this.prevInstance != null) {
          this.prevInstance.nextInstance = this.nextInstance;
        }
      }
      if ((this.name != null) && (this.parent != null)) {
        delete this.parent[this.name];
      }
      this.prevInstance = null;
      this.nextInstance = null;
      this.linkInstance = null;
      IObject.__super__.destroy.call(this);
    };

    IObject.prototype.linkButton = function() {};

    IObject.prototype.getFullName = function() {
      var fullPath, name, o, splitter;
      fullPath = "";
      splitter = "";
      o = this;
      while (o != null) {
        if (o.name == null) {
          return null;
        }
        if ((o.parent != null) && o.objectId === o.lwf.data.header.rootMovieId) {
          name = o.lwf.attachName;
        } else {
          name = o.name;
        }
        fullPath = name + splitter + fullPath;
        splitter = ".";
        o = o.parent;
      }
      return fullPath;
    };

    return IObject;

  })(LObject);

  Button = (function(_super) {
    __extends(Button, _super);

    function Button(lwf, parent, objId, instId, matrixId, colorTransformId) {
      if (matrixId == null) {
        matrixId = null;
      }
      if (colorTransformId == null) {
        colorTransformId = null;
      }
      Button.__super__.constructor.call(this, lwf, parent, Type.BUTTON, objId, instId);
      this.matrixId = matrixId;
      this.colorTransformId = colorTransformId;
      this.invert = new Matrix();
      this.hitX = Number.MIN_VALUE;
      this.hitY = Number.MIN_VALUE;
      if (objId >= 0) {
        this.data = lwf.data.buttons[objId];
        this.dataMatrixId = this.data.matrixId;
        this.width = this.data.width;
        this.height = this.data.height;
      } else {
        this.width = 0;
        this.height = 0;
      }
      this.handler = lwf.getButtonEventHandlers(this);
      if (this.handler != null) {
        this.handler.call("load", this);
      }
    }

    Button.prototype.setHandlers = function(handler) {
      if (this.handler != null) {
        this.handler.concat(handler);
      } else {
        this.handler = handler;
      }
    };

    Button.prototype.exec = function(matrixId, colorTransformId) {
      if (matrixId == null) {
        matrixId = 0;
      }
      if (colorTransformId == null) {
        colorTransformId = 0;
      }
      Button.__super__.exec.call(this, matrixId, colorTransformId);
      this.enterFrame();
    };

    Button.prototype.update = function(m, c) {
      Button.__super__.update.call(this, m, c);
      if (this.handler != null) {
        this.handler.call("update", this);
      }
    };

    Button.prototype.render = function(v, rOffset) {
      if (this.handler != null) {
        this.handler.call("render", this);
      }
    };

    Button.prototype.destroy = function() {
      this.lwf.clearFocus(this);
      this.lwf.clearPressed(this);
      if (this.handler != null) {
        this.handler.call("unload", this);
      }
      Button.__super__.destroy.call(this);
    };

    Button.prototype.linkButton = function() {
      if (this.lwf.focus === this) {
        this.lwf.focusOnLink = true;
      }
      this.buttonLink = this.lwf.buttonHead;
      this.lwf.buttonHead = this;
    };

    Button.prototype.checkHit = function(px, py) {
      var x, y, _ref;
      Utility.invertMatrix(this.invert, this.matrix);
      _ref = Utility.calcMatrixToPoint(px, py, this.invert), x = _ref[0], y = _ref[1];
      if (x >= 0 && x < this.data.width && y >= 0 && y < this.data.height) {
        this.hitX = x;
        this.hitY = y;
        return true;
      } else {
        this.hitX = Number.MIN_VALUE;
        this.hitY = Number.MIN_VALUE;
        return false;
      }
    };

    Button.prototype.enterFrame = function() {
      if (this.handler != null) {
        this.handler.call("enterFrame", this);
      }
    };

    Button.prototype.rollOver = function() {
      if (this.handler != null) {
        this.handler.call("rollOver", this);
      }
      this.playAnimation(Condition.ROLLOVER);
    };

    Button.prototype.rollOut = function() {
      if (this.handler != null) {
        this.handler.call("rollOut", this);
      }
      this.playAnimation(Condition.ROLLOUT);
    };

    Button.prototype.press = function() {
      if (this.handler != null) {
        this.handler.call("press", this);
      }
      this.playAnimation(Condition.PRESS);
    };

    Button.prototype.release = function() {
      if (this.handler != null) {
        this.handler.call("release", this);
      }
      this.playAnimation(Condition.RELEASE);
    };

    Button.prototype.keyPress = function(code) {
      if (this.handler != null) {
        this.handler.call("keyPress", this);
      }
      this.playAnimation(Condition.KEYPRESS, code);
    };

    Button.prototype.playAnimation = function(condition, code) {
      var c, conditions, i, _i, _ref;
      if (code == null) {
        code = 0;
      }
      conditions = this.lwf.data.buttonConditions;
      for (i = _i = 0, _ref = this.data.conditions; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        c = conditions[this.data.conditionId + i];
        if ((c.condition & condition) !== 0 && (condition !== Condition.KEYPRESS || c.keyCode === code)) {
          this.lwf.playAnimation(c.animationId, this.parent, this);
        }
      }
    };

    Button.prototype.addEventHandler = function(e, eventHandler) {
      switch (e) {
        case "load":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
        case "press":
        case "release":
        case "rollOver":
        case "rollOut":
        case "keyPress":
          this.lwf.setInteractive();
          this.lwf.enableExec();
          if (this.handler == null) {
            this.setHandlers(new ButtonEventHandlers());
          }
          this.handler.addHandler(e, eventHandler);
      }
    };

    Button.prototype.removeEventHandler = function(e, eventHandler) {
      switch (e) {
        case "load":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
        case "press":
        case "release":
        case "rollOver":
        case "rollOut":
        case "keyPress":
          if (this.handler != null) {
            this.handler.removeHandler(e, eventHandler);
          }
      }
    };

    Button.prototype.clearEventHandler = function(e) {
      if (e == null) {
        e = null;
      }
      switch (e) {
        case null:
          if (this.handler != null) {
            this.handler.clear();
          }
          break;
        case "load":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
        case "press":
        case "release":
        case "rollOver":
        case "rollOut":
        case "keyPress":
          if (this.handler != null) {
            this.handler.clear(e);
          }
      }
    };

    Button.prototype.setEventHandler = function(e, eventHandler) {
      this.clearEventHandler(e);
      this.addEventHandler(e, eventHandler);
    };

    return Button;

  })(IObject);

  LWFContainer = (function(_super) {
    __extends(LWFContainer, _super);

    function LWFContainer(parent, child) {
      this.parent = parent;
      this.child = child;
      this.lwf = this.parent.lwf;
    }

    LWFContainer.prototype.checkHit = function(px, py) {
      var button;
      button = this.child.inputPoint(px, py);
      if (button !== null) {
        return true;
      } else {
        return false;
      }
    };

    LWFContainer.prototype.rollOver = function() {};

    LWFContainer.prototype.rollOut = function() {
      if (this.child.focus != null) {
        this.child.focus.rollOut();
        this.child.clearFocus(this.child.focus);
      }
    };

    LWFContainer.prototype.press = function() {
      this.child.inputPress();
    };

    LWFContainer.prototype.release = function() {
      this.child.inputRelease();
    };

    LWFContainer.prototype.keyPress = function(code) {
      this.child.inputKeyPress(code);
    };

    return LWFContainer;

  })(Button);

  Property = (function() {
    function Property(lwf) {
      this.lwf = lwf;
      this.matrix = new Matrix;
      this.colorTransform = new ColorTransform;
      this.scaleX = 1;
      this.scaleY = 1;
      this.rotation = 0;
      this.hasMatrix = false;
      this.hasColorTransform = false;
      this.clearRenderingOffset();
    }

    Property.prototype.clear = function() {
      this.scaleX = 1;
      this.scaleY = 1;
      this.rotation = 0;
      this.matrix.clear();
      this.colorTransform.clear();
      if (this.hasMatrix || this.hasColorTransform) {
        this.lwf.setPropertyDirty();
      }
      this.hasMatrix = false;
      this.hasColorTransform = false;
      this.clearRenderingOffset();
    };

    Property.prototype.move = function(x, y) {
      this.matrix._[4] += x;
      this.matrix._[5] += y;
      this.hasMatrix = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.moveTo = function(x, y) {
      this.matrix._[4] = x;
      this.matrix._[5] = y;
      this.hasMatrix = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.rotate = function(degree) {
      this.rotateTo(this.rotation + degree);
    };

    Property.prototype.rotateTo = function(degree) {
      this.rotation = degree;
      this.setScaleAndRotation();
    };

    Property.prototype.scale = function(x, y) {
      this.scaleX *= x;
      this.scaleY *= y;
      this.setScaleAndRotation();
    };

    Property.prototype.scaleTo = function(x, y) {
      this.scaleX = x;
      this.scaleY = y;
      this.setScaleAndRotation();
    };

    Property.prototype.setScaleAndRotation = function() {
      var c, radian, s;
      radian = this.rotation * Math.PI / 180;
      if (radian === 0) {
        c = 1;
        s = 0;
      } else {
        c = Math.cos(radian);
        s = Math.sin(radian);
      }
      this.matrix._[0] = this.scaleX * c;
      this.matrix._[2] = this.scaleY * -s;
      this.matrix._[1] = this.scaleX * s;
      this.matrix._[3] = this.scaleY * c;
      this.hasMatrix = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.setMatrix = function(m, scaleX, scaleY, rotation) {
      this.scaleX = scaleX != null ? scaleX : 1;
      this.scaleY = scaleY != null ? scaleY : 1;
      this.rotation = rotation != null ? rotation : 0;
      this.matrix.set(m);
      this.hasMatrix = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.setAlpha = function(alpha) {
      this.colorTransform.multi._[3] = alpha;
      this.hasColorTransform = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.setColorTransform = function(c) {
      this.colorTransform.set(c);
      this.hasColorTransform = true;
      this.lwf.setPropertyDirty();
    };

    Property.prototype.setRenderingOffset = function(rOffset) {
      this.renderingOffset = rOffset;
      this.hasRenderingOffset = true;
    };

    Property.prototype.clearRenderingOffset = function() {
      this.renderingOffset = Number.MIN_VALUE;
      this.hasRenderingOffset = false;
    };

    return Property;

  })();

  BitmapClip = (function(_super) {
    __extends(BitmapClip, _super);

    function BitmapClip(lwf, parent, objId) {
      var data, fragment, texdata;
      BitmapClip.__super__.constructor.call(this, lwf, parent, Type.BITMAP, objId);
      this.isBitmapClip = true;
      data = lwf.data.bitmaps[objId];
      fragment = lwf.data.textureFragments[data.textureFragmentId];
      texdata = lwf.data.textures[fragment.textureId];
      this.width = fragment.w / texdata.scale;
      this.height = fragment.h / texdata.scale;
      this.offsetX = fragment.x;
      this.offsetY = fragment.y;
      this.originalWidth = fragment.ow;
      this.originalHeight = fragment.oh;
      this.dataMatrixId = data.matrixId;
      this.renderer = lwf.rendererFactory.constructBitmap(lwf, objId, this);
      this.depth = -1;
      this.visible = true;
      this.regX = 0;
      this.regY = 0;
      this.x = 0;
      this.y = 0;
      this.scaleX = 1;
      this.scaleY = 1;
      this.rotation = 0;
      this.alpha = 1;
      this._scaleX = this.scaleX;
      this._scaleY = this.scaleY;
      this._rotation = this.rotation;
      this._cos = 1;
      this._sin = 0;
      this._ = TypedArray.available ? new Float32Array(8) : [];
      this._[0] = 1;
      this._[1] = 0;
      this._[2] = 0;
      this._[3] = 1;
      this._[4] = 0;
      this._[5] = 0;
      this._[6] = 0;
      this._[7] = 0;
    }

    BitmapClip.prototype.update = function(m, c) {
      var cm, dirty, dst, i, mm, my, radian, _i, _j;
      dst = this.matrix._;
      mm = m._;
      my = this._;
      if (this.rotation !== this._rotation) {
        this._rotation = this.rotation;
        radian = this._rotation * Math.PI / 180;
        if (radian === 0) {
          this._cos = 1;
          this._sin = 0;
        } else {
          this._cos = Math.cos(radian);
          this._sin = Math.sin(radian);
        }
        dirty = true;
      } else {
        dirty = false;
      }
      if (dirty || this._scaleX !== this.scaleX || this._scaleY !== this.scaleY) {
        this._scaleX = this.scaleX;
        this._scaleY = this.scaleY;
        my[0] = this._scaleX * this._cos;
        my[1] = this._scaleX * this._sin;
        my[2] = this._scaleY * -this._sin;
        my[3] = this._scaleY * this._cos;
      }
      my[4] = this.x;
      my[6] = this.regX;
      my[4] -= my[6];
      my[5] = this.y;
      my[7] = this.regY;
      my[5] -= my[7];
      dst[0] = mm[0] * my[0] + mm[2] * my[1];
      dst[2] = mm[0] * my[2] + mm[2] * my[3];
      dst[4] = mm[0] * my[4] + mm[2] * my[5] + mm[4] + mm[0] * my[6] + mm[2] * my[7] + dst[0] * -my[6] + dst[2] * -my[7];
      dst[1] = mm[1] * my[0] + mm[3] * my[1];
      dst[3] = mm[1] * my[2] + mm[3] * my[3];
      dst[5] = mm[1] * my[4] + mm[3] * my[5] + mm[5] + mm[1] * my[6] + mm[3] * my[7] + dst[1] * -my[6] + dst[3] * -my[7];
      dst = this.colorTransform.multi._;
      cm = c.multi._;
      if (this.lwf.useVertexColor) {
        if (this.alpha === 1) {
          for (i = _i = 0; _i < 4; i = ++_i) {
            dst[i] = cm[i];
          }
        } else {
          for (i = _j = 0; _j < 3; i = ++_j) {
            dst[i] = cm[i];
          }
          dst[3] = this.alpha * cm[3];
        }
      } else {
        dst[3] = this.alpha * cm[3];
      }
      this.lwf.renderObject();
    };

    BitmapClip.prototype.setMatrix = function(m) {
      var i, _i;
      for (i = _i = 0; _i < 6; i = ++_i) {
        this._[i] = m._[i];
      }
    };

    BitmapClip.prototype.detachFromParent = function() {
      if (this.parent != null) {
        this.parent.detachBitmap(this.depth);
        this.parent = null;
      }
    };

    return BitmapClip;

  })(LObject);

  Movie = (function(_super) {
    __extends(Movie, _super);

    function Movie(lwf, parent, objId, instId, matrixId, colorTransformId, attached, handler, n) {
      var func, type, _ref;
      if (matrixId == null) {
        matrixId = null;
      }
      if (colorTransformId == null) {
        colorTransformId = null;
      }
      if (attached == null) {
        attached = false;
      }
      if (handler == null) {
        handler = null;
      }
      if (n == null) {
        n = null;
      }
      type = attached ? Type.ATTACHEDMOVIE : Type.MOVIE;
      Movie.__super__.constructor.call(this, lwf, parent, type, objId, instId);
      if (n != null) {
        this.name = n;
      }
      this.matrixId = matrixId;
      this.colorTransformId = colorTransformId;
      this.data = lwf.data.movies[objId];
      this.totalFrames = this.data.frames;
      this.instanceHead = null;
      this.instanceTail = null;
      this.currentFrameInternal = -1;
      this.execedFrame = -1;
      this.animationPlayedFrame = -1;
      this.lastControlOffset = -1;
      this.lastControls = -1;
      this.lastHasButton = false;
      this.lastControlAnimationOffset = -1;
      this.skipped = false;
      this.postLoaded = false;
      this.active = true;
      this.visible = true;
      this.playing = true;
      this.jumped = false;
      this.overriding = false;
      this.attachMovieExeced = false;
      this.attachMoviePostExeced = false;
      this.movieExecCount = -1;
      this.postExecCount = -1;
      this.eventHandlers = {};
      this.requestedCalculateBounds = false;
      this.calculateBoundsCallback = null;
      this.currentLabelsCache = null;
      this.currentLabelCache = {};
      this.property = new Property(lwf);
      this.matrix0 = new Matrix;
      this.matrix1 = new Matrix;
      this.colorTransform0 = new ColorTransform;
      this.colorTransform1 = new ColorTransform;
      this.blendMode = "normal";
      this.displayList = [];
      this.attachName = null;
      this.depth = null;
      this.hasButton = false;
      this.getMovieFunctions();
      if (objId === this.lwf.data.header.rootMovieId) {
        func = (_ref = this.lwf.functions) != null ? _ref['init'] : void 0;
        if (func != null) {
          func.call(this);
        }
      }
      if (this.loadFunc != null) {
        this.loadFunc.call(this);
      }
      this.playAnimation(ClipEvent.LOAD);
      this.handler = new MovieEventHandlers;
      this.handler.concat(lwf.getMovieEventHandlers(this));
      this.handler.concat(handler);
      if (!this.handler.empty) {
        this.handler.call("load", this);
      }
      lwf.execMovieCommand();
    }

    Movie.prototype.getMovieFunctions = function() {
      var _ref;
      _ref = this.lwf.getMovieFunctions(this.objectId), this.loadFunc = _ref[0], this.postLoadFunc = _ref[1], this.unloadFunc = _ref[2], this.enterFrameFunc = _ref[3];
    };

    Movie.prototype.setHandlers = function(handler) {
      this.handler.concat(handler);
    };

    Movie.prototype.play = function() {
      this.playing = true;
      return this;
    };

    Movie.prototype.stop = function() {
      this.playing = false;
      return this;
    };

    Movie.prototype.nextFrame = function() {
      this.jumped = true;
      this.stop();
      if (this.currentFrameInternal < this.totalFrames - 1) {
        ++this.currentFrameInternal;
      }
      return this;
    };

    Movie.prototype.prevFrame = function() {
      this.jumped = true;
      this.stop();
      if (this.currentFrameInternal > 0) {
        --this.currentFrameInternal;
      }
      return this;
    };

    Movie.prototype.gotoFrame = function(frameNo) {
      return this.gotoFrameInternal(frameNo - 1);
    };

    Movie.prototype.gotoFrameInternal = function(frameNo) {
      this.jumped = true;
      this.stop();
      this.currentFrameInternal = frameNo;
      return this;
    };

    Movie.prototype.setVisible = function(visible) {
      this.visible = visible;
      return this;
    };

    Movie.prototype.globalToLocal = function(point) {
      var invert, m, x, y, _ref;
      if (this.property.hasMatrix) {
        m = new Matrix();
        m = Utility.calcMatrix(m, this.matrix, this.property.matrix);
      } else {
        m = this.matrix;
      }
      invert = new Matrix();
      Utility.invertMatrix(invert, m);
      _ref = Utility.calcMatrixToPoint(point.x, point.y, invert), x = _ref[0], y = _ref[1];
      return new Point(x, y);
    };

    Movie.prototype.localToGlobal = function(point) {
      var m, x, y, _ref;
      if (this.property.hasMatrix) {
        m = new Matrix();
        m = Utility.calcMatrix(m, this.matrix, this.property.matrix);
      } else {
        m = this.matrix;
      }
      _ref = Utility.calcMatrixToPoint(point.x, point.y, m), x = _ref[0], y = _ref[1];
      return new Point(x, y);
    };

    Movie.prototype.getDepth = function(keys) {
      var depth;
      depth = keys.length === 0 ? 0 : keys[keys.length - 1] + 1;
      return depth;
    };

    Movie.prototype.reorderList = function(reorder, keys, list, index, object, op) {
      var i, k, newlist, v;
      Utility.insertIntArray(keys, index);
      list[index] = object;
      if (reorder) {
        i = 0;
        newlist = {};
        for (k in list) {
          v = list[k];
          op(v, i);
          keys[i] = i;
          newlist[i] = v;
          ++i;
        }
        list = newlist;
      }
      return list;
    };

    Movie.prototype.deleteAttachedMovie = function(parent, movie, destroy, deleteFromDetachedMovies) {
      var attachName, depth;
      if (destroy == null) {
        destroy = true;
      }
      if (deleteFromDetachedMovies == null) {
        deleteFromDetachedMovies = true;
      }
      attachName = movie.attachName;
      depth = movie.depth;
      delete parent.attachedMovies[attachName];
      delete parent.attachedMovieList[depth];
      Utility.deleteIntArray(parent.attachedMovieListKeys, depth);
      if (deleteFromDetachedMovies) {
        delete parent.detachedMovies[attachName];
      }
      delete parent[attachName];
      if (destroy) {
        return movie.destroy();
      }
    };

    Movie.prototype.attachMovie = function(linkageName, attachName, options) {
      var attachedMovie, depth, handlers, movie, movieId, reorder, _ref;
      if (options == null) {
        options = null;
      }
      if (linkageName instanceof LWF) {
        return this.attachLWF(linkageName, attachName, options);
      }
      if (options == null) {
        options = {};
      }
      depth = options["depth"];
      reorder = (_ref = options["reorder"]) != null ? _ref : false;
      if (linkageName instanceof Movie && linkageName.lwf === this.lwf) {
        movie = linkageName;
        this.deleteAttachedMovie(movie.parent, movie, false);
      } else if (typeof linkageName === "string") {
        movieId = this.lwf.searchMovieLinkage(this.lwf.getStringId(linkageName));
        if (movieId === -1) {
          return null;
        }
      } else {
        return null;
      }
      if (this.attachedMovies == null) {
        this.attachedMovies = {};
        this.detachedMovies = {};
        this.attachedMovieList = {};
        this.attachedMovieListKeys = Utility.newIntArray();
      }
      attachedMovie = this.attachedMovies[attachName];
      if (attachedMovie != null) {
        this.deleteAttachedMovie(this, attachedMovie);
      }
      if (!reorder && (depth != null)) {
        attachedMovie = this.attachedMovieList[depth];
        if (attachedMovie != null) {
          this.deleteAttachedMovie(this, attachedMovie);
        }
      }
      handlers = new MovieEventHandlers();
      handlers.add(options);
      if (movie != null) {
        movie.parent = this;
        movie.setHandlers(handlers);
      } else {
        movie = new Movie(this.lwf, this, movieId, -1, 0, 0, true, handlers, attachName);
        if (this.attachMovieExeced) {
          movie.exec();
        }
        if (this.attachMoviePostExeced) {
          movie.postExec(true);
        }
      }
      movie.attachName = attachName;
      if (depth == null) {
        depth = this.getDepth(this.attachedMovieListKeys);
      }
      movie.depth = depth;
      this.attachedMovies[attachName] = movie;
      this.attachedMovieList = this.reorderList(reorder, this.attachedMovieListKeys, this.attachedMovieList, movie.depth, movie, function(o, i) {
        return o.depth = i;
      });
      this[attachName] = movie;
      return movie;
    };

    Movie.prototype.attachEmptyMovie = function(attachName, options) {
      if (options == null) {
        options = null;
      }
      return this.attachMovie("_empty", attachName, options);
    };

    Movie.prototype.swapAttachedMovieDepth = function(depth0, depth1) {
      var attachedMovie0, attachedMovie1;
      if ((this.attachedMovies == null) || depth0 === depth1) {
        return;
      }
      attachedMovie0 = this.attachedMovieList[depth0];
      attachedMovie1 = this.attachedMovieList[depth1];
      if (attachedMovie0 != null) {
        attachedMovie0.depth = depth1;
        this.attachedMovieList[depth1] = attachedMovie0;
        Utility.insertIntArray(this.attachedMovieListKeys, depth1);
      } else {
        delete this.attachedMovieList[depth1];
        Utility.deleteIntArray(this.attachedMovieListKeys, depth1);
      }
      if (attachedMovie1 != null) {
        attachedMovie1.depth = depth0;
        this.attachedMovieList[depth0] = attachedMovie1;
        Utility.insertIntArray(this.attachedMovieListKeys, depth0);
      } else {
        delete this.attachedMovieList[depth0];
        Utility.deleteIntArray(this.attachedMovieListKeys, depth0);
      }
    };

    Movie.prototype.getAttachedMovie = function(attachName) {
      var depth;
      if (this.attachedMovies == null) {
        return null;
      }
      switch (typeof attachName) {
        case "string":
          return this.attachedMovies[attachName];
        case "number":
          depth = attachName;
          return this.attachedMovieList[depth];
      }
    };

    Movie.prototype.searchAttachedMovie = function(attachName, recursive) {
      var i, instance, movie;
      if (recursive == null) {
        recursive = true;
      }
      movie = this.getAttachedMovie(attachName);
      if (movie != null) {
        return movie;
      }
      if (!recursive) {
        return null;
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie) {
          i = instance.searchAttachedMovie(attachName, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.detachMovie = function(arg) {
      var attachedMovie, _ref;
      if (this.detachedMovies != null) {
        if (arg instanceof Movie) {
          if ((arg != null ? arg.attachName : void 0) != null) {
            this.detachedMovies[arg.attachName] = true;
          }
        } else {
          switch (typeof arg) {
            case "string":
              this.detachedMovies[arg] = true;
              break;
            case "number":
              attachedMovie = (_ref = this.attachedMovieList) != null ? _ref[arg] : void 0;
              if ((attachedMovie != null ? attachedMovie.attachName : void 0) != null) {
                this.detachedMovies[attachedMovie.attachName] = true;
              }
          }
        }
      }
    };

    Movie.prototype.detachFromParent = function() {
      if (this.type !== Type.ATTACHEDMOVIE) {
        return;
      }
      this.active = false;
      if (this.parent != null) {
        this.parent.detachMovie(this);
      }
    };

    Movie.prototype.removeMovieClip = function() {
      if (this.attachName != null) {
        if (this.parent != null) {
          this.parent.detachMovie(this);
        }
      } else if (this.lwf.attachName != null) {
        if (this.lwf.parent != null) {
          this.lwf.parent.detachLWF(this.lwf);
        }
      }
    };

    Movie.prototype.attachBitmap = function(linkageName, depth) {
      var bitmap, bitmapId;
      bitmapId = this.lwf.data.bitmapMap[linkageName];
      if (bitmapId == null) {
        return null;
      }
      bitmap = new BitmapClip(this.lwf, this, bitmapId);
      if (this.bitmapClips != null) {
        this.detachBitmap(depth);
      } else {
        this.bitmapClips = [];
      }
      this.bitmapClips[depth] = bitmap;
      bitmap.depth = depth;
      bitmap.name = linkageName;
      return bitmap;
    };

    Movie.prototype.getAttachedBitmaps = function() {
      return this.bitmapClips;
    };

    Movie.prototype.getAttachedBitmap = function(depth) {
      if (this.bitmapClips == null) {
        return null;
      }
      return this.bitmapClips[depth];
    };

    Movie.prototype.detachBitmap = function(depth) {
      var bitmapClip;
      if (this.bitmapClips == null) {
        return;
      }
      bitmapClip = this.bitmapClips[depth];
      if (bitmapClip == null) {
        return;
      }
      bitmapClip.destroy();
      this.bitmapClips[depth] = null;
    };

    Movie.prototype.execDetachHandler = function(lwfContainer) {
      var lwf;
      lwf = lwfContainer.child;
      if (lwf.detachHandler != null) {
        if (lwf.detachHandler(lwf)) {
          lwf.destroy();
        } else {
          lwf.setAttachVisible(false);
          lwf.render();
        }
      } else {
        lwf.destroy();
      }
      lwf.parent = null;
      if (lwf.rootMovie != null) {
        lwf.rootMovie.parent = null;
      }
      lwf.detachHandler = null;
      lwf.attachName = null;
    };

    Movie.prototype.deleteAttachedLWF = function(parent, lwfContainer, destroy, deleteFromDetachedLWFs) {
      var attachName, depth;
      if (destroy == null) {
        destroy = true;
      }
      if (deleteFromDetachedLWFs == null) {
        deleteFromDetachedLWFs = true;
      }
      attachName = lwfContainer.child.attachName;
      depth = lwfContainer.child.depth;
      delete parent.attachedLWFs[attachName];
      delete parent.attachedLWFList[depth];
      Utility.deleteIntArray(parent.attachedLWFListKeys, depth);
      if (deleteFromDetachedLWFs) {
        delete parent.detachedLWFs[attachName];
      }
      delete parent[attachName];
      if (destroy) {
        return this.execDetachHandler(lwfContainer);
      }
    };

    Movie.prototype.attachLWF = function(attachLWF, attachName, options) {
      var depth, detachHandler, lwfContainer, reorder, _ref;
      if (options == null) {
        options = null;
      }
      if (options == null) {
        options = {};
      }
      depth = options["depth"];
      reorder = (_ref = options["reorder"]) != null ? _ref : false;
      detachHandler = options["detach"];
      if (this.attachedLWFs == null) {
        this.attachedLWFs = {};
        this.detachedLWFs = {};
        this.attachedLWFList = {};
        this.attachedLWFListKeys = Utility.newIntArray();
        this.needsUpdateAttachedLWFs = false;
        this.matrixForAttachedLWFs = new Matrix;
        this.colorTransformForAttachedLWFs = new ColorTransform;
      }
      if (attachLWF.parent != null) {
        lwfContainer = attachLWF.parent.attachedLWFs[attachLWF.attachName];
        this.deleteAttachedLWF(attachLWF.parent, lwfContainer, false);
      }
      lwfContainer = this.attachedLWFs[attachName];
      if (lwfContainer != null) {
        this.deleteAttachedLWF(this, lwfContainer);
      }
      if (!reorder && (depth != null)) {
        lwfContainer = this.attachedLWFList[depth];
        if (lwfContainer != null) {
          this.deleteAttachedLWF(this, lwfContainer);
        }
      }
      lwfContainer = new LWFContainer(this, attachLWF);
      if (attachLWF.interactive) {
        this.lwf.setInteractive();
      }
      attachLWF.setParent(this);
      attachLWF.detachHandler = detachHandler;
      attachLWF.attachName = attachName;
      if (depth == null) {
        depth = this.getDepth(this.attachedLWFListKeys);
      }
      attachLWF.depth = depth;
      this.attachedLWFs[attachName] = lwfContainer;
      this.attachedLWFList = this.reorderList(reorder, this.attachedLWFListKeys, this.attachedLWFList, attachLWF.depth, lwfContainer, function(o, i) {
        return o.child.depth = i;
      });
      this[attachName] = attachLWF.rootMovie;
      if (attachLWF.lwfInstanceId != null) {
        delete this.lwf.loadedLWFs[attachLWF.lwfInstanceId];
      }
      this.lwf.setLWFAttached();
    };

    Movie.prototype.swapAttachedLWFDepth = function(depth0, depth1) {
      var attachedLWF0, attachedLWF1;
      if ((this.attachedLWFs == null) || depth0 === depth1) {
        return;
      }
      attachedLWF0 = this.attachedLWFList[depth0];
      attachedLWF1 = this.attachedLWFList[depth1];
      if (attachedLWF0 != null) {
        attachedLWF0.child.depth = depth1;
        this.attachedLWFList[depth1] = attachedLWF0;
        Utility.insertIntArray(this.attachedLWFListKeys, depth1);
      } else {
        delete this.attachedLWFList[depth1];
        Utility.deleteIntArray(this.attachedLWFListKeys, depth1);
      }
      if (attachedLWF1 != null) {
        attachedLWF1.child.depth = depth0;
        this.attachedLWFList[depth0] = attachedLWF1;
        Utility.insertIntArray(this.attachedLWFListKeys, depth0);
      } else {
        delete this.attachedLWFList[depth0];
        Utility.deleteIntArray(this.attachedLWFListKeys, depth0);
      }
    };

    Movie.prototype.swapDepths = function(depth) {
      var movie;
      if (depth instanceof Movie) {
        movie = depth;
        if (this.attachName != null) {
          this.parent.swapAttachedMovieDepth(this.depth, movie.depth);
        } else if (this.lwf === movie.lwf && (this.lwf.attachName != null)) {
          this.parent.swapAttachedLWFDepth(this.lwf.depth, movie.lwf.depth);
        }
      } else {
        if (this.attachName != null) {
          this.parent.swapAttachedMovieDepth(this.depth, depth);
        } else if (this.lwf.attachName != null) {
          this.parent.swapAttachedLWFDepth(this.lwf.depth, depth);
        }
      }
    };

    Movie.prototype.getAttachedLWF = function(attachName) {
      var depth, _ref, _ref1;
      if (this.attachedLWFs == null) {
        return null;
      }
      switch (typeof attachName) {
        case "string":
          return (_ref = this.attachedLWFs[attachName]) != null ? _ref.child : void 0;
        case "number":
          depth = attachName;
          return (_ref1 = this.attachedLWFList[depth]) != null ? _ref1.child : void 0;
      }
    };

    Movie.prototype.searchAttachedLWF = function(attachName, recursive) {
      var attachedLWF, i, instance;
      if (recursive == null) {
        recursive = true;
      }
      attachedLWF = this.getAttachedLWF(attachName);
      if (attachedLWF != null) {
        return attachedLWF;
      }
      if (!recursive) {
        return null;
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie) {
          i = instance.searchAttachedLWF(attachName, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.detachLWF = function(arg) {
      var attachedLWF, _ref, _ref1;
      if (this.detachedLWFs != null) {
        if (arg instanceof LWF) {
          if ((arg != null ? arg.attachName : void 0) != null) {
            this.detachedLWFs[arg.attachName] = true;
          }
        } else {
          switch (typeof arg) {
            case "string":
              this.detachedLWFs[arg] = true;
              break;
            case "number":
              attachedLWF = (_ref = this.attachedLWFList) != null ? _ref[arg] : void 0;
              if ((attachedLWF != null ? (_ref1 = attachedLWF.child) != null ? _ref1.attachName : void 0 : void 0) != null) {
                this.detachedLWFs[attachedLWF.child.attachName] = true;
              }
          }
        }
      }
    };

    Movie.prototype.detachAllLWFs = function() {
      var k, lwfContainer, _ref;
      if (this.detachedLWFs != null) {
        _ref = this.attachedLWFs;
        for (k in _ref) {
          lwfContainer = _ref[k];
          this.detachedLWFs[lwfContainer.child.attachName] = true;
        }
      }
    };

    Movie.prototype.setBlendMode = function(obj, blendMode) {
      switch (blendMode) {
        case Format.Constant.BLEND_MODE_NORMAL:
          return obj.blendMode = "normal";
        case Format.Constant.BLEND_MODE_ADD:
          return obj.blendMode = "add";
        case Format.Constant.BLEND_MODE_ERASE:
          return obj.blendMode = "erase";
        case Format.Constant.BLEND_MODE_LAYER:
          return obj.blendMode = "layer";
        case Format.Constant.BLEND_MODE_MASK:
          return obj.blendMode = "mask";
        case Format.Constant.BLEND_MODE_MULTIPLY:
          return obj.blendMode = "multiply";
        case Format.Constant.BLEND_MODE_SCREEN:
          return obj.blendMode = "screen";
        case Format.Constant.BLEND_MODE_SUBTRACT:
          return obj.blendMode = "subtract";
      }
    };

    Movie.prototype.execObject = function(depth, objId, matrixId, colorTransformId, instId, blendMode, updateBlendMode) {
      var data, dataObject, dataObjectId, obj;
      if (updateBlendMode == null) {
        updateBlendMode = false;
      }
      if (objId === -1) {
        return;
      }
      data = this.lwf.data;
      dataObject = data.objects[objId];
      dataObjectId = dataObject.objectId;
      obj = this.displayList[depth];
      if ((obj != null) && (obj.type !== dataObject.objectType || obj.objectId !== dataObjectId || (obj.isMovie && obj.instanceId !== instId))) {
        obj.destroy();
        obj = null;
      }
      if (obj == null) {
        switch (dataObject.objectType) {
          case Type.BUTTON:
            obj = new Button(this.lwf, this, dataObjectId, instId, matrixId, colorTransformId);
            break;
          case Type.GRAPHIC:
            obj = new Graphic(this.lwf, this, dataObjectId);
            break;
          case Type.MOVIE:
            obj = new Movie(this.lwf, this, dataObjectId, instId, matrixId, colorTransformId);
            this.setBlendMode(obj, blendMode);
            break;
          case Type.BITMAP:
            obj = new Bitmap(this.lwf, this, dataObjectId);
            break;
          case Type.BITMAPEX:
            obj = new BitmapEx(this.lwf, this, dataObjectId);
            break;
          case Type.TEXT:
            obj = new Text(this.lwf, this, dataObjectId, instId);
            break;
          case Type.PARTICLE:
            obj = new Particle(this.lwf, this, dataObjectId);
            break;
          case Type.PROGRAMOBJECT:
            obj = new ProgramObject(this.lwf, this, dataObjectId);
        }
      }
      if (obj.isMovie && updateBlendMode) {
        this.setBlendMode(obj, blendMode);
      }
      if (obj.isMovie || obj.isButton) {
        obj.linkInstance = null;
        if (this.instanceHead === null) {
          this.instanceHead = obj;
        } else {
          this.instanceTail.linkInstance = obj;
        }
        this.instanceTail = obj;
        if (obj.isButton) {
          this.hasButton = true;
        }
      }
      this.displayList[depth] = obj;
      obj.execCount = this.movieExecCount;
      obj.exec(matrixId, colorTransformId);
    };

    Movie.prototype.override = function(m, c) {
      this.overriding = true;
      Utility.copyMatrix(this.matrix, m);
      Utility.copyColorTransform(this.lwf, this.colorTransform, c);
      this.lwf.isPropertyDirty = true;
    };

    Movie.prototype.exec = function(matrixId, colorTransformId) {
      if (matrixId == null) {
        matrixId = 0;
      }
      if (colorTransformId == null) {
        colorTransformId = 0;
      }
      this.attachMovieExeced = false;
      this.attachMoviePostExeced = false;
      Movie.__super__.exec.call(this, matrixId, colorTransformId);
    };

    Movie.prototype.postExec = function(progressing) {
      var animationPlayed, attachName, control, controlAnimationOffset, ctrl, data, depth, frame, func, funcs, i, instance, k, movie, obj, p, postExeced, v, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      this.hasButton = false;
      if (!this.active) {
        return;
      }
      this.execedFrame = -1;
      postExeced = this.postExecCount === this.lwf.execCount;
      if (progressing && this.playing && !this.jumped && !postExeced) {
        ++this.currentFrameInternal;
      }
      while (true) {
        if (this.currentFrameInternal < 0 || this.currentFrameInternal >= this.totalFrames) {
          this.currentFrameInternal = 0;
        }
        if (this.currentFrameInternal === this.execedFrame) {
          break;
        }
        this.currentFrameCurrent = this.currentFrameInternal;
        this.execedFrame = this.currentFrameCurrent;
        data = this.lwf.data;
        frame = data.frames[this.data.frameOffset + this.currentFrameCurrent];
        if (this.lastControlOffset === frame.controlOffset && this.lastControls === frame.controls) {
          controlAnimationOffset = this.lastControlAnimationOffset;
          if (this.skipped) {
            instance = this.instanceHead;
            while (instance !== null) {
              if (instance.isMovie) {
                instance.attachMovieExeced = false;
                instance.attachMoviePostExeced = false;
              } else if (instance.isButton) {
                instance.enterFrame();
              }
              instance = instance.linkInstance;
            }
            this.hasButton = this.lastHasButton;
          } else {
            for (depth = _i = 0, _ref = this.data.depths; 0 <= _ref ? _i < _ref : _i > _ref; depth = 0 <= _ref ? ++_i : --_i) {
              obj = this.displayList[depth];
              if (obj != null) {
                if (!postExeced) {
                  obj.matrixIdChanged = false;
                  obj.colorTransformIdChanged = false;
                }
                if (obj.isMovie) {
                  obj.attachMovieExeced = false;
                  obj.attachMoviePostExeced = false;
                } else if (obj.isButton) {
                  obj.enterFrame();
                  this.hasButton = true;
                }
              }
            }
            this.lastHasButton = this.hasButton;
            this.skipped = true;
          }
        } else {
          ++this.movieExecCount;
          this.instanceHead = null;
          this.instanceTail = null;
          this.lastControlOffset = frame.controlOffset;
          this.lastControls = frame.controls;
          controlAnimationOffset = -1;
          for (i = _j = 0, _ref1 = frame.controls; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            control = data.controls[frame.controlOffset + i];
            switch (control.controlType) {
              case ControlType.MOVE:
                p = data.places[control.controlId];
                this.execObject(p.depth, p.objectId, p.matrixId, 0, p.instanceId, p.blendMode);
                break;
              case ControlType.MOVEM:
                ctrl = data.controlMoveMs[control.controlId];
                p = data.places[ctrl.placeId];
                this.execObject(p.depth, p.objectId, ctrl.matrixId, 0, p.instanceId, p.blendMode);
                break;
              case ControlType.MOVEC:
                ctrl = data.controlMoveCs[control.controlId];
                p = data.places[ctrl.placeId];
                this.execObject(p.depth, p.objectId, p.matrixId, ctrl.colorTransformId, p.instanceId, p.blendMode);
                break;
              case ControlType.MOVEMC:
                ctrl = data.controlMoveMCs[control.controlId];
                p = data.places[ctrl.placeId];
                this.execObject(p.depth, p.objectId, ctrl.matrixId, ctrl.colorTransformId, p.instanceId, p.blendMode);
                break;
              case ControlType.MOVEMCB:
                ctrl = data.controlMoveMCBs[control.controlId];
                p = data.places[ctrl.placeId];
                this.execObject(p.depth, p.objectId, ctrl.matrixId, ctrl.colorTransformId, p.instanceId, ctrl.blendMode, true);
                break;
              case ControlType.ANIMATION:
                if (controlAnimationOffset === -1) {
                  controlAnimationOffset = i;
                }
            }
          }
          this.lastControlAnimationOffset = controlAnimationOffset;
          this.lastHasButton = this.hasButton;
          for (depth = _k = 0, _ref2 = this.data.depths; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; depth = 0 <= _ref2 ? ++_k : --_k) {
            obj = this.displayList[depth];
            if ((obj != null) && obj.execCount !== this.movieExecCount) {
              obj.destroy();
              this.displayList[depth] = null;
            }
          }
        }
        this.attachMovieExeced = true;
        if (this.attachedMovies != null) {
          _ref3 = this.attachedMovieListKeys;
          for (_l = 0, _len = _ref3.length; _l < _len; _l++) {
            k = _ref3[_l];
            movie = this.attachedMovieList[k];
            movie.exec();
          }
        }
        instance = this.instanceHead;
        while (instance !== null) {
          if (instance.isMovie) {
            movie = instance;
            movie.postExec(progressing);
            if (!this.hasButton && movie.hasButton) {
              this.hasButton = true;
            }
          }
          instance = instance.linkInstance;
        }
        this.attachMoviePostExeced = true;
        if (this.attachedMovies != null) {
          _ref4 = this.detachedMovies;
          for (attachName in _ref4) {
            v = _ref4[attachName];
            movie = this.attachedMovies[attachName];
            if (movie != null) {
              this.deleteAttachedMovie(this, movie, true, false);
            }
          }
          this.detachedMovies = {};
          _ref5 = this.attachedMovieListKeys;
          for (_m = 0, _len1 = _ref5.length; _m < _len1; _m++) {
            k = _ref5[_m];
            movie = this.attachedMovieList[k];
            movie.postExec(progressing);
            if (!this.hasButton && movie.hasButton) {
              this.hasButton = true;
            }
          }
        }
        if (this.attachedLWFs != null) {
          this.hasButton = true;
        }
        if (!this.postLoaded) {
          this.postLoaded = true;
          if (this.postLoadFunc != null) {
            this.postLoadFunc.call(this);
          }
          if (!this.handler.empty) {
            this.handler.call("postLoad", this);
          }
        }
        if (this.nextEnterFrameFunctions != null) {
          funcs = this.nextEnterFrameFunctions;
          this.nextEnterFrameFunctions = null;
          for (_n = 0, _len2 = funcs.length; _n < _len2; _n++) {
            func = funcs[_n];
            func.call(this);
          }
        }
        if (controlAnimationOffset !== -1 && this.execedFrame === this.currentFrameInternal) {
          animationPlayed = this.animationPlayedFrame === this.currentFrameCurrent && !this.jumped;
          if (!animationPlayed) {
            for (i = _o = controlAnimationOffset, _ref6 = frame.controls; controlAnimationOffset <= _ref6 ? _o < _ref6 : _o > _ref6; i = controlAnimationOffset <= _ref6 ? ++_o : --_o) {
              control = data.controls[frame.controlOffset + i];
              this.lwf.playAnimation(control.controlId, this);
            }
          }
        }
        this.animationPlayedFrame = this.currentFrameCurrent;
        if (this.currentFrameCurrent === this.currentFrameInternal) {
          this.jumped = false;
        }
      }
      if (this.postExecCount !== this.lwf.execCount) {
        if (this.enterFrameFunc != null) {
          this.enterFrameFunc.call(this);
        }
        this.playAnimation(ClipEvent.ENTERFRAME);
        if (!this.handler.empty) {
          this.handler.call("enterFrame", this);
        }
      }
      this.postExecCount = this.lwf.execCount;
    };

    Movie.prototype.execAttachedLWF = function(tick, currentProgress) {
      var attachName, child, hasButton, instance, k, lwfContainer, movie, v, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      hasButton = false;
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie) {
          hasButton |= instance.execAttachedLWF(tick, currentProgress);
        }
        instance = instance.linkInstance;
      }
      if (this.attachedMovies != null) {
        _ref = this.attachedMovieListKeys;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          k = _ref[_i];
          movie = this.attachedMovieList[k];
          hasButton |= movie.execAttachedLWF(tick, currentProgress);
        }
      }
      if (this.attachedLWFs != null) {
        _ref1 = this.detachedLWFs;
        for (attachName in _ref1) {
          v = _ref1[attachName];
          lwfContainer = this.attachedLWFs[attachName];
          if (lwfContainer != null) {
            this.deleteAttachedLWF(this, lwfContainer, true, false);
          }
        }
        this.detachedLWFs = {};
        _ref2 = this.attachedLWFListKeys;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          k = _ref2[_j];
          lwfContainer = this.attachedLWFList[k];
          child = lwfContainer.child;
          if (child.tick === this.lwf.tick) {
            child.progress = currentProgress;
          }
          this.lwf.renderObject(child.execInternal(tick));
          hasButton |= child.rootMovie.hasButton;
        }
      }
      return hasButton;
    };

    Movie.prototype.updateObject = function(obj, m, c, matrixChanged, colorTransformChanged) {
      var objc, objm;
      if (obj.isMovie && obj.property.hasMatrix) {
        objm = m;
      } else if (matrixChanged || !obj.updated || obj.matrixIdChanged) {
        objm = Utility.calcMatrixId(this.lwf, this.matrix1, m, obj.matrixId);
      } else {
        objm = null;
      }
      if (obj.isMovie && obj.property.hasColorTransform) {
        objc = c;
      } else if (colorTransformChanged || !obj.updated || obj.colorTransformIdChanged) {
        objc = Utility.calcColorTransformId(this.lwf, this.colorTransform1, c, obj.colorTransformId);
      } else {
        objc = null;
      }
      obj.update(objm, objc);
    };

    Movie.prototype.update = function(m, c) {
      var bitmapClip, colorTransformChanged, depth, k, matrixChanged, movie, obj, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
      if (!this.active) {
        return;
      }
      if (this.overriding) {
        matrixChanged = true;
        colorTransformChanged = true;
      } else {
        matrixChanged = this.matrix.setWithComparing(m);
        colorTransformChanged = this.colorTransform.setWithComparing(c);
      }
      if (this.property.hasMatrix) {
        matrixChanged = true;
        m = Utility.calcMatrix(this.matrix0, this.matrix, this.property.matrix);
      } else {
        m = this.matrix;
      }
      if (this.property.hasColorTransform) {
        colorTransformChanged = true;
        c = Utility.calcColorTransform(this.lwf, this.colorTransform0, this.colorTransform, this.property.colorTransform);
      } else {
        c = this.colorTransform;
      }
      if (this.attachedLWFs != null) {
        this.needsUpdateAttachedLWFs = false;
        this.needsUpdateAttachedLWFs |= this.matrixForAttachedLWFs.setWithComparing(m);
        this.needsUpdateAttachedLWFs |= this.colorTransformForAttachedLWFs.setWithComparing(c);
      }
      for (depth = _i = 0, _ref = this.data.depths; 0 <= _ref ? _i < _ref : _i > _ref; depth = 0 <= _ref ? ++_i : --_i) {
        obj = this.displayList[depth];
        if (obj != null) {
          this.updateObject(obj, m, c, matrixChanged, colorTransformChanged);
        }
      }
      if (this.bitmapClips != null) {
        _ref1 = this.bitmapClips;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          bitmapClip = _ref1[_j];
          if (bitmapClip != null) {
            bitmapClip.update(m, c);
          }
        }
      }
      if (this.attachedMovies != null) {
        _ref2 = this.attachedMovieListKeys;
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          k = _ref2[_k];
          movie = this.attachedMovieList[k];
          this.updateObject(movie, m, c, matrixChanged, colorTransformChanged);
        }
      }
    };

    Movie.prototype.postUpdate = function() {
      var inspector, instance, invert, k, movie, p, _i, _len, _ref;
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie) {
          instance.postUpdate();
        }
        instance = instance.linkInstance;
      }
      if (this.attachedMovies != null) {
        _ref = this.attachedMovieListKeys;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          k = _ref[_i];
          movie = this.attachedMovieList[k];
          movie.postUpdate();
        }
      }
      if (this.requestedCalculateBounds) {
        this.xMin = Number.MAX_VALUE;
        this.xMax = -Number.MAX_VALUE;
        this.yMin = Number.MAX_VALUE;
        this.yMax = -Number.MAX_VALUE;
        inspector = (function(_this) {
          return function(o, h, d, r) {
            return _this.calculateBounds(o);
          };
        })(this);
        this.inspect(inspector, 0, 0);
        if (this.lwf.property.hasMatrix) {
          invert = new Matrix();
          Utility.invertMatrix(invert, this.lwf.property.matrix);
          p = Utility.calcMatrixToPoint(this.xMin, this.yMin, invert);
          this.xMin = p[0];
          this.yMin = p[1];
          p = Utility.calcMatrixToPoint(this.xMax, this.yMax, invert);
          this.xMax = p[0];
          this.yMax = p[1];
        }
        this.bounds = {
          "xMin": this.xMin,
          "xMax": this.xMax,
          "yMin": this.yMin,
          "yMax": this.yMax
        };
        this.requestedCalculateBounds = false;
        if (this.calculateBoundsCallback != null) {
          this.calculateBoundsCallback.call(this);
          this.calculateBoundsCallback = null;
        }
      }
      if (!this.handler.empty) {
        this.handler.call("update", this);
      }
    };

    Movie.prototype.updateAttachedLWF = function() {
      var child, instance, k, lwfContainer, movie, needsUpdateAttachedLWFs, _i, _j, _len, _len1, _ref, _ref1;
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie) {
          instance.updateAttachedLWF();
        }
        instance = instance.linkInstance;
      }
      if (this.attachedMovies != null) {
        _ref = this.attachedMovieListKeys;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          k = _ref[_i];
          movie = this.attachedMovieList[k];
          movie.updateAttachedLWF();
        }
      }
      if (this.attachedLWFs != null) {
        _ref1 = this.attachedLWFListKeys;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          k = _ref1[_j];
          lwfContainer = this.attachedLWFList[k];
          child = lwfContainer.child;
          needsUpdateAttachedLWFs = child.needsUpdate || this.needsUpdateAttachedLWFs;
          if (needsUpdateAttachedLWFs) {
            child.update(this.matrixForAttachedLWFs, this.colorTransformForAttachedLWFs);
          }
          if (child.isLWFAttached) {
            child.rootMovie.updateAttachedLWF();
          }
          if (needsUpdateAttachedLWFs) {
            child.rootMovie.postUpdate();
          }
        }
      }
    };

    Movie.prototype.calculateBounds = function(o) {
      var obj, pobj, text, tf, tfId, _i, _len, _ref;
      tfId = null;
      switch (o.type) {
        case Type.GRAPHIC:
          _ref = o.displayList;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            obj = _ref[_i];
            this.calculateBounds(obj);
          }
          break;
        case Type.BITMAP:
        case Type.BITMAPEX:
          if (o.type === Type.BITMAP) {
            tfId = o.lwf.data.bitmaps[o.objectId].textureFragmentId;
          } else {
            tfId = o.lwf.data.bitmapExs[o.objectId].textureFragmentId;
          }
          if ((tfId != null) && tfId >= 0) {
            tf = o.lwf.data.textureFragments[tfId];
            this.updateBounds(o.matrix, tf.x, tf.x + tf.w, tf.y, tf.y + tf.h);
          }
          break;
        case Type.BUTTON:
          this.updateBounds(o.matrix, 0, o.width, 0, o.height);
          break;
        case Type.TEXT:
          text = o.lwf.data.texts[o.objectId];
          this.updateBounds(o.matrix, 0, text.width, 0, text.height);
          break;
        case Type.PROGRAMOBJECT:
          pobj = o.lwf.data.programObjects[o.objectId];
          this.updateBounds(o.matrix, 0, pobj.width, 0, pobj.height);
      }
    };

    Movie.prototype.updateBounds = function(matrix, xmin, xmax, ymin, ymax) {
      var p, x, y, _i, _len, _ref, _ref1;
      _ref = [[xmin, ymin], [xmin, ymax], [xmax, ymin], [xmax, ymax]];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _ref1 = Utility.calcMatrixToPoint(p[0], p[1], matrix), x = _ref1[0], y = _ref1[1];
        if (x < this.xMin) {
          this.xMin = x;
        } else if (x > this.xMax) {
          this.xMax = x;
        }
        if (y < this.yMin) {
          this.yMin = y;
        } else if (y > this.yMax) {
          this.yMax = y;
        }
      }
    };

    Movie.prototype.linkButton = function() {
      var depth, k, lwfContainer, movie, obj, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
      if (!this.visible || !this.active || !this.hasButton) {
        return;
      }
      for (depth = _i = 0, _ref = this.data.depths; 0 <= _ref ? _i < _ref : _i > _ref; depth = 0 <= _ref ? ++_i : --_i) {
        obj = this.displayList[depth];
        if (obj != null) {
          if (obj.isButton) {
            obj.linkButton();
          } else if (obj.isMovie) {
            if (obj.hasButton) {
              obj.linkButton();
            }
          }
        }
      }
      if (this.attachedMovies != null) {
        _ref1 = this.attachedMovieListKeys;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          k = _ref1[_j];
          movie = this.attachedMovieList[k];
          if (movie.hasButton) {
            movie.linkButton();
          }
        }
      }
      if (this.attachedLWFs != null) {
        _ref2 = this.attachedLWFListKeys;
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          k = _ref2[_k];
          lwfContainer = this.attachedLWFList[k];
          lwfContainer.linkButton();
        }
      }
    };

    Movie.prototype.render = function(v, rOffset) {
      var attachedMovie, bitmapClip, child, depth, k, lwfContainer, obj, useBlendMode, useMaskMode, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      if (!this.active && (this.lwf.rendererFactory.needsRenderForInactive == null)) {
        return;
      }
      if (!this.visible || !this.active) {
        v = false;
      }
      useBlendMode = false;
      useMaskMode = false;
      if (this.blendMode !== "normal") {
        switch (this.blendMode) {
          case "add":
          case "multiply":
          case "screen":
          case "subtract":
            this.lwf.beginBlendMode(this.blendMode);
            useBlendMode = true;
            break;
          case "erase":
          case "layer":
          case "mask":
          case "alpha":
            this.lwf.beginMaskMode(this.blendMode);
            useMaskMode = true;
        }
      }
      if (!this.handler.empty) {
        this.handler.call("render", this);
      }
      if (this.property.hasRenderingOffset) {
        this.lwf.renderOffset();
        rOffset = this.property.renderingOffset;
      }
      if (rOffset === Number.MIN_VALUE) {
        this.lwf.clearRenderOffset();
      }
      for (depth = _i = 0, _ref = this.data.depths; 0 <= _ref ? _i < _ref : _i > _ref; depth = 0 <= _ref ? ++_i : --_i) {
        obj = this.displayList[depth];
        if (obj != null) {
          obj.render(v, rOffset);
        }
      }
      if (this.bitmapClips != null) {
        _ref1 = this.bitmapClips;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          bitmapClip = _ref1[_j];
          if (bitmapClip != null) {
            bitmapClip.render(v && bitmapClip.visible, rOffset);
          }
        }
      }
      if (this.attachedMovies != null) {
        _ref2 = this.attachedMovieListKeys;
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          k = _ref2[_k];
          attachedMovie = this.attachedMovieList[k];
          attachedMovie.render(v, rOffset);
        }
      }
      if (this.attachedLWFs != null) {
        _ref3 = this.attachedLWFListKeys;
        for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
          k = _ref3[_l];
          lwfContainer = this.attachedLWFList[k];
          child = lwfContainer.child;
          child.setAttachVisible(v);
          this.lwf.renderObject(child.render(this.lwf.renderingIndex, this.lwf.renderingCount, rOffset));
        }
      }
      if (useBlendMode) {
        this.lwf.endBlendMode();
      }
      if (useMaskMode) {
        this.lwf.endMaskMode();
      }
    };

    Movie.prototype.inspect = function(inspector, hierarchy, depth) {
      var attachedMovie, bitmapClip, child, d, k, lwfContainer, obj, rOffset, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      if (this.property.hasRenderingOffset) {
        this.lwf.renderOffset();
        rOffset = this.property.renderingOffset;
      }
      if (rOffset === Number.MIN_VALUE) {
        this.lwf.clearRenderOffset();
      }
      inspector(this, hierarchy, depth, rOffset);
      ++hierarchy;
      for (d = _i = 0, _ref = this.data.depths; 0 <= _ref ? _i < _ref : _i > _ref; d = 0 <= _ref ? ++_i : --_i) {
        obj = this.displayList[d];
        if (obj != null) {
          obj.inspect(inspector, hierarchy, d, rOffset);
        }
      }
      if (this.bitmapClips != null) {
        _ref1 = this.bitmapClips;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          bitmapClip = _ref1[_j];
          if (bitmapClip != null) {
            bitmapClip.inspect(inspector, hierarchy, d++, rOffset);
          }
        }
      }
      if (this.attachedMovies != null) {
        _ref2 = this.attachedMovieListKeys;
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          k = _ref2[_k];
          attachedMovie = this.attachedMovieList[k];
          attachedMovie.inspect(inspector, hierarchy, d++, rOffset);
        }
      }
      if (this.attachedLWFs != null) {
        _ref3 = this.attachedLWFListKeys;
        for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
          k = _ref3[_l];
          lwfContainer = this.attachedLWFList[k];
          child = lwfContainer.child;
          this.lwf.renderObject(child.inspect(inspector, hierarchy, d++, rOffset));
        }
      }
    };

    Movie.prototype.destroy = function() {
      var bitmapClip, k, lwfContainer, movie, obj, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      _ref = this.displayList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        if (obj != null) {
          obj.destroy();
        }
      }
      if (this.bitmapClips != null) {
        _ref1 = this.bitmapClips;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          bitmapClip = _ref1[_j];
          if (bitmapClip != null) {
            bitmapClip.destroy();
          }
        }
        this.bitmapClips = null;
      }
      if (this.attachedMovies != null) {
        _ref2 = this.attachedMovies;
        for (k in _ref2) {
          movie = _ref2[k];
          movie.destroy();
        }
        this.attachedMovies = null;
        this.detachedMovies = null;
        this.attachedMovieList = null;
        this.attachedMovieListKeys = null;
      }
      if (this.attachedLWFs != null) {
        _ref3 = this.attachedLWFs;
        for (k in _ref3) {
          lwfContainer = _ref3[k];
          this.execDetachHandler(lwfContainer);
        }
        this.attachedLWFs = null;
        this.detachedLWFs = null;
        this.attachedLWFList = null;
        this.attachedLWFListKeys = null;
      }
      if (this.unloadFunc != null) {
        this.unloadFunc.call(this);
      }
      this.playAnimation(ClipEvent.UNLOAD);
      if (!this.handler.empty) {
        this.handler.call("unload", this);
      }
      this.instanceHead = null;
      this.instanceTail = null;
      this.displayList = null;
      this.property = null;
      Movie.__super__.destroy.call(this);
    };

    Movie.prototype.playAnimation = function(clipEvent) {
      var c, clipEvents, i, _i, _ref;
      clipEvents = this.lwf.data.movieClipEvents;
      for (i = _i = 0, _ref = this.data.clipEvents; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        c = clipEvents[this.data.clipEventId + i];
        if ((c.clipEvent & clipEvent) !== 0) {
          this.lwf.playAnimation(c.animationId, this);
        }
      }
    };

    Movie.prototype.dispatchEvent = function(e) {
      var handler, handlers, param, _i, _len;
      if (typeof e === "object") {
        param = e["param"];
        e = e["type"];
      } else {
        param = null;
      }
      switch (e) {
        case "load":
        case "postLoad":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
          if (!this.handler.empty) {
            this.handler.call(e, this);
          }
          break;
        default:
          handlers = this.eventHandlers[e];
          if (handlers == null) {
            return false;
          }
          handlers = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = handlers.length; _i < _len; _i++) {
              handler = handlers[_i];
              _results.push(handler);
            }
            return _results;
          })();
          for (_i = 0, _len = handlers.length; _i < _len; _i++) {
            handler = handlers[_i];
            if (handler != null) {
              handler.call(this, {
                "type": e,
                "param": param
              });
            }
          }
      }
      return true;
    };

    Movie.prototype.addEventHandler = function(e, eventHandler) {
      var _base;
      switch (e) {
        case "load":
        case "postLoad":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
          this.lwf.enableExec();
          this.handler.addHandler(e, eventHandler);
          break;
        default:
          if ((_base = this.eventHandlers)[e] == null) {
            _base[e] = [];
          }
          this.eventHandlers[e].push(eventHandler);
      }
    };

    Movie.prototype.removeEventHandler = function(e, eventHandler) {
      var handlers, i;
      switch (e) {
        case "load":
        case "postLoad":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
          this.handler.removeHandler(e, eventHandler);
          break;
        default:
          handlers = this.eventHandlers[e];
          if (handlers == null) {
            return;
          }
          i = 0;
          while (i < handlers.length) {
            if (handlers[i] === eventHandler) {
              handlers.splice(i, 1);
            } else {
              ++i;
            }
          }
          if (handlers.length === 0) {
            delete this.eventHandlers[e];
          }
      }
    };

    Movie.prototype.clearEventHandler = function(e) {
      if (e == null) {
        e = null;
      }
      switch (e) {
        case null:
          this.handler.clear();
          this.eventHandlers = {};
          break;
        case "load":
        case "postLoad":
        case "unload":
        case "enterFrame":
        case "update":
        case "render":
          this.handler.clear(e);
          break;
        default:
          delete this.eventHandlers[e];
      }
    };

    Movie.prototype.setEventHandler = function(e, eventHandler) {
      this.clearEventHandler(e);
      this.addEventHandler(e, eventHandler);
    };

    Movie.prototype.nextEnterFrame = function(func) {
      if (this.nextEnterFrameFunctions == null) {
        this.nextEnterFrameFunctions = [];
      }
      this.nextEnterFrameFunctions.push(func);
    };

    Movie.prototype.searchFrame = function(label) {
      return this.lwf.searchFrame(this, label);
    };

    Movie.prototype.gotoLabel = function(label) {
      if (typeof label === "string") {
        label = this.lwf.getStringId(label);
      }
      this.gotoFrame(this.lwf.searchFrame(this, label));
      return this;
    };

    Movie.prototype.gotoAndStop = function(n) {
      if (typeof n === "string") {
        this.gotoFrame(this.lwf.searchFrame(this, this.lwf.getStringId(n)));
      } else {
        this.gotoFrame(n);
      }
      this.stop();
      return this;
    };

    Movie.prototype.gotoAndPlay = function(n) {
      if (typeof n === "string") {
        this.gotoFrame(this.lwf.searchFrame(this, this.lwf.getStringId(n)));
      } else {
        this.gotoFrame(n);
      }
      this.play();
      return this;
    };

    Movie.prototype.searchMovieInstance = function(stringId, recursive) {
      var i, instance;
      if (recursive == null) {
        recursive = true;
      }
      if (typeof stringId === "string") {
        stringId = this.lwf.getStringId(stringId);
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie && this.lwf.getInstanceNameStringId(instance.instanceId) === stringId) {
          return instance;
        } else if (recursive && instance.isMovie) {
          i = instance.searchMovieInstance(stringId, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.searchMovieInstanceByInstanceId = function(instId, recursive) {
      var i, instance;
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie && instance.instanceId === instId) {
          return instance;
        } else if (recursive && instance.isMovie) {
          i = instance.searchMovieInstanceByInstanceId(instId, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.searchButtonInstance = function(stringId, recursive) {
      var i, instance;
      if (recursive == null) {
        recursive = true;
      }
      if (typeof stringId === "string") {
        stringId = this.lwf.getStringId(stringId);
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isButton && this.lwf.getInstanceNameStringId(instance.instanceId) === stringId) {
          return instance;
        } else if (recursive && instance.isMovie) {
          i = instance.searchButtonInstance(stringId, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.searchButtonInstanceByInstanceId = function(instId, recursive) {
      var i, instance;
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isButton && instance.instanceId === instId) {
          return instance;
        } else if (recursive && instance.isMovie) {
          i = instance.searchMovieInstanceByInstanceId(instId, recursive);
          if (i !== null) {
            return i;
          }
        }
        instance = instance.linkInstance;
      }
      return null;
    };

    Movie.prototype.move = function(x, y) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.move(x, y);
      return this;
    };

    Movie.prototype.moveTo = function(x, y) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.moveTo(x, y);
      return this;
    };

    Movie.prototype.rotate = function(degree) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.rotate(degree);
      return this;
    };

    Movie.prototype.rotateTo = function(degree) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.rotateTo(degree);
      return this;
    };

    Movie.prototype.scale = function(x, y) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.scale(x, y);
      return this;
    };

    Movie.prototype.scaleTo = function(x, y) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.scaleTo(x, y);
      return this;
    };

    Movie.prototype.setMatrix = function(m, scaleX, scaleY, rotation) {
      if (scaleX == null) {
        scaleX = 1;
      }
      if (scaleY == null) {
        scaleY = 1;
      }
      if (rotation == null) {
        rotation = 0;
      }
      this.property.setMatrix(m, scaleX, scaleY, rotation);
      return this;
    };

    Movie.prototype.setAlpha = function(alpha) {
      if (!this.property.hasColorTransform) {
        Utility.syncColorTransform(this);
      }
      this.property.setAlpha(alpha);
      return this;
    };

    Movie.prototype.setColorTransform = function(c) {
      this.property.setColorTransform(c);
      return this;
    };

    Movie.prototype.setRenderingOffset = function(rOffset) {
      this.property.setRenderingOffset(rOffset);
      return this;
    };

    Movie.prototype.getX = function() {
      if (this.property.hasMatrix) {
        return this.property.matrix.translateX;
      } else {
        return Utility.getX(this);
      }
    };

    Movie.prototype.setX = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.moveTo(v, this.property.matrix.translateY);
    };

    Movie.prototype.getY = function() {
      if (this.property.hasMatrix) {
        return this.property.matrix.translateY;
      } else {
        return Utility.getY(this);
      }
    };

    Movie.prototype.setY = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.moveTo(this.property.matrix.translateX, v);
    };

    Movie.prototype.getScaleX = function() {
      if (this.property.hasMatrix) {
        return this.property.scaleX;
      } else {
        return Utility.getScaleX(this);
      }
    };

    Movie.prototype.setScaleX = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.scaleTo(v, this.property.scaleY);
    };

    Movie.prototype.getScaleY = function() {
      if (this.property.hasMatrix) {
        return this.property.scaleY;
      } else {
        return Utility.getScaleY(this);
      }
    };

    Movie.prototype.setScaleY = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.scaleTo(this.property.scaleX, v);
    };

    Movie.prototype.getRotation = function() {
      if (this.property.hasMatrix) {
        return this.property.rotation;
      } else {
        return Utility.getRotation(this);
      }
    };

    Movie.prototype.setRotation = function(v) {
      if (!this.property.hasMatrix) {
        Utility.syncMatrix(this);
      }
      this.property.rotateTo(v);
    };

    Movie.prototype.getAlphaProperty = function() {
      if (this.property.hasColorTransform) {
        return this.property.colorTransform.multi.alpha;
      } else {
        return Utility.getAlpha(this);
      }
    };

    Movie.prototype.setAlphaProperty = function(v) {
      if (!this.property.hasColorTransform) {
        Utility.syncColorTransform(this);
      }
      this.property.setAlpha(v);
    };

    Movie.prototype.requestCalculateBounds = function(callback) {
      if (callback == null) {
        callback = null;
      }
      this.requestedCalculateBounds = true;
      this.calculateBoundsCallback = callback;
      this.bounds = void 0;
    };

    Movie.prototype.getBounds = function() {
      return this.bounds;
    };

    Movie.prototype.setFrameRate = function(frameRate) {
      var instance, k, lwfContainer, movie, _i, _j, _len, _len1, _ref, _ref1;
      if (this.attachedMovies != null) {
        _ref = this.attachedMovieListKeys;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          k = _ref[_i];
          movie = this.attachedMovieList[k];
          movie.setFrameRate(frameRate);
        }
      }
      if (this.attachedLWFs != null) {
        _ref1 = this.attachedLWFListKeys;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          k = _ref1[_j];
          lwfContainer = this.attachedLWFList[k];
          lwfContainer.child.setFrameRate(frameRate);
        }
      }
      instance = this.instanceHead;
      while (instance !== null) {
        if (instance.isMovie) {
          instance.setFrameRate(frameRate);
        }
        instance = instance.linkInstance;
      }
    };

    Movie.prototype.cacheCurrentLabels = function() {
      var frameNo, labels, map, stringId;
      if (this.currentLabelsCache == null) {
        this.currentLabelsCache = [];
        labels = this.lwf.getMovieLabels(this);
        if (labels != null) {
          for (stringId in labels) {
            frameNo = labels[stringId];
            map = {};
            map["frame"] = frameNo + 1;
            map["name"] = this.lwf.data.strings[stringId];
            this.currentLabelsCache.push(map);
          }
          this.currentLabelsCache.sort(function(a, b) {
            return a["frame"] - b["frame"];
          });
        }
      }
    };

    Movie.prototype.getCurrentLabel = function() {
      var currentFrame, firstLabel, l, labelName, lastLabel, ln, n, nn, r, rn;
      this.cacheCurrentLabels();
      if (this.currentLabelsCache.length === 0) {
        return null;
      }
      currentFrame = this.currentFrameInternal + 1;
      if (currentFrame < 1) {
        currentFrame = 1;
      }
      labelName = this.currentLabelCache[currentFrame];
      if (labelName == null) {
        firstLabel = this.currentLabelsCache[0];
        lastLabel = this.currentLabelsCache[this.currentLabelsCache.length - 1];
        if (currentFrame < firstLabel["frame"]) {
          labelName = "";
        } else if (currentFrame === firstLabel["frame"]) {
          labelName = firstLabel["name"];
        } else if (currentFrame >= lastLabel["frame"]) {
          labelName = lastLabel["name"];
        } else {
          l = 0;
          ln = this.currentLabelsCache[l]["frame"];
          r = this.currentLabelsCache.length - 1;
          rn = this.currentLabelsCache[r]["frame"];
          while (true) {
            if (l === r || r - l === 1) {
              if (currentFrame < ln) {
                labelName = "";
              } else if (currentFrame === rn) {
                labelName = this.currentLabelsCache[r]["name"];
              } else {
                labelName = this.currentLabelsCache[l]["name"];
              }
              break;
            }
            n = Math.floor((r - l) / 2) + l;
            nn = this.currentLabelsCache[n]["frame"];
            if (currentFrame < nn) {
              r = n;
              rn = nn;
            } else if (currentFrame > nn) {
              l = n;
              ln = nn;
            } else {
              labelName = this.currentLabelsCache[n]["name"];
              break;
            }
          }
        }
        this.currentLabelCache[currentFrame] = labelName;
      }
      if (labelName === "") {
        return null;
      } else {
        return labelName;
      }
    };

    Movie.prototype.getCurrentLabels = function() {
      this.cacheCurrentLabels();
      return this.currentLabelsCache;
    };

    return Movie;

  })(IObject);

  if (typeof Movie.prototype.__defineGetter__ !== "undefined") {
    Movie.prototype.__defineGetter__("x", function() {
      return this.getX();
    });
    Movie.prototype.__defineSetter__("x", function(v) {
      return this.setX(v);
    });
    Movie.prototype.__defineGetter__("y", function() {
      return this.getY();
    });
    Movie.prototype.__defineSetter__("y", function(v) {
      return this.setY(v);
    });
    Movie.prototype.__defineGetter__("scaleX", function() {
      return this.getScaleX();
    });
    Movie.prototype.__defineSetter__("scaleX", function(v) {
      return this.setScaleX(v);
    });
    Movie.prototype.__defineGetter__("scaleY", function() {
      return this.getScaleY();
    });
    Movie.prototype.__defineSetter__("scaleY", function(v) {
      return this.setScaleY(v);
    });
    Movie.prototype.__defineGetter__("rotation", function() {
      return this.getRotation();
    });
    Movie.prototype.__defineSetter__("rotation", function(v) {
      return this.setRotation(v);
    });
    Movie.prototype.__defineGetter__("alpha", function() {
      return this.getAlphaProperty();
    });
    Movie.prototype.__defineSetter__("alpha", function(v) {
      return this.setAlphaProperty(v);
    });
    Movie.prototype.__defineGetter__("currentFrame", function() {
      return this.currentFrameInternal + 1;
    });
    Movie.prototype.__defineGetter__("currentLabel", function() {
      return this.getCurrentLabel();
    });
    Movie.prototype.__defineGetter__("currentLabels", function() {
      return this.getCurrentLabels();
    });
  } else if (typeof Object.defineProperty !== "undefined") {
    Object.defineProperty(Movie.prototype, "x", {
      get: function() {
        return this.getX();
      },
      set: function(v) {
        return this.setX(v);
      }
    });
    Object.defineProperty(Movie.prototype, "y", {
      get: function() {
        return this.getY();
      },
      set: function(v) {
        return this.setY(v);
      }
    });
    Object.defineProperty(Movie.prototype, "scaleX", {
      get: function() {
        return this.getScaleX();
      },
      set: function(v) {
        return this.setScaleX(v);
      }
    });
    Object.defineProperty(Movie.prototype, "scaleY", {
      get: function() {
        return this.getScaleY();
      },
      set: function(v) {
        return this.setScaleY(v);
      }
    });
    Object.defineProperty(Movie.prototype, "rotation", {
      get: function() {
        return this.getRotation();
      },
      set: function(v) {
        return this.setRotation(v);
      }
    });
    Object.defineProperty(Movie.prototype, "alpha", {
      get: function() {
        return this.getAlphaProperty();
      },
      set: function(v) {
        return this.setAlphaProperty(v);
      }
    });
    Object.defineProperty(Movie.prototype, "currentFrame", {
      get: function() {
        return this.currentFrameInternal + 1;
      }
    });
    Object.defineProperty(Movie.prototype, "currentLabel", {
      get: function() {
        return this.getCurrentLabel();
      }
    });
    Object.defineProperty(Movie.prototype, "currentLabels", {
      get: function() {
        return this.getCurrentLabels();
      }
    });
  }

  EventHandlers = (function() {
    function EventHandlers() {
      this.clear();
    }

    EventHandlers.prototype.clear = function(type) {
      var _i, _len, _ref;
      if (type == null) {
        type = null;
      }
      if (type != null) {
        if (this[type] != null) {
          this[type] = [];
        }
      } else {
        _ref = this.types;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          type = _ref[_i];
          this[type] = [];
        }
      }
      this.empty = true;
    };

    EventHandlers.prototype.add = function(handlers) {
      var handler, type, _i, _len, _ref;
      if (handlers == null) {
        return;
      }
      _ref = this.types;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        handler = handlers[type];
        if (handler != null) {
          this[type].push(handler);
        }
      }
      this.updateEmpty();
    };

    EventHandlers.prototype.concat = function(handlers) {
      var h, handler, type, _i, _j, _len, _len1, _ref;
      if (handlers == null) {
        return;
      }
      if (handlers.empty) {
        return;
      }
      _ref = this.types;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        handler = handlers[type];
        for (_j = 0, _len1 = handler.length; _j < _len1; _j++) {
          h = handler[_j];
          this[type].push(h);
        }
      }
      this.updateEmpty();
    };

    EventHandlers.prototype.addHandler = function(type, handler) {
      if (handler != null) {
        this[type].push(handler);
        this.empty = false;
      }
    };

    EventHandlers.prototype.removeInternal = function(array, handler) {
      var i;
      i = 0;
      while (i < array.length) {
        if (array[i] === handler) {
          array.splice(i, 1);
        } else {
          ++i;
        }
      }
    };

    EventHandlers.prototype.remove = function(handlers) {
      var handler, type, _i, _len, _ref;
      _ref = this.types;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        handler = handlers[type];
        if (handler != null) {
          this.removeInternal(this[type], handler);
        }
      }
      this.updateEmpty();
    };

    EventHandlers.prototype.removeHandler = function(type, handler) {
      if (handler != null) {
        this.removeInternal(this[type], handler);
      }
      this.updateEmpty();
    };

    EventHandlers.prototype.call = function(type, target) {
      var handler, handlers, _i, _len;
      handlers = this[type];
      if ((handlers != null) && handlers.length > 0) {
        handlers = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = handlers.length; _i < _len; _i++) {
            handler = handlers[_i];
            _results.push(handler);
          }
          return _results;
        })();
        for (_i = 0, _len = handlers.length; _i < _len; _i++) {
          handler = handlers[_i];
          handler.call(target, target);
        }
      }
    };

    EventHandlers.prototype.updateEmpty = function() {
      var type, _i, _len, _ref, _ref1;
      _ref = this.types;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        if (((_ref1 = this[type]) != null ? _ref1.length : void 0) > 0) {
          this.empty = false;
          return;
        }
      }
      this.empty = true;
    };

    return EventHandlers;

  })();

  MovieEventHandlers = (function(_super) {
    var TYPES;

    __extends(MovieEventHandlers, _super);

    TYPES = ["load", "postLoad", "unload", "enterFrame", "update", "render"];

    function MovieEventHandlers() {
      this.types = TYPES;
      MovieEventHandlers.__super__.constructor.apply(this, arguments);
    }

    return MovieEventHandlers;

  })(EventHandlers);

  ButtonEventHandlers = (function(_super) {
    var TYPES;

    __extends(ButtonEventHandlers, _super);

    TYPES = ["load", "unload", "enterFrame", "update", "render", "press", "release", "rollOver", "rollOut", "keyPress"];

    function ButtonEventHandlers() {
      this.types = TYPES;
      ButtonEventHandlers.__super__.constructor.apply(this, arguments);
    }

    return ButtonEventHandlers;

  })(EventHandlers);

  LWF = (function() {
    var ROUND_OFF_TICK_RATE;

    ROUND_OFF_TICK_RATE = 1.0 / 60.0 * 0.05;

    LWF.globalRenderCount = 0;

    function LWF(lwfData, rendererFactory, embeddedScript, privateData) {
      if (rendererFactory == null) {
        rendererFactory = null;
      }
      if (embeddedScript == null) {
        embeddedScript = null;
      }
      this.privateData = privateData != null ? privateData : null;
      this.data = lwfData;
      if (embeddedScript != null) {
        this.functions = embeddedScript();
      }
      this.width = this.data.header.width;
      this.height = this.data.header.height;
      this.backgroundColor = this.data.header.backgroundColor;
      this.name = this.data.strings[this.data.header.nameStringId];
      this.interactive = this.data.buttonConditions.length > 0;
      this.url = null;
      this.lwfInstanceId = null;
      this.frameRate = this.data.header.frameRate;
      this.active = true;
      this.fastForwardTimeout = 15;
      this.fastForward = false;
      this.frameSkip = true;
      this.execLimit = 3;
      this.tick = 1.0 / this.frameRate;
      this.roundOffTick = ROUND_OFF_TICK_RATE;
      this.time = 0;
      this.attachVisible = true;
      this.execCount = 0;
      this.renderCount = 0;
      this.isExecDisabled = false;
      this.isPropertyDirty = false;
      this.isLWFAttached = false;
      this.interceptByNotAllowOrDenyButtons = true;
      this.intercepted = false;
      this.needsUpdate = false;
      this.needsUpdateForAttachLWF = false;
      this.textScale = 1;
      this.pointX = Number.MIN_VALUE;
      this.pointY = Number.MIN_VALUE;
      this.pressing = false;
      this.buttonHead = null;
      this.blendModes = [];
      this.maskModes = [];
      this._tweens = null;
      this.useVertexColor = false;
      if (!this.interactive && this.data.frames.length === 1) {
        if (!this.functions || !(this.functions['_root_load'] || this.functions['_root_postLoad'] || this.functions['_root_unload'] || this.functions['_root_enterFrame'] || this.functions['_root_update'] || this.functions['_root_render'])) {
          this.disableExec();
        }
      }
      this.property = new Property(this);
      this.instances = [];
      this.execHandlers = null;
      this.eventHandlers = [];
      this.genericEventHandlers = [];
      this.movieEventHandlers = [];
      this.buttonEventHandlers = [];
      this.movieCommands = {};
      this.programObjectConstructors = [];
      this.loadedLWFs = {};
      this.parent = null;
      this.attachName = null;
      this.depth = null;
      this.matrix = new Matrix;
      this.matrixIdentity = new Matrix;
      this.execMatrix = new Matrix;
      this.colorTransform = new ColorTransform;
      this.colorTransformIdentity = new ColorTransform;
      this.execColorTransform = new ColorTransform;
      this.setRendererFactory(rendererFactory);
      this.init();
    }

    LWF.prototype.setRendererFactory = function(rendererFactory) {
      if (rendererFactory == null) {
        rendererFactory = null;
      }
      if (rendererFactory == null) {
        rendererFactory = new NullRendererFactory();
      }
      this.rendererFactory = rendererFactory;
      this.rendererFactory.init(this);
    };

    LWF.prototype.getRendererFactory = function() {
      var parent;
      if (this.parent != null) {
        parent = this.parent;
        while (parent.parent != null) {
          parent = parent.parent;
        }
        return parent.lwf.rendererFactory;
      } else {
        return this.rendererFactory;
      }
    };

    LWF.prototype.setFrameRate = function(frameRate) {
      if (frameRate === 0) {
        return;
      }
      this.frameRate = frameRate;
      this.tick = 1.0 / this.frameRate;
      if (this.isLWFAttached) {
        this.rootMovie.setFrameRate(frameRate);
      }
    };

    LWF.prototype.setPreferredFrameRate = function(preferredFrameRate, execLimit) {
      if (execLimit == null) {
        execLimit = 2;
      }
      if (preferredFrameRate === 0) {
        return;
      }
      this.execLimit = Math.ceil(this.frameRate / preferredFrameRate) + execLimit;
    };

    LWF.prototype.fitForHeight = function(stageWidth, stageHeight) {
      Utility.fitForHeight(this, stageWidth, stageHeight);
    };

    LWF.prototype.fitForWidth = function(stageWidth, stageHeight) {
      Utility.fitForWidth(this, stageWidth, stageHeight);
    };

    LWF.prototype.scaleForHeight = function(stageWidth, stageHeight) {
      Utility.scaleForHeight(this, stageWidth, stageHeight);
    };

    LWF.prototype.scaleForWidth = function(stageWidth, stageHeight) {
      Utility.scaleForWidth(this, stageWidth, stageHeight);
    };

    LWF.prototype.setTextScale = function(textScale) {
      this.textScale = textScale;
    };

    LWF.prototype.setFont = function(oldFontName, newFontName) {
      this.rendererFactory.setFont(oldFontName, newFontName);
    };

    LWF.prototype.getStageSize = function() {
      var h, w, _ref;
      _ref = this.rendererFactory.getStageSize(), w = _ref[0], h = _ref[1];
      return {
        width: w,
        height: h
      };
    };

    LWF.prototype.renderOffset = function() {
      this.renderingIndexOffsetted = 0;
    };

    LWF.prototype.clearRenderOffset = function() {
      this.renderingIndexOffsetted = this.renderingIndex;
    };

    LWF.prototype.renderObject = function(count) {
      if (count == null) {
        count = 1;
      }
      this.renderingIndex += count;
      this.renderingIndexOffsetted += count;
      return this.renderingIndex;
    };

    LWF.prototype.beginBlendMode = function(blendMode) {
      if (this.parent != null) {
        this.parent.lwf.beginBlendMode(blendMode);
      } else {
        this.blendModes.unshift(blendMode);
        this.rendererFactory.setBlendMode(blendMode);
      }
    };

    LWF.prototype.endBlendMode = function() {
      if (this.parent != null) {
        this.parent.lwf.endBlendMode();
      } else {
        this.blendModes.shift();
        this.rendererFactory.setBlendMode(this.blendModes.length > 0 ? this.blendModes[0] : "normal");
      }
    };

    LWF.prototype.beginMaskMode = function(maskMode) {
      if (this.parent != null) {
        this.parent.lwf.beginMaskMode(maskMode);
      } else {
        this.maskModes.unshift(maskMode);
        this.rendererFactory.setMaskMode(maskMode);
      }
    };

    LWF.prototype.endMaskMode = function() {
      if (this.parent != null) {
        this.parent.lwf.endMaskMode();
      } else {
        this.maskModes.shift();
        this.rendererFactory.setMaskMode(this.maskModes.length > 0 ? this.maskModes[0] : "normal");
      }
    };

    LWF.prototype.setAttachVisible = function(visible) {
      this.attachVisible = visible;
    };

    LWF.prototype.clearFocus = function(button) {
      if (this.focus === button) {
        this.focus = null;
      }
    };

    LWF.prototype.clearPressed = function(button) {
      if (this.pressed === button) {
        this.pressed = null;
      }
    };

    LWF.prototype.clearIntercepted = function() {
      this.intercepted = false;
    };

    LWF.prototype.init = function() {
      this.time = 0;
      this.progress = 0;
      this.instances = [];
      this.focus = null;
      this.pressed = null;
      this.movieCommands = {};
      this.rootMovieStringId = this.getStringId("_root");
      if (this.rootMovie != null) {
        this.rootMovie.destroy();
      }
      this.rootMovie = new Movie(this, null, this.data.header.rootMovieId, this.searchInstanceId(this.rootMovieStringId));
    };

    LWF.prototype.calcMatrix = function(matrix) {
      var m, p;
      p = this.property;
      if (p.hasMatrix) {
        if (matrix != null) {
          m = Utility.calcMatrix(this.matrix, matrix, p.matrix);
        } else {
          m = p.matrix;
        }
      } else {
        m = matrix != null ? matrix : this.matrixIdentity;
      }
      return m;
    };

    LWF.prototype.calcColorTransform = function(colorTransform) {
      var c, p;
      p = this.property;
      if (p.hasColorTransform) {
        if (colorTransform != null) {
          c = Utility.calcColorTransform(this, this.colorTransform, colorTransform, p.colorTransform);
        } else {
          c = p.colorTransform;
        }
      } else {
        c = colorTransform != null ? colorTransform : this.colorTransformIdentity;
      }
      return c;
    };

    LWF.prototype.linkButton = function() {
      this.buttonHead = null;
      if (this.interactive && this.rootMovie.hasButton) {
        this.focusOnLink = false;
        this.rootMovie.linkButton();
        if (this.focus !== null && !this.focusOnLink) {
          this.focus.rollOut();
          this.focus = null;
        }
      }
    };

    LWF.prototype.execInternal = function(tick) {
      var currentProgress, execLimit, execed, handler, handlers, hasButton, progressing, _i, _len;
      if (!((this.rootMovie != null) && this.active)) {
        return 0;
      }
      execed = false;
      currentProgress = this.progress;
      if (this.isExecDisabled && this._tweens === null) {
        if (!this.executedForExecDisabled) {
          ++this.execCount;
          this.rootMovie.exec();
          this.rootMovie.postExec(true);
          this.executedForExecDisabled = true;
          execed = true;
        }
      } else {
        progressing = true;
        if (tick === 0) {
          this.progress = this.tick;
        } else if (tick < 0) {
          this.progress = this.tick;
          progressing = false;
        } else {
          if (this.time === 0) {
            this.time += this.tick;
            this.progress += this.tick;
          } else {
            this.time += tick;
            this.progress += tick;
          }
        }
        handlers = this.execHandlers;
        if (handlers != null) {
          for (_i = 0, _len = handlers.length; _i < _len; _i++) {
            handler = handlers[_i];
            handler.call(this);
          }
        }
        execLimit = this.execLimit;
        while (this.progress >= this.tick - this.roundOffTick) {
          if (--execLimit < 0) {
            this.progress = 0;
            break;
          }
          this.progress -= this.tick;
          ++this.execCount;
          this.rootMovie.exec();
          this.rootMovie.postExec(progressing);
          execed = true;
          if (!this.frameSkip) {
            break;
          }
        }
        if (this.progress < this.roundOffTick) {
          this.progress = 0;
        }
        this.linkButton();
      }
      if (this.isLWFAttached) {
        hasButton = this.rootMovie.execAttachedLWF(tick, currentProgress);
        if (hasButton) {
          this.linkButton();
        }
      }
      this.needsUpdate = false;
      if (!this.fastForward) {
        if (execed || this.isPropertyDirty || this.needsUpdateForAttachLWF) {
          this.needsUpdate = true;
        }
      }
      if (!this.execDisabled) {
        if (tick < 0) {
          this.progress = currentProgress;
        }
      }
      return this.renderingCount;
    };

    LWF.prototype.exec = function(tick, matrix, colorTransform) {
      var needsUpdate, renderingCount, startTime;
      if (tick == null) {
        tick = 0;
      }
      if (matrix == null) {
        matrix = null;
      }
      if (colorTransform == null) {
        colorTransform = null;
      }
      needsUpdate = false;
      if (matrix != null) {
        needsUpdate |= this.execMatrix.setWithComparing(matrix);
      }
      if (colorTransform != null) {
        needsUpdate |= this.execColorTransform.setWithComparing(colorTransform);
      }
      if (this.parent == null) {
        this.fastForwardCurrent = this.fastForward;
        if (this.fastForwardCurrent) {
          tick = this.tick;
          startTime = Date.now();
        }
      }
      while (true) {
        renderingCount = this.execInternal(tick);
        needsUpdate |= this.needsUpdate;
        if (needsUpdate) {
          this.update(matrix, colorTransform);
        }
        if (this.isLWFAttached) {
          this.rootMovie.updateAttachedLWF();
        }
        if (needsUpdate) {
          this.rootMovie.postUpdate();
        }
        if (this.fastForwardCurrent && this.fastForward && (this.parent == null)) {
          if (Date.now() - startTime >= this.fastForwardTimeout) {
            break;
          }
        } else {
          break;
        }
      }
      return renderingCount;
    };

    LWF.prototype.forceExec = function(matrix, colorTransform) {
      if (matrix == null) {
        matrix = null;
      }
      if (colorTransform == null) {
        colorTransform = null;
      }
      return this.exec(0, matrix, colorTransform);
    };

    LWF.prototype.forceExecWithoutProgress = function(matrix, colorTransform) {
      if (matrix == null) {
        matrix = null;
      }
      if (colorTransform == null) {
        colorTransform = null;
      }
      return this.exec(-1, matrix, colorTransform);
    };

    LWF.prototype.update = function(matrix, colorTransform) {
      var c, m;
      if (matrix == null) {
        matrix = null;
      }
      if (colorTransform == null) {
        colorTransform = null;
      }
      m = this.calcMatrix(matrix);
      c = this.calcColorTransform(colorTransform);
      this.renderingIndex = 0;
      this.renderingIndexOffsetted = 0;
      this.rootMovie.update(m, c);
      this.renderingCount = this.renderingIndex;
      this.isPropertyDirty = false;
      this.needsUpdateForAttachLWF = false;
    };

    LWF.prototype.render = function(rIndex, rCount, rOffset) {
      if (rIndex == null) {
        rIndex = 0;
      }
      if (rCount == null) {
        rCount = 0;
      }
      if (rOffset == null) {
        rOffset = Number.MIN_VALUE;
      }
      if ((this.rootMovie == null) || !this.active || this.fastForwardCurrent) {
        return 0;
      }
      this.renderCount = ++LWF.globalRenderCount;
      if (rCount > 0) {
        this.renderingCount = rCount;
      }
      this.renderingIndex = rIndex;
      this.renderingIndexOffsetted = rIndex;
      if (this.property.hasRenderingOffset) {
        this.renderOffset();
        rOffset = this.property.renderingOffset;
      }
      this.rendererFactory.beginRender(this);
      this.rootMovie.render(this.attachVisible, rOffset);
      this.rendererFactory.endRender(this);
      return this.renderingIndex - rIndex;
    };

    LWF.prototype.inspect = function(inspector, hierarchy, depth, rIndex, rCount, rOffset) {
      if (hierarchy == null) {
        hierarchy = 0;
      }
      if (depth == null) {
        depth = 0;
      }
      if (rIndex == null) {
        rIndex = 0;
      }
      if (rCount == null) {
        rCount = 0;
      }
      if (rOffset == null) {
        rOffset = Number.MIN_VALUE;
      }
      if (rCount > 0) {
        this.renderingCount = rCount;
      }
      this.renderingIndex = rIndex;
      this.renderingIndexOffsetted = rIndex;
      if (this.property.hasRenderingOffset) {
        this.renderOffset();
        rOffset = this.property.renderingOffset;
      }
      this.rootMovie.inspect(inspector, hierarchy, depth, rOffset);
      return this.renderingIndex - rIndex;
    };

    LWF.prototype.destroy = function() {
      var func, k, lwfInstance, resourceCache, _ref, _ref1;
      if (this.rootMovie == null) {
        return;
      }
      if (this.stopTweens != null) {
        this.stopTweens();
      }
      _ref = this.loadedLWFs;
      for (k in _ref) {
        lwfInstance = _ref[k];
        lwfInstance.destroy();
      }
      this.loadedLWFs = null;
      this.rootMovie.destroy();
      this.rootMovie = null;
      func = (_ref1 = this.functions) != null ? _ref1['destroy'] : void 0;
      if (func != null) {
        func.call(this);
      }
      this.functions = null;
      if (this.rendererFactory != null) {
        resourceCache = this.rendererFactory.resourceCache;
        if (resourceCache != null) {
          resourceCache.unloadLWF(this);
        }
        this.rendererFactory.destruct();
        this.rendererFactory = null;
      }
      this.property = null;
      this.buttonHead = null;
      this.instances = null;
      this.execHandlers = null;
      this.eventHandlers = null;
      this.genericEventHandlers = null;
      this.movieEventHandlers = null;
      this.buttonEventHandlers = null;
      this.movieCommands = null;
      this.programObjectConstructors = null;
    };

    LWF.prototype.getInstanceNameStringId = function(instId) {
      if (instId < 0 || instId >= this.data.instanceNames.length) {
        return -1;
      } else {
        return this.data.instanceNames[instId].stringId;
      }
    };

    LWF.prototype.getStringId = function(str) {
      var i;
      i = this.data.stringMap[str];
      if (i != null) {
        return i;
      } else {
        return -1;
      }
    };

    LWF.prototype.searchInstanceId = function(stringId) {
      var i;
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      i = this.data.instanceNameMap[stringId];
      if (i != null) {
        return i;
      } else {
        return -1;
      }
    };

    LWF.prototype.searchFrame = function(movie, stringId) {
      var frameNo;
      if (typeof stringId === "string") {
        stringId = this.getStringId(stringId);
      }
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      frameNo = this.data.labelMap[movie.objectId][stringId];
      if (frameNo != null) {
        return frameNo + 1;
      } else {
        return -1;
      }
    };

    LWF.prototype.getMovieLabels = function(movie) {
      if (movie == null) {
        return null;
      }
      return this.data.labelMap[movie.objectId];
    };

    LWF.prototype.searchMovieLinkage = function(stringId) {
      var i;
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      i = this.data.movieLinkageMap[stringId];
      if (i != null) {
        return this.data.movieLinkages[i].movieId;
      } else {
        return -1;
      }
    };

    LWF.prototype.getMovieLinkageName = function(movieId) {
      var i;
      i = this.data.movieLinkageNameMap[movieId];
      if (i != null) {
        return this.data.strings[i];
      } else {
        return null;
      }
    };

    LWF.prototype.searchMovieInstance = function(stringId) {
      var instanceName, m, name, names, _i, _len;
      if (typeof stringId === "string") {
        instanceName = stringId;
        if (instanceName.indexOf(".") !== -1) {
          names = instanceName.split(".");
          if (names[0] !== this.data.strings[this.rootMovieStringId]) {
            return null;
          }
          m = this.rootMovie;
          for (_i = 0, _len = names.length; _i < _len; _i++) {
            name = names[_i];
            m = m.searchMovieInstance(name, false);
            if (m == null) {
              return null;
            }
          }
          return m;
        }
        stringId = this.getStringId(stringId);
      }
      return this.searchMovieInstanceByInstanceId(this.searchInstanceId(stringId));
    };

    LWF.prototype.searchMovieInstanceByInstanceId = function(instId) {
      var obj;
      if (typeof instId === "string") {
        instId = this.searchInstanceId(this.getStringId(instId));
      }
      if (instId < 0 || instId >= this.data.instanceNames.length) {
        return null;
      }
      obj = this.instances[instId];
      while (obj != null) {
        if (obj.isMovie) {
          return obj;
        }
        obj = obj.nextInstance;
      }
      return null;
    };

    LWF.prototype.searchButtonInstance = function(stringId) {
      var i, instanceName, m, names, _i, _ref;
      if (typeof stringId === "string") {
        instanceName = stringId;
        if (instanceName.indexOf(".") !== -1) {
          names = instanceName.split(".");
          if (names[0] !== this.data.strings[this.rootMovieStringId]) {
            return null;
          }
          m = this.rootMovie;
          for (i = _i = 1, _ref = names.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
            if (i === names.length - 1) {
              return m.searchButtonInstance(names[i], false);
            } else {
              m = m.searchButtonInstance(names[i], false);
              if (m == null) {
                return null;
              }
            }
          }
          return null;
        }
        stringId = this.getStringId(stringId);
      }
      return this.searchButtonInstanceByInstanceId(this.searchInstanceId(stringId));
    };

    LWF.prototype.searchButtonInstanceByInstanceId = function(instId) {
      var obj;
      if (typeof instId === "string") {
        instId = this.searchInstanceId(this.getStringId(instId));
      }
      if (instId < 0 || instId >= this.data.instanceNames.length) {
        return null;
      }
      obj = this.instances[instId];
      while (obj != null) {
        if (obj.isButton) {
          return obj;
        }
        obj = obj.nextInstance;
      }
      return null;
    };

    LWF.prototype.searchEventId = function(stringId) {
      var i;
      if (typeof stringId === "string") {
        stringId = this.getStringId(stringId);
      }
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      i = this.data.eventMap[stringId];
      if (i != null) {
        return i;
      } else {
        return -1;
      }
    };

    LWF.prototype.searchProgramObjectId = function(stringId) {
      var i;
      if (typeof stringId === "string") {
        stringId = this.getStringId(stringId);
      }
      if (stringId < 0 || stringId >= this.data.strings.length) {
        return -1;
      }
      i = this.data.programObjectMap[stringId];
      if (i != null) {
        return i;
      } else {
        return -1;
      }
    };

    LWF.prototype.getInstance = function(instId) {
      return this.instances[instId];
    };

    LWF.prototype.setInstance = function(instId, instance) {
      this.instances[instId] = instance;
    };

    LWF.prototype.addExecHandler = function(execHandler) {
      if (this.execHandlers == null) {
        this.execHandlers = [];
      }
      this.execHandlers.push(execHandler);
    };

    LWF.prototype.removeExecHandler = function(execHandler) {
      var handlers, i;
      handlers = this.execHandlers;
      if (handlers == null) {
        return;
      }
      i = 0;
      while (i < handlers.length) {
        if (handlers[i] === execHandler) {
          handlers.splice(i, 1);
        } else {
          ++i;
        }
      }
    };

    LWF.prototype.clearExecHandler = function() {
      this.execHandlers = null;
    };

    LWF.prototype.setExecHandler = function(execHandler) {
      this.clearExecHandler();
      this.addExecHandler(execHandler);
    };

    LWF.prototype.addEventHandler = function(e, eventHandler) {
      var eventId, _base, _base1;
      eventId = typeof e === "string" ? this.searchEventId(e) : e;
      if (eventId < 0 || eventId >= this.data.events.length) {
        if ((_base = this.genericEventHandlers)[e] == null) {
          _base[e] = [];
        }
        this.genericEventHandlers[e].push(eventHandler);
      } else {
        if ((_base1 = this.eventHandlers)[eventId] == null) {
          _base1[eventId] = [];
        }
        this.eventHandlers[eventId].push(eventHandler);
      }
    };

    LWF.prototype.removeEventHandler = function(e, eventHandler) {
      var eventId, handlers, i, k, keys, v, _i, _len;
      eventId = typeof e === "string" ? this.searchEventId(e) : e;
      if (eventId < 0 || eventId >= this.data.events.length) {
        handlers = this.genericEventHandlers[e];
        if (handlers == null) {
          return;
        }
        keys = [];
        for (k in handlers) {
          v = handlers[k];
          if (v === eventHandler) {
            keys.push(k);
          }
        }
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          k = keys[_i];
          delete handlers[k];
        }
      } else {
        handlers = this.eventHandlers[eventId];
        if (handlers == null) {
          return;
        }
        i = 0;
        while (i < handlers.length) {
          if (handlers[i] === eventHandler) {
            handlers.splice(i, 1);
          } else {
            ++i;
          }
        }
        if (handlers.length === 0) {
          delete this.eventHandlers[eventId];
        }
      }
    };

    LWF.prototype.clearEventHandler = function(e) {
      var eventId;
      eventId = typeof e === "string" ? this.searchEventId(e) : e;
      if (eventId < 0 || eventId >= this.data.events.length) {
        this.genericEventHandlers[e] = null;
      } else {
        this.eventHandlers[eventId] = null;
      }
    };

    LWF.prototype.setEventHandler = function(eventId, eventHandler) {
      this.clearEventHandler(eventId);
      this.addEventHandler(eventId, eventHandler);
    };

    LWF.prototype.getProgramObjectConstructor = function(programObjectId) {
      if (typeof programObjectId === "string") {
        programObjectId = this.searchProgramObjectId(this.getStringId(programObjectId));
      }
      if (programObjectId < 0 || programObjectId >= this.data.programObjects.length) {
        return null;
      }
      return this.programObjectConstructors[programObjectId];
    };

    LWF.prototype.setProgramObjectConstructor = function(programObjectId, programObjectConstructor) {
      if (typeof programObjectId === "string") {
        programObjectId = this.searchProgramObjectId(this.getStringId(programObjectId));
      }
      if (programObjectId < 0 || programObjectId >= this.data.programObjects.length) {
        return;
      }
      this.programObjectConstructors[programObjectId] = programObjectConstructor;
    };

    LWF.prototype.getMovieEventHandlers = function(m) {
      var fullName, handlers, instId, instanceName;
      if (typeof m === "string") {
        instanceName = m;
        instId = this.searchInstanceId(this.getStringId(instanceName));
        if (instId >= 0 && instId < this.data.instanceNames.length) {
          return this.movieEventHandlers[instId];
        } else {
          if (this.movieEventHandlersByFullName == null) {
            return null;
          }
          return this.movieEventHandlersByFullName[instanceName];
        }
      }
      if (this.movieEventHandlersByFullName != null) {
        fullName = m.getFullName();
        if (fullName != null) {
          handlers = this.movieEventHandlersByFullName[fullName];
          if (handlers != null) {
            return handlers;
          }
        }
      }
      return this.movieEventHandlers[m.instanceId];
    };

    LWF.prototype.addMovieEventHandler = function(instanceName, handlers) {
      var h, instId, movie;
      instId = this.searchInstanceId(this.getStringId(instanceName));
      if (instId >= 0 && instId < this.data.instanceNames.length) {
        h = this.movieEventHandlers[instId];
        if (h == null) {
          h = new MovieEventHandlers();
          this.movieEventHandlers[instId] = h;
        }
        movie = this.searchMovieInstanceByInstanceId(instId);
      } else {
        if (instanceName.indexOf(".") === -1) {
          return;
        }
        if (this.movieEventHandlersByFullName == null) {
          this.movieEventHandlersByFullName = [];
        }
        h = this.movieEventHandlersByFullName[instanceName];
        if (h == null) {
          h = new MovieEventHandlers();
          this.movieEventHandlersByFullName[instanceName] = h;
        }
        movie = this.searchMovieInstance(instanceName);
      }
      h.add(handlers);
      if (movie != null) {
        movie.setHandlers(h);
      }
    };

    LWF.prototype.removeMovieEventHandler = function(instanceName, handlers) {
      var h, movie;
      h = this.getMovieEventHandlers(instanceName);
      if (h != null) {
        h.remove(handlers);
      }
      movie = this.searchMovieInstance(instanceName);
      if (movie != null) {
        movie.handler.remove(handlers);
      }
    };

    LWF.prototype.clearMovieEventHandler = function(instanceName, type) {
      var h, movie;
      if (type == null) {
        type = null;
      }
      h = this.getMovieEventHandlers(instanceName);
      if (h != null) {
        h.clear(type);
      }
      movie = this.searchMovieInstance(instanceName);
      if (movie != null) {
        movie.handler.clear(type);
      }
    };

    LWF.prototype.setMovieEventHandler = function(instanceName, handlers) {
      this.clearMovieEventHandler(instanceName);
      this.addMovieEventHandler(instanceName, handlers);
    };

    LWF.prototype.getButtonEventHandlers = function(m) {
      var fullName, handlers, instId, instanceName;
      if (typeof m === "string") {
        instanceName = m;
        instId = this.searchInstanceId(this.getStringId(instanceName));
        if (instId >= 0 && instId < this.data.instanceNames.length) {
          return this.buttonEventHandlers[instId];
        } else {
          if (this.buttonEventHandlersByFullName == null) {
            return null;
          }
          return this.buttonEventHandlersByFullName[instanceName];
        }
      }
      if (this.buttonEventHandlersByFullName != null) {
        fullName = m.getFullName();
        if (fullName != null) {
          handlers = this.buttonEventHandlersByFullName[fullName];
          if (handlers != null) {
            return handlers;
          }
        }
      }
      return this.buttonEventHandlers[m.instanceId];
    };

    LWF.prototype.addButtonEventHandler = function(instanceName, handlers) {
      var button, h, instId;
      this.setInteractive();
      instId = this.searchInstanceId(this.getStringId(instanceName));
      if (instId >= 0 && instId < this.data.instanceNames.length) {
        h = this.buttonEventHandlers[instId];
        if (h == null) {
          h = new ButtonEventHandlers();
          this.buttonEventHandlers[instId] = h;
        }
        button = this.searchButtonInstanceByInstanceId(instId);
      } else {
        if (instanceName.indexOf(".") === -1) {
          return;
        }
        if (this.buttonEventHandlersByFullName == null) {
          this.buttonEventHandlersByFullName = [];
        }
        h = this.buttonEventHandlersByFullName[instanceName];
        if (h == null) {
          h = new ButtonEventHandlers();
          this.buttonEventHandlersByFullName[instanceName] = h;
        }
        button = this.searchButtonInstance(instanceName);
      }
      h.add(handlers);
      if (button != null) {
        button.setHandlers(h);
      }
    };

    LWF.prototype.removeButtonEventHandler = function(instanceName, handlers) {
      var button, h;
      h = this.getButtonEventHandlers(instanceName);
      if (h != null) {
        h.remove(handlers);
      }
      button = this.searchButtonInstance(instanceName);
      if ((button != null ? button.handler : void 0) != null) {
        button.handler.remove(handlers);
      }
    };

    LWF.prototype.clearButtonEventHandler = function(instanceName, type) {
      var button, h;
      if (type == null) {
        type = null;
      }
      h = this.getButtonEventHandlers(instanceName);
      if (h != null) {
        h.clear(type);
      }
      button = this.searchButtonInstance(instanceName);
      if ((typeof buffon !== "undefined" && buffon !== null ? buffon.handler : void 0) != null) {
        button.handler.clear(type);
      }
    };

    LWF.prototype.setButtonEventHandler = function(instanceName, handlers) {
      this.clearButtonEventHandler(instanceName);
      this.addButtonEventHandler(instanceName, handlers);
    };

    LWF.prototype.setMovieLoadCommand = function(instanceName, handler) {
      var handlers, m;
      m = this.searchMovieInstance(instanceName);
      if (m != null) {
        handler.call(m);
      } else {
        handlers = {};
        handlers["load"] = function() {
          this.lwf.removeMovieEventHandler(instanceName, handlers);
          return handler.call(this);
        };
        this.addMovieEventHandler(instanceName, handlers);
      }
    };

    LWF.prototype.setMoviePostLoadCommand = function(instanceName, handler) {
      var handlers, m;
      m = this.searchMovieInstance(instanceName);
      if (m != null) {
        handler.call(m);
      } else {
        handlers = {};
        handlers["postLoad"] = function() {
          this.lwf.removeMovieEventHandler(instanceName, handlers);
          return handler.call(this);
        };
        this.addMovieEventHandler(instanceName, handlers);
      }
    };

    LWF.prototype.playMovie = function(instanceName) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.play();
      });
    };

    LWF.prototype.stopMovie = function(instanceName) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.stop();
      });
    };

    LWF.prototype.nextFrameMovie = function(instanceName) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.nextFrame();
      });
    };

    LWF.prototype.prevFrameMovie = function(instanceName) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.prevFrame();
      });
    };

    LWF.prototype.setVisibleMovie = function(instanceName, visible) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.setVisible(visible);
      });
    };

    LWF.prototype.gotoAndStopMovie = function(instanceName, label) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.gotoAndStop(label);
      });
    };

    LWF.prototype.gotoAndStopMovie = function(instanceName, frameNo) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.gotoAndStop(frameNo);
      });
    };

    LWF.prototype.gotoAndPlayMovie = function(instanceName, label) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.gotoAndPlay(label);
      });
    };

    LWF.prototype.gotoAndPlayMovie = function(instanceName, frameNo) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.gotoAndPlay(frameNo);
      });
    };

    LWF.prototype.moveMovie = function(instanceName, x, y) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.move(x, y);
      });
    };

    LWF.prototype.moveToMovie = function(instanceName, x, y) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.moveTo(x, y);
      });
    };

    LWF.prototype.rotateMovie = function(instanceName, degree) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.rotate(degree);
      });
    };

    LWF.prototype.rotateToMovie = function(instanceName, degree) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.rotateTo(degree);
      });
    };

    LWF.prototype.scaleMovie = function(instanceName, x, y) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.scale(x, y);
      });
    };

    LWF.prototype.scaleToMovie = function(instanceName, x, y) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.scaleTo(x, y);
      });
    };

    LWF.prototype.setMatrixMovie = function(instanceName, matrix, sx, sy, r) {
      if (sx == null) {
        sx = 1;
      }
      if (sy == null) {
        sy = 1;
      }
      if (r == null) {
        r = 0;
      }
      this.setMovieLoadCommand(instanceName, function() {
        return this.setMatrix(matrix, sx, sy, r);
      });
    };

    LWF.prototype.setAlphaMovie = function(instanceName, alpha) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.setAlpha(alpha);
      });
    };

    LWF.prototype.setColorTransformMovie = function(instanceName, colorTransform) {
      this.setMovieLoadCommand(instanceName, function() {
        return this.setColorTransform(colorTransform);
      });
    };

    LWF.prototype.execMovieCommand = function() {
      var available, deletes, k, movie, name, v, _i, _j, _len, _len1, _ref;
      deletes = [];
      _ref = this.movieCommands;
      for (k in _ref) {
        v = _ref[k];
        available = true;
        movie = this.rootMovie;
        for (_i = 0, _len = k.length; _i < _len; _i++) {
          name = k[_i];
          movie = movie.searchMovieInstance(name);
          if (movie == null) {
            available = false;
            break;
          }
        }
        if (available) {
          v(movie);
          deletes.push(k);
        }
      }
      for (_j = 0, _len1 = deletes.length; _j < _len1; _j++) {
        k = deletes[_j];
        delete this.movieCommands[k];
      }
    };

    LWF.prototype.setMovieCommand = function(instanceNames, cmd) {
      var names;
      names = instanceNames.slice(0);
      this.movieCommands[names] = cmd;
      this.execMovieCommand();
    };

    LWF.prototype.searchAttachedMovie = function(attachName) {
      return this.rootMovie.searchAttachedMovie(attachName);
    };

    LWF.prototype.searchAttachedLWF = function(attachName) {
      return this.rootMovie.searchAttachedLWF(attachName);
    };

    LWF.prototype.addAllowButton = function(buttonName) {
      var instId;
      instId = this.searchInstanceId(this.getStringId(buttonName));
      if (instId < 0) {
        return false;
      }
      if (this.allowButtonList == null) {
        this.allowButtonList = {};
      }
      this.allowButtonList[instId] = true;
      return true;
    };

    LWF.prototype.removeAllowButton = function(buttonName) {
      var instId;
      if (this.allowButtonList == null) {
        return false;
      }
      instId = this.searchInstanceId(this.getStringId(buttonName));
      if (instId < 0) {
        return false;
      }
      delete this.allowButtonList[instId];
      return true;
    };

    LWF.prototype.clearAllowButton = function() {
      this.allowButtonList = null;
    };

    LWF.prototype.addDenyButton = function(buttonName) {
      var instId;
      instId = this.searchInstanceId(this.getStringId(buttonName));
      if (instId < 0) {
        return false;
      }
      if (this.denyButtonList == null) {
        this.denyButtonList = {};
      }
      this.denyButtonList[instId] = true;
      return true;
    };

    LWF.prototype.denyAllButtons = function() {
      var instId, _i, _ref;
      if (this.denyButtonList == null) {
        this.denyButtonList = {};
      }
      for (instId = _i = 0, _ref = this.data.instanceNames.length; 0 <= _ref ? _i < _ref : _i > _ref; instId = 0 <= _ref ? ++_i : --_i) {
        this.denyButtonList[instId] = true;
      }
    };

    LWF.prototype.removeDenyButton = function(buttonName) {
      var instId;
      if (this.denyButtonList == null) {
        return false;
      }
      instId = this.searchInstanceId(this.getStringId(buttonName));
      if (instId < 0) {
        return false;
      }
      delete this.denyButtonList[instId];
      return true;
    };

    LWF.prototype.clearDenyButton = function() {
      this.denyButtonList = null;
    };

    LWF.prototype.disableExec = function() {
      this.isExecDisabled = true;
      this.executedForExecDisabled = false;
    };

    LWF.prototype.enableExec = function() {
      this.isExecDisabled = false;
    };

    LWF.prototype.setPropertyDirty = function() {
      this.isPropertyDirty = true;
      if (this.parent != null) {
        this.parent.lwf.setPropertyDirty();
      }
    };

    LWF.prototype.setParent = function(parent) {
      var func, _ref;
      this.active = true;
      this.parent = parent;
      this.rootMovie.parent = parent;
      this.setTextScale(parent.lwf.textScale);
      func = (_ref = this.functions) != null ? _ref['init'] : void 0;
      if (func != null) {
        func.call(this.rootMovie);
      }
    };

    LWF.prototype.setInteractive = function() {
      this.interactive = true;
      if (this.parent != null) {
        this.parent.lwf.setInteractive();
      }
    };

    LWF.prototype.setFrameSkip = function(frameSkip) {
      this.frameSkip = frameSkip;
      this.progress = 0;
      if (this.parent != null) {
        this.parent.lwf.setFrameSkip(frameSkip);
      }
    };

    LWF.prototype.setLWFAttached = function() {
      this.isLWFAttached = true;
      this.needsUpdateForAttachLWF = true;
      if (this.parent != null) {
        this.parent.lwf.setLWFAttached();
      }
    };

    LWF.prototype.setFastForwardTimeout = function(fastForwardTimeout) {
      this.fastForwardTimeout = fastForwardTimeout;
    };

    LWF.prototype.setFastForward = function(fastForward) {
      this.fastForward = fastForward;
      if (this.parent != null) {
        this.parent.lwf.setFastForward(fastForward);
      }
    };

    LWF.prototype.getMovieFunctions = function(movieId) {
      var enterFrameFunc, linkageName, loadFunc, postLoadFunc, unloadFunc, _ref, _ref1, _ref2, _ref3;
      linkageName = this.getMovieLinkageName(movieId);
      loadFunc = (_ref = this.functions) != null ? _ref[linkageName + "_load"] : void 0;
      postLoadFunc = (_ref1 = this.functions) != null ? _ref1[linkageName + "_postLoad"] : void 0;
      unloadFunc = (_ref2 = this.functions) != null ? _ref2[linkageName + "_unload"] : void 0;
      enterFrameFunc = (_ref3 = this.functions) != null ? _ref3[linkageName + "_enterFrame"] : void 0;
      return [loadFunc, postLoadFunc, unloadFunc, enterFrameFunc];
    };

    LWF.prototype.playAnimation = function(animationId, movie, button) {
      var a, animations, count, eventId, func, handler, handlers, i, instId, j, stringId, target, _i, _j, _len, _ref, _ref1;
      i = 0;
      animations = this.data.animations[animationId];
      target = movie;
      while (true) {
        a = animations[i++];
        switch (a) {
          case Animation.END:
            return;
          case Animation.PLAY:
            target.play();
            break;
          case Animation.STOP:
            target.stop();
            break;
          case Animation.NEXTFRAME:
            target.nextFrame();
            break;
          case Animation.PREVFRAME:
            target.prevFrame();
            break;
          case Animation.GOTOFRAME:
            target.gotoFrameInternal(animations[i++]);
            break;
          case Animation.GOTOLABEL:
            target.gotoFrame(this.searchFrame(target, animations[i++]));
            break;
          case Animation.SETTARGET:
            target = movie;
            count = animations[i++];
            if (count !== 0) {
              for (j = _i = 0; 0 <= count ? _i < count : _i > count; j = 0 <= count ? ++_i : --_i) {
                instId = animations[i++];
                switch (instId) {
                  case Animation.INSTANCE_TARGET_ROOT:
                    target = this.rootMovie;
                    break;
                  case Animation.INSTANCE_TARGET_PARENT:
                    target = target.parent;
                    if (target == null) {
                      target = this.rootMovie;
                    }
                    break;
                  default:
                    target = target.searchMovieInstanceByInstanceId(instId, false);
                    if (target == null) {
                      target = movie;
                    }
                }
              }
            }
            break;
          case Animation.EVENT:
            eventId = animations[i++];
            handlers = (_ref = this.eventHandlers[eventId]) != null ? _ref.slice(0) : void 0;
            if (handlers != null) {
              for (_j = 0, _len = handlers.length; _j < _len; _j++) {
                handler = handlers[_j];
                handler(movie, button);
              }
            }
            break;
          case Animation.CALL:
            stringId = animations[i++];
            func = (_ref1 = this.functions) != null ? _ref1[this.data.strings[stringId]] : void 0;
            if (func != null) {
              func.call(movie);
            }
        }
      }
    };

    LWF.prototype.dispatchEvent = function(e, movie, button) {
      var eventId, handler, handlers, _i, _len;
      if (movie == null) {
        movie = this.rootMovie;
      }
      if (button == null) {
        button = null;
      }
      eventId = typeof e === "string" ? this.searchEventId(e) : e;
      if (eventId < 0 || eventId >= this.data.events.length) {
        handlers = this.genericEventHandlers[e];
      } else {
        handlers = this.eventHandlers[eventId];
      }
      if (handlers == null) {
        return false;
      }
      handlers = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = handlers.length; _i < _len; _i++) {
          handler = handlers[_i];
          _results.push(handler);
        }
        return _results;
      })();
      for (_i = 0, _len = handlers.length; _i < _len; _i++) {
        handler = handlers[_i];
        if (handler != null) {
          handler(movie, button);
        }
      }
      return true;
    };

    LWF.prototype.inputPoint = function(x, y) {
      var button, found;
      if (this.rootMovie == null) {
        return null;
      }
      this.intercepted = false;
      if (!this.interactive) {
        return null;
      }
      this.pointX = x;
      this.pointY = y;
      found = false;
      button = this.buttonHead;
      while (button != null) {
        if (button.checkHit(x, y)) {
          if (this.allowButtonList != null) {
            if (this.allowButtonList[button.instanceId] == null) {
              if (this.interceptByNotAllowOrDenyButtons) {
                this.intercepted = true;
                break;
              } else {
                button = button.buttonLink;
                continue;
              }
            }
          } else if (this.denyButtonList != null) {
            if (this.denyButtonList[button.instanceId] != null) {
              if (this.interceptByNotAllowOrDenyButtons) {
                this.intercepted = true;
                break;
              } else {
                button = button.buttonLink;
                continue;
              }
            }
          }
          found = true;
          if (this.focus !== button) {
            if (this.focus != null) {
              this.focus.rollOut();
            }
            this.focus = button;
            this.focus.rollOver();
          }
          break;
        }
        button = button.buttonLink;
      }
      if (!found && (this.focus != null)) {
        this.focus.rollOut();
        this.focus = null;
      }
      return this.focus;
    };

    LWF.prototype.inputPress = function() {
      if (this.rootMovie == null) {
        return;
      }
      if (!this.interactive) {
        return;
      }
      this.pressing = true;
      if (this.focus != null) {
        this.pressed = this.focus;
        this.focus.press();
      }
    };

    LWF.prototype.inputRelease = function() {
      if (this.rootMovie == null) {
        return;
      }
      if (!this.interactive) {
        return;
      }
      this.pressing = false;
      if ((this.focus != null) && this.pressed === this.focus) {
        this.focus.release();
        this.pressed = null;
      }
    };

    LWF.prototype.inputKeyPress = function(code) {
      var button;
      if (this.rootMovie == null) {
        return;
      }
      if (!this.interactive) {
        return;
      }
      button = this.buttonHead;
      while (button != null) {
        button.keyPress(code);
        button = button.buttonLink;
      }
    };

    return LWF;

  })();

  if (typeof global !== "undefined") {
    if (global["LWF"] == null) {
      global["LWF"] = {};
    }
    global["LWF"]["BitmapClip"] = BitmapClip;
    global["LWF"]["Color"] = Color;
    global["LWF"]["ColorTransform"] = ColorTransform;
    global["LWF"]["Format"] = Format;
    global["LWF"]["LWF"] = LWF;
    global["LWF"]["Loader"] = Loader;
    global["LWF"]["Matrix"] = Matrix;
    global["LWF"]["Movie"] = Movie;
    global["LWF"]["Point"] = Point;
    global["LWF"]["Property"] = Property;
  }

  LWF.prototype["addAllowButton"] = LWF.prototype.addAllowButton;

  LWF.prototype["addButtonEventHandler"] = LWF.prototype.addButtonEventHandler;

  LWF.prototype["addButtonEventListener"] = LWF.prototype.addButtonEventHandler;

  LWF.prototype["addDenyButton"] = LWF.prototype.addDenyButton;

  LWF.prototype["addEventHandler"] = LWF.prototype.addEventHandler;

  LWF.prototype["addEventListener"] = LWF.prototype.addEventHandler;

  LWF.prototype["addExecHandler"] = LWF.prototype.addExecHandler;

  LWF.prototype["addExecListener"] = LWF.prototype.addExecHandler;

  LWF.prototype["addMovieEventHandler"] = LWF.prototype.addMovieEventHandler;

  LWF.prototype["addMovieEventListener"] = LWF.prototype.addMovieEventHandler;

  LWF.prototype["clearAllowButton"] = LWF.prototype.clearAllowButton;

  LWF.prototype["clearButtonEventHandler"] = LWF.prototype.clearButtonEventHandler;

  LWF.prototype["clearButtonEventListener"] = LWF.prototype.clearButtonEventHandler;

  LWF.prototype["clearDenyButton"] = LWF.prototype.clearDenyButton;

  LWF.prototype["clearEventHandler"] = LWF.prototype.clearEventHandler;

  LWF.prototype["clearEventListener"] = LWF.prototype.clearEventHandler;

  LWF.prototype["clearExecHandler"] = LWF.prototype.clearExecHandler;

  LWF.prototype["clearExecListener"] = LWF.prototype.clearExecHandler;

  LWF.prototype["clearMovieEventHandler"] = LWF.prototype.clearMovieEventHandler;

  LWF.prototype["clearMovieEventListener"] = LWF.prototype.clearMovieEventHandler;

  LWF.prototype["denyAllButtons"] = LWF.prototype.denyAllButtons;

  LWF.prototype["destroy"] = LWF.prototype.destroy;

  LWF.prototype["dispatchEvent"] = LWF.prototype.dispatchEvent;

  LWF.prototype["exec"] = LWF.prototype.exec;

  LWF.prototype["fitForHeight"] = LWF.prototype.fitForHeight;

  LWF.prototype["fitForWidth"] = LWF.prototype.fitForWidth;

  LWF.prototype["forceExec"] = LWF.prototype.forceExec;

  LWF.prototype["forceExecWithoutProgress"] = LWF.prototype.forceExecWithoutProgress;

  LWF.prototype["getStageSize"] = LWF.prototype.getStageSize;

  LWF.prototype["getStringId"] = LWF.prototype.getStringId;

  LWF.prototype["gotoAndPlayMovie"] = LWF.prototype.gotoAndPlayMovie;

  LWF.prototype["gotoAndPlayMovie"] = LWF.prototype.gotoAndPlayMovie;

  LWF.prototype["gotoAndStopMovie"] = LWF.prototype.gotoAndStopMovie;

  LWF.prototype["gotoAndStopMovie"] = LWF.prototype.gotoAndStopMovie;

  LWF.prototype["init"] = LWF.prototype.init;

  LWF.prototype["inputKeyPress"] = LWF.prototype.inputKeyPress;

  LWF.prototype["inputPoint"] = LWF.prototype.inputPoint;

  LWF.prototype["inputPress"] = LWF.prototype.inputPress;

  LWF.prototype["inputRelease"] = LWF.prototype.inputRelease;

  LWF.prototype["inspect"] = LWF.prototype.inspect;

  LWF.prototype["moveMovie"] = LWF.prototype.moveMovie;

  LWF.prototype["moveToMovie"] = LWF.prototype.moveToMovie;

  LWF.prototype["nextFrameMovie"] = LWF.prototype.nextFrameMovie;

  LWF.prototype["playMovie"] = LWF.prototype.playMovie;

  LWF.prototype["prevFrameMovie"] = LWF.prototype.prevFrameMovie;

  LWF.prototype["removeAllowButton"] = LWF.prototype.removeAllowButton;

  LWF.prototype["removeButtonEventHandler"] = LWF.prototype.removeButtonEventHandler;

  LWF.prototype["removeButtonEventListener"] = LWF.prototype.removeButtonEventHandler;

  LWF.prototype["removeDenyButton"] = LWF.prototype.removeDenyButton;

  LWF.prototype["removeEventHandler"] = LWF.prototype.removeEventHandler;

  LWF.prototype["removeEventListener"] = LWF.prototype.removeEventHandler;

  LWF.prototype["removeExecHandler"] = LWF.prototype.removeExecHandler;

  LWF.prototype["removeExecListener"] = LWF.prototype.removeExecHandler;

  LWF.prototype["removeMovieEventHandler"] = LWF.prototype.removeMovieEventHandler;

  LWF.prototype["removeMovieEventListener"] = LWF.prototype.removeMovieEventHandler;

  LWF.prototype["render"] = LWF.prototype.render;

  LWF.prototype["rotateMovie"] = LWF.prototype.rotateMovie;

  LWF.prototype["rotateToMovie"] = LWF.prototype.rotateToMovie;

  LWF.prototype["scaleForHeight"] = LWF.prototype.scaleForHeight;

  LWF.prototype["scaleForWidth"] = LWF.prototype.scaleForWidth;

  LWF.prototype["scaleMovie"] = LWF.prototype.scaleMovie;

  LWF.prototype["scaleToMovie"] = LWF.prototype.scaleToMovie;

  LWF.prototype["searchAttachedLWF"] = LWF.prototype.searchAttachedLWF;

  LWF.prototype["searchAttachedMovie"] = LWF.prototype.searchAttachedMovie;

  LWF.prototype["searchEventId"] = LWF.prototype.searchEventId;

  LWF.prototype["searchFrame"] = LWF.prototype.searchFrame;

  LWF.prototype["searchProgramObjectId"] = LWF.prototype.searchProgramObjectId;

  LWF.prototype["setAlphaMovie"] = LWF.prototype.setAlphaMovie;

  LWF.prototype["setButtonEventHandler"] = LWF.prototype.setButtonEventHandler;

  LWF.prototype["setButtonEventListener"] = LWF.prototype.setButtonEventHandler;

  LWF.prototype["setColorTransformMovie"] = LWF.prototype.setColorTransformMovie;

  LWF.prototype["setEventHandler"] = LWF.prototype.setEventHandler;

  LWF.prototype["setEventListener"] = LWF.prototype.setEventHandler;

  LWF.prototype["setExecHandler"] = LWF.prototype.setExecHandler;

  LWF.prototype["setExecListener"] = LWF.prototype.setExecHandler;

  LWF.prototype["setFastForward"] = LWF.prototype.setFastForward;

  LWF.prototype["setFastForwardTimeout"] = LWF.prototype.setFastForwardTimeout;

  LWF.prototype["setFont"] = LWF.prototype.setFont;

  LWF.prototype["setFrameRate"] = LWF.prototype.setFrameRate;

  LWF.prototype["setFrameSkip"] = LWF.prototype.setFrameSkip;

  LWF.prototype["setMatrixMovie"] = LWF.prototype.setMatrixMovie;

  LWF.prototype["setMovieCommand"] = LWF.prototype.setMovieCommand;

  LWF.prototype["setMovieEventHandler"] = LWF.prototype.setMovieEventHandler;

  LWF.prototype["setMovieEventListener"] = LWF.prototype.setMovieEventHandler;

  LWF.prototype["setMovieLoadCommand"] = LWF.prototype.setMovieLoadCommand;

  LWF.prototype["setMoviePostLoadCommand"] = LWF.prototype.setMoviePostLoadCommand;

  LWF.prototype["setPreferredFrameRate"] = LWF.prototype.setPreferredFrameRate;

  LWF.prototype["setProgramObjectConstructor"] = LWF.prototype.setProgramObjectConstructor;

  LWF.prototype["setRendererFactory"] = LWF.prototype.setRendererFactory;

  LWF.prototype["setTextScale"] = LWF.prototype.setTextScale;

  LWF.prototype["setVisibleMovie"] = LWF.prototype.setVisibleMovie;

  LWF.prototype["stopMovie"] = LWF.prototype.stopMovie;

  Loader["load"] = Loader.load;

  Data.prototype["check"] = Data.prototype.check;

  Data.prototype["name"] = Data.prototype.name;

  IObject.prototype["getFullName"] = IObject.prototype.getFullName;

  Button.prototype["addEventHandler"] = Button.prototype.addEventHandler;

  Button.prototype["addEventListener"] = Button.prototype.addEventHandler;

  Button.prototype["clearEventHandler"] = Button.prototype.clearEventHandler;

  Button.prototype["clearEventListener"] = Button.prototype.clearEventHandler;

  Button.prototype["removeEventHandler"] = Button.prototype.removeEventHandler;

  Button.prototype["removeEventListener"] = Button.prototype.removeEventHandler;

  Button.prototype["setEventHandler"] = Button.prototype.setEventHandler;

  Button.prototype["setEventListener"] = Button.prototype.setEventHandler;

  Movie.prototype["addEventHandler"] = Movie.prototype.addEventHandler;

  Movie.prototype["addEventListener"] = Movie.prototype.addEventHandler;

  Movie.prototype["attachBitmap"] = Movie.prototype.attachBitmap;

  Movie.prototype["attachEmptyMovie"] = Movie.prototype.attachEmptyMovie;

  Movie.prototype["attachLWF"] = Movie.prototype.attachLWF;

  Movie.prototype["attachMovie"] = Movie.prototype.attachMovie;

  Movie.prototype["clearEventHandler"] = Movie.prototype.clearEventHandler;

  Movie.prototype["clearEventListener"] = Movie.prototype.clearEventHandler;

  Movie.prototype["detachBitmap"] = Movie.prototype.detachBitmap;

  Movie.prototype["detachFromParent"] = Movie.prototype.detachFromParent;

  Movie.prototype["detachLWF"] = Movie.prototype.detachLWF;

  Movie.prototype["detachMovie"] = Movie.prototype.detachMovie;

  Movie.prototype["dispatchEvent"] = Movie.prototype.dispatchEvent;

  Movie.prototype["getAttachedBitmap"] = Movie.prototype.getAttachedBitmap;

  Movie.prototype["getAttachedLWF"] = Movie.prototype.getAttachedLWF;

  Movie.prototype["getAttachedMovie"] = Movie.prototype.getAttachedMovie;

  Movie.prototype["getAttachedBitmaps"] = Movie.prototype.getAttachedBitmaps;

  Movie.prototype["getBounds"] = Movie.prototype.getBounds;

  Movie.prototype["globalToLocal"] = Movie.prototype.globalToLocal;

  Movie.prototype["gotoAndPlay"] = Movie.prototype.gotoAndPlay;

  Movie.prototype["gotoAndStop"] = Movie.prototype.gotoAndStop;

  Movie.prototype["gotoFrame"] = Movie.prototype.gotoFrame;

  Movie.prototype["gotoLabel"] = Movie.prototype.gotoLabel;

  Movie.prototype["inspect"] = Movie.prototype.inspect;

  Movie.prototype["localToGlobal"] = Movie.prototype.localToGlobal;

  Movie.prototype["move"] = Movie.prototype.move;

  Movie.prototype["moveTo"] = Movie.prototype.moveTo;

  Movie.prototype["nextEnterFrame"] = Movie.prototype.nextEnterFrame;

  Movie.prototype["nextFrame"] = Movie.prototype.nextFrame;

  Movie.prototype["override"] = Movie.prototype.override;

  Movie.prototype["play"] = Movie.prototype.play;

  Movie.prototype["prevFrame"] = Movie.prototype.prevFrame;

  Movie.prototype["removeEventHandler"] = Movie.prototype.removeEventHandler;

  Movie.prototype["removeEventListener"] = Movie.prototype.removeEventHandler;

  Movie.prototype["removeMovieClip"] = Movie.prototype.removeMovieClip;

  Movie.prototype["requestCalculateBounds"] = Movie.prototype.requestCalculateBounds;

  Movie.prototype["rotate"] = Movie.prototype.rotate;

  Movie.prototype["rotateTo"] = Movie.prototype.rotateTo;

  Movie.prototype["scale"] = Movie.prototype.scale;

  Movie.prototype["scaleTo"] = Movie.prototype.scaleTo;

  Movie.prototype["searchAttachedLWF"] = Movie.prototype.searchAttachedLWF;

  Movie.prototype["searchAttachedMovie"] = Movie.prototype.searchAttachedMovie;

  Movie.prototype["searchMovieInstance"] = Movie.prototype.searchMovieInstance;

  Movie.prototype["searchMovieInstanceByInstanceId"] = Movie.prototype.searchMovieInstanceByInstanceId;

  Movie.prototype["setAlpha"] = Movie.prototype.setAlpha;

  Movie.prototype["setColorTransform"] = Movie.prototype.setColorTransform;

  Movie.prototype["setEventHandler"] = Movie.prototype.setEventHandler;

  Movie.prototype["setEventListener"] = Movie.prototype.setEventHandler;

  Movie.prototype["setMatrix"] = Movie.prototype.setMatrix;

  Movie.prototype["setRenderingOffset"] = Movie.prototype.setRenderingOffset;

  Movie.prototype["setVisible"] = Movie.prototype.setVisible;

  Movie.prototype["stop"] = Movie.prototype.stop;

  Movie.prototype["swapAttachedLWFDepth"] = Movie.prototype.swapAttachedLWFDepth;

  Movie.prototype["swapAttachedMovieDepth"] = Movie.prototype.swapAttachedMovieDepth;

  Movie.prototype["swapDepths"] = Movie.prototype.swapDepths;

  Property.prototype["clear"] = Property.prototype.clear;

  Property.prototype["move"] = Property.prototype.move;

  Property.prototype["moveTo"] = Property.prototype.moveTo;

  Property.prototype["rotate"] = Property.prototype.rotate;

  Property.prototype["rotateTo"] = Property.prototype.rotateTo;

  Property.prototype["scale"] = Property.prototype.scale;

  Property.prototype["scaleTo"] = Property.prototype.scaleTo;

  Property.prototype["setAlpha"] = Property.prototype.setAlpha;

  Property.prototype["setColorTransform"] = Property.prototype.setColorTransform;

  Property.prototype["setMatrix"] = Property.prototype.setMatrix;

  Matrix.prototype["clear"] = Matrix.prototype.clear;

  Matrix.prototype["set"] = Matrix.prototype.set;

  Color.prototype["set"] = Color.prototype.set;

  ColorTransform.prototype["clear"] = ColorTransform.prototype.clear;

  ColorTransform.prototype["set"] = ColorTransform.prototype.set;

  BitmapClip.prototype["detachFromParent"] = BitmapClip.prototype.detachFromParent;

  BitmapClip.prototype["setMatrix"] = BitmapClip.prototype.setMatrix;

  WebKitCSSRenderCommand = (function() {
    function WebKitCSSRenderCommand() {
      this.renderCount = 0;
      this.renderingIndex = 0;
      this.isBitmap = false;
      this.renderer = null;
      this.matrix = null;
      this.maskMode = 0;
    }

    return WebKitCSSRenderCommand;

  })();

  WebkitCSSRendererFactory = (function() {
    function WebkitCSSRendererFactory(data, resourceCache, cache, stage, textInSubpixel, use3D, recycleTextCanvas, quirkyClearRect) {
      var bitmap, bitmapEx, h, style, text, w, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      this.resourceCache = resourceCache;
      this.cache = cache;
      this.stage = stage;
      this.textInSubpixel = textInSubpixel;
      this.use3D = use3D;
      this.recycleTextCanvas = recycleTextCanvas;
      this.quirkyClearRect = quirkyClearRect;
      this.needsRenderForInactive = true;
      this.maskMode = "normal";
      this.bitmapContexts = [];
      _ref = data.bitmaps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bitmap = _ref[_i];
        if (bitmap.textureFragmentId === -1) {
          continue;
        }
        bitmapEx = new Format.BitmapEx();
        bitmapEx.matrixId = bitmap.matrixId;
        bitmapEx.textureFragmentId = bitmap.textureFragmentId;
        bitmapEx.u = 0;
        bitmapEx.v = 0;
        bitmapEx.w = 1;
        bitmapEx.h = 1;
        bitmapEx.attribute = 0;
        this.bitmapContexts.push(new WebkitCSSBitmapContext(this, data, bitmapEx));
      }
      this.bitmapExContexts = [];
      _ref1 = data.bitmapExs;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        bitmapEx = _ref1[_j];
        if (bitmapEx.textureFragmentId === -1) {
          continue;
        }
        this.bitmapExContexts.push(new WebkitCSSBitmapContext(this, data, bitmapEx));
      }
      this.textContexts = [];
      _ref2 = data.texts;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        text = _ref2[_k];
        this.textContexts.push(new WebkitCSSTextContext(this, data, text));
      }
      style = this.stage.style;
      style.display = "block";
      style.overflow = "hidden";
      style.webkitUserSelect = "none";
      if (this.use3D) {
        style.webkitTransform = "translateZ(0)";
        style.webkitTransformStyle = "preserve-3d";
      }
      _ref3 = this.getStageSize(), w = _ref3[0], h = _ref3[1];
      if (w === 0 && h === 0) {
        style.width = "" + data.header.width + "px";
        style.height = "" + data.header.height + "px";
      }
      this.initCommands();
      this.destructedRenderers = [];
    }

    WebkitCSSRendererFactory.prototype.initCommands = function() {
      if ((this.commands == null) || this.commandsCount < this.commands.length * 0.75) {
        this.commands = [];
      }
      this.commandsCount = 0;
      this.subCommands = null;
    };

    WebkitCSSRendererFactory.prototype.isMask = function(cmd) {
      switch (cmd.maskMode) {
        case "erase":
        case "mask":
        case "alpha":
          return true;
      }
      return false;
    };

    WebkitCSSRendererFactory.prototype.isLayer = function(cmd) {
      return cmd.maskMode === "layer";
    };

    WebkitCSSRendererFactory.prototype.addCommand = function(rIndex, cmd) {
      cmd.renderCount = this.lwf.renderCount;
      cmd.renderingIndex = rIndex;
      if (this.isMask(cmd)) {
        if (this.subCommands != null) {
          this.subCommands[rIndex] = cmd;
        }
      } else {
        if (this.isLayer(cmd) && this.commandMaskMode !== cmd.maskMode) {
          cmd.subCommands = [];
          this.subCommands = cmd.subCommands;
        }
        this.commands[rIndex] = cmd;
        this.commandsCount++;
      }
      this.commandMaskMode = cmd.maskMode;
    };

    WebkitCSSRendererFactory.prototype.addCommandToParent = function(lwf) {
      var cmd, f, rIndex, renderCount, scmd, srIndex, subCommands, _i, _j, _ref, _ref1;
      f = lwf.getRendererFactory();
      renderCount = lwf.renderCount;
      for (rIndex = _i = 0, _ref = this.commands.length; 0 <= _ref ? _i < _ref : _i > _ref; rIndex = 0 <= _ref ? ++_i : --_i) {
        cmd = this.commands[rIndex];
        if ((cmd == null) || cmd.renderingIndex !== rIndex || cmd.renderCount !== renderCount) {
          continue;
        }
        subCommands = cmd.subCommands;
        cmd.subCommands = null;
        f.addCommand(rIndex, cmd);
        if (subCommands != null) {
          for (srIndex = _j = 0, _ref1 = subCommands.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; srIndex = 0 <= _ref1 ? ++_j : --_j) {
            scmd = subCommands[srIndex];
            if ((scmd == null) || scmd.renderingIndex !== srIndex || scmd.renderCount !== renderCount) {
              continue;
            }
            f.addCommand(srIndex, scmd);
          }
        }
      }
      this.initCommands();
    };

    WebkitCSSRendererFactory.prototype.destruct = function() {
      var context, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      if (this.destructedRenderers != null) {
        this.callRendererDestructor();
      }
      _ref = this.bitmapContexts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        context = _ref[_i];
        context.destruct();
      }
      _ref1 = this.bitmapExContexts;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        context = _ref1[_j];
        context.destruct();
      }
      _ref2 = this.textContexts;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        context = _ref2[_k];
        context.destruct();
      }
    };

    WebkitCSSRendererFactory.prototype.init = function(lwf) {
      var domName, m, name, progObj, _i, _len, _ref, _results;
      this.lwf = lwf;
      lwf.stage = this.stage;
      lwf.resourceCache = this.resourceCache;
      if (this.setupedDomElementConstructor) {
        return;
      }
      this.setupedDomElementConstructor = true;
      _ref = lwf.data.programObjects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        progObj = _ref[_i];
        name = lwf.data.strings[progObj.stringId];
        m = name.match(/^DOM_(.*)/);
        if (m != null) {
          domName = m[1];
          _results.push((function(_this) {
            return function(domName) {
              return lwf.setProgramObjectConstructor(name, function(lwf_, objId, w, h) {
                var ctor, domElement;
                ctor = _this.resourceCache.domElementConstructor;
                if (ctor == null) {
                  return null;
                }
                domElement = ctor(lwf_, domName, w, h);
                if (domElement == null) {
                  return null;
                }
                return new WebkitCSSDomElementRenderer(_this, domElement);
              });
            };
          })(this)(domName));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    WebkitCSSRendererFactory.prototype.destructRenderer = function(renderer) {
      this.destructedRenderers.push(renderer);
    };

    WebkitCSSRendererFactory.prototype.callRendererDestructor = function() {
      var renderer, _i, _len, _ref;
      _ref = this.destructedRenderers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        renderer = _ref[_i];
        renderer.destructor();
      }
      this.destructedRenderers = [];
    };

    WebkitCSSRendererFactory.prototype.beginRender = function(lwf) {
      if (this.destructedRenderers != null) {
        this.callRendererDestructor();
      }
    };

    WebkitCSSRendererFactory.prototype.render = function(cmd) {
      var m, node, renderer, scaleX, scaleY, skew0, skew1, style, translateX, translateY;
      renderer = cmd.renderer;
      node = renderer.node;
      style = node.style;
      style.zIndex = renderer.zIndex;
      m = cmd.matrix;
      switch (cmd.maskMode) {
        case "mask":
        case "alpha":
          this.renderMasked = true;
          style.opacity = 0;
          if (this.renderMaskMode !== "mask" && this.renderMaskMode !== "alpha") {
            if (node.mask != null) {
              this.mask = node.mask;
              style = this.mask.style;
            } else {
              this.mask = node.mask = document.createElement("div");
              style = this.mask.style;
              style.display = "block";
              style.position = "absolute";
              style.overflow = "hidden";
              style.webkitUserSelect = "none";
              style.webkitTransformOrigin = "0px 0px";
              this.stage.appendChild(this.mask);
            }
            style.width = node.style.width;
            style.height = node.style.height;
            if (this.maskMatrix == null) {
              this.maskMatrix = new Matrix();
              this.maskedMatrix = new Matrix();
            }
            Utility.invertMatrix(this.maskMatrix, m);
          } else {
            return;
          }
          break;
        case "layer":
          if (this.renderMasked) {
            if (this.renderMaskMode !== cmd.maskMode) {
              this.mask.style.zIndex = renderer.zIndex;
            }
            if (node.parentNode !== this.mask) {
              node.parentNode.removeChild(node);
              this.mask.appendChild(node);
            }
            m = Utility.calcMatrix(this.maskedMatrix, this.maskMatrix, m);
          } else {
            if (node.parentNode !== this.stage) {
              node.parentNode.removeChild(node);
              this.stage.appendChild(node);
            }
          }
          break;
        default:
          if (node.parentNode !== this.stage) {
            node.parentNode.removeChild(node);
            this.stage.appendChild(node);
          }
      }
      this.renderMaskMode = cmd.maskMode;
      style.opacity = renderer.alpha;
      scaleX = m.scaleX.toFixed(12);
      scaleY = m.scaleY.toFixed(12);
      skew1 = m.skew1.toFixed(12);
      skew0 = m.skew0.toFixed(12);
      translateX = m.translateX.toFixed(12);
      translateY = m.translateY.toFixed(12);
      if (this.use3D) {
        style.webkitTransform = "matrix3d(" + ("" + scaleX + "," + skew1 + ",0,0,") + ("" + skew0 + "," + scaleY + ",0,0,") + "0,0,1,0," + ("" + translateX + "," + translateY + ",0,1)");
      } else {
        style.webkitTransform = "matrix(" + ("" + scaleX + "," + skew1 + "," + skew0 + "," + scaleY + "," + translateX + "," + translateY + ")");
      }
    };

    WebkitCSSRendererFactory.prototype.endRender = function(lwf) {
      var cmd, rIndex, renderCount, scmd, srIndex, _i, _j, _ref, _ref1;
      if (lwf.parent != null) {
        this.addCommandToParent(lwf);
        if (this.destructedRenderers != null) {
          this.callRendererDestructor();
        }
        return;
      }
      this.renderMaskMode = "normal";
      this.renderMasked = false;
      renderCount = lwf.renderCount;
      for (rIndex = _i = 0, _ref = this.commands.length; 0 <= _ref ? _i < _ref : _i > _ref; rIndex = 0 <= _ref ? ++_i : --_i) {
        cmd = this.commands[rIndex];
        if ((cmd == null) || cmd.renderingIndex !== rIndex || cmd.renderCount !== renderCount) {
          continue;
        }
        if (cmd.subCommands != null) {
          for (srIndex = _j = 0, _ref1 = cmd.subCommands.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; srIndex = 0 <= _ref1 ? ++_j : --_j) {
            scmd = cmd.subCommands[srIndex];
            if ((scmd == null) || scmd.renderingIndex !== srIndex || scmd.renderCount !== renderCount) {
              continue;
            }
            this.render(scmd);
          }
        }
        this.render(cmd);
      }
      this.initCommands();
      if (this.destructedRenderers != null) {
        this.callRendererDestructor();
      }
    };

    WebkitCSSRendererFactory.prototype.setBlendMode = function(blendMode) {};

    WebkitCSSRendererFactory.prototype.setMaskMode = function(maskMode) {
      this.maskMode = maskMode;
    };

    WebkitCSSRendererFactory.prototype.constructBitmap = function(lwf, objectId, bitmap) {
      var context;
      context = this.bitmapContexts[objectId];
      if (context) {
        return new WebkitCSSBitmapRenderer(context);
      }
    };

    WebkitCSSRendererFactory.prototype.constructBitmapEx = function(lwf, objectId, bitmapEx) {
      var context;
      context = this.bitmapExContexts[objectId];
      if (context) {
        return new WebkitCSSBitmapRenderer(context);
      }
    };

    WebkitCSSRendererFactory.prototype.constructText = function(lwf, objectId, text) {
      var context;
      context = this.textContexts[objectId];
      if (context) {
        return new WebkitCSSTextRenderer(lwf, context, text);
      }
    };

    WebkitCSSRendererFactory.prototype.constructParticle = function(lwf, objectId, particle) {
      var ctor, particleData;
      ctor = this.resourceCache.particleConstructor;
      particleData = lwf.data.particleDatas[particle.particleDataId];
      if (ctor != null) {
        return ctor(lwf, lwf.data.strings[particleData.stringId]);
      }
    };

    WebkitCSSRendererFactory.prototype.convertColor = function(lwf, d, c, t) {
      Utility.calcColor(lwf, d, c, t);
      d.red = Math.round(d.red * 255);
      d.green = Math.round(d.green * 255);
      d.blue = Math.round(d.blue * 255);
    };

    WebkitCSSRendererFactory.prototype.convertRGB = function(c) {
      var b, g, r;
      r = Math.round(c.red * 255);
      g = Math.round(c.green * 255);
      b = Math.round(c.blue * 255);
      return "rgb(" + r + "," + g + "," + b + ")";
    };

    WebkitCSSRendererFactory.prototype.getStageSize = function() {
      var r;
      r = this.stage.getBoundingClientRect();
      return [r.width, r.height];
    };

    WebkitCSSRendererFactory.prototype.fitForHeight = function(lwf) {
      var h, w, _ref;
      _ref = this.getStageSize(), w = _ref[0], h = _ref[1];
      if (h !== 0 && h !== lwf.data.header.height) {
        lwf.fitForHeight(w, h);
      }
    };

    WebkitCSSRendererFactory.prototype.fitForWidth = function(lwf) {
      var h, w, _ref;
      _ref = this.getStageSize(), w = _ref[0], h = _ref[1];
      if (w !== 0 && w !== lwf.data.header.width) {
        lwf.fitForWidth(w, h);
      }
    };

    WebkitCSSRendererFactory.prototype.scaleForHeight = function(lwf) {
      var h, w, _ref;
      _ref = this.getStageSize(), w = _ref[0], h = _ref[1];
      if (h !== 0 && h !== lwf.data.header.height) {
        lwf.scaleForHeight(w, h);
      }
    };

    WebkitCSSRendererFactory.prototype.scaleForWidth = function(lwf) {
      var h, w, _ref;
      _ref = this.getStageSize(), w = _ref[0], h = _ref[1];
      if (w !== 0 && w !== lwf.data.header.width) {
        lwf.scaleForWidth(w, h);
      }
    };

    WebkitCSSRendererFactory.prototype.parseBackgroundColor = function(v) {
      var a, b, bgColor, g, lwf, r;
      if (typeof v === "number") {
        bgColor = v;
      } else if (typeof v === "string") {
        bgColor = parseInt(v, 16);
      } else if (v instanceof LWF) {
        lwf = v;
        bgColor = lwf.data.header.backgroundColor;
        bgColor |= 0xff << 24;
      } else {
        return [255, 255, 255, 255];
      }
      a = (bgColor >> 24) & 0xff;
      r = (bgColor >> 16) & 0xff;
      g = (bgColor >> 8) & 0xff;
      b = (bgColor >> 0) & 0xff;
      return [r, g, b, a];
    };

    WebkitCSSRendererFactory.prototype.setBackgroundColor = function(v) {
      var a, b, g, r, _ref;
      _ref = this.parseBackgroundColor(v), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
      this.stage.style.backgroundColor = "rgba(" + r + "," + g + "," + b + "," + (a / 255) + ")";
    };

    WebkitCSSRendererFactory.prototype.clearCanvasRect = function(canvas, ctx) {
      ctx.clearRect(0, 0, canvas.width + 1, canvas.height + 1);
      if (this.quirkyClearRect) {
        canvas.width = canvas.width;
      }
    };

    WebkitCSSRendererFactory.prototype.setFont = function(oldFontName, newFontName) {
      var context, _i, _len, _ref;
      oldFontName += ",sans-serif";
      newFontName += ",sans-serif";
      _ref = this.textContexts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        context = _ref[_i];
        if (context.fontName === oldFontName) {
          context.fontName = newFontName;
          context.fontChanged = true;
        }
      }
    };

    return WebkitCSSRendererFactory;

  })();

  WebkitCSSBitmapContext = (function() {
    function WebkitCSSBitmapContext(factory, data, bitmapEx) {
      var bh, bu, bv, bw, h, image, imageScale, sh, su, sv, sw, texture, u, v, w, x, y;
      this.factory = factory;
      this.data = data;
      this.fragment = data.textureFragments[bitmapEx.textureFragmentId];
      texture = data.textures[this.fragment.textureId];
      image = this.factory.cache[texture.filename];
      imageScale = image.width / texture.width;
      this.scale = 1 / (texture.scale * imageScale);
      x = this.fragment.x;
      y = this.fragment.y;
      u = this.fragment.u;
      v = this.fragment.v;
      w = this.fragment.w;
      h = this.fragment.h;
      bu = bitmapEx.u * w;
      bv = bitmapEx.v * h;
      bw = bitmapEx.w;
      bh = bitmapEx.h;
      x += bu;
      y += bv;
      u += bu;
      v += bv;
      w *= bw;
      h *= bh;
      this.x = Math.round(x * imageScale);
      this.y = Math.round(y * imageScale);
      su = Math.round(u * imageScale);
      sv = Math.round(v * imageScale);
      if (this.fragment.rotated) {
        sw = Math.round(h * imageScale);
        sh = Math.round(w * imageScale);
      } else {
        sw = Math.round(w * imageScale);
        sh = Math.round(h * imageScale);
      }
      this.h = Math.round(h * imageScale);
      this.node = document.createElement("div");
      if (image.src != null) {
        this.node.style.background = "url(" + image.src + ") transparent";
      } else if (typeof document.getCSSCanvasContext !== "undefined") {
        this.node.style.background = "-webkit-canvas(" + image.name + ") transparent";
      } else {
        this.node.style.background = "url(" + (image.toDataURL('image/png')) + ") transparent";
      }
      this.node.style.backgroundPosition = "" + (-su) + "px " + (-sv) + "px";
      this.node.style.width = "" + sw + "px";
      this.node.style.height = "" + sh + "px";
      this.node.style.display = "block";
      this.node.style.pointerEvents = "none";
      this.node.style.position = "absolute";
      this.node.style.webkitTransformOrigin = "0px 0px";
      this.width = sw;
      this.height = sh;
      this.cache = [];
    }

    WebkitCSSBitmapContext.prototype.destruct = function() {
      var node, _i, _len, _ref;
      _ref = this.cache;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node.mask != null) {
          node.mask.parentNode.removeChild(node.mask);
        }
        node.parentNode.removeChild(node);
      }
    };

    return WebkitCSSBitmapContext;

  })();

  WebkitCSSBitmapRenderer = (function() {
    function WebkitCSSBitmapRenderer(context) {
      var fragment;
      this.context = context;
      this.matrix = new Matrix(0, 0, 0, 0, 0, 0);
      this.alpha = -1;
      this.zIndex = -1;
      this.visible = true;
      fragment = this.context.fragment;
      if (fragment.rotated || this.context.x !== 0 || this.context.y !== 0 || this.context.scale !== 1) {
        this.matrixForAtlas = new Matrix();
      }
      this.cmd = {};
    }

    WebkitCSSBitmapRenderer.prototype.destructor = function() {
      if (this.node != null) {
        this.node.style.visibility = "hidden";
        this.context.cache.push(this.node);
      }
    };

    WebkitCSSBitmapRenderer.prototype.destruct = function() {
      this.context.factory.destructRenderer(this);
    };

    WebkitCSSBitmapRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var cmd, fragment, maskMode, matrixChanged, scale, x, y;
      if (this.visible === visible) {
        if (visible === false) {
          return;
        }
      } else {
        this.visible = visible;
        if (visible === false) {
          if (this.node != null) {
            this.node.style.visibility = "hidden";
          }
          return;
        } else {
          if (this.node != null) {
            this.node.style.visibility = "visible";
          }
        }
      }
      if (this.node == null) {
        if (this.context.cache.length > 0) {
          this.node = this.context.cache.pop();
          this.node.style.visibility = "visible";
        } else {
          this.node = this.context.node.cloneNode(true);
          this.context.factory.stage.appendChild(this.node);
        }
      }
      matrixChanged = this.matrix.setWithComparing(m);
      if (matrixChanged) {
        m = this.matrix;
        fragment = this.context.fragment;
        x = this.context.x;
        y = this.context.y;
        scale = this.context.scale;
        if (fragment.rotated) {
          m = Utility.rotateMatrix(this.matrixForAtlas, m, scale, x, y + this.context.h);
        } else if (scale !== 1 || x !== 0 || y !== 0) {
          m = Utility.scaleMatrix(this.matrixForAtlas, m, scale, x, y);
        }
      } else {
        if (this.matrixForAtlas != null) {
          m = this.matrixForAtlas;
        } else {
          m = this.matrix;
        }
      }
      maskMode = this.context.factory.maskMode;
      if (!matrixChanged && this.alpha === c.multi.alpha && this.zIndex === renderingIndex && maskMode === "normal" && this.node.parentNode === this.context.factory.stage) {
        return;
      }
      this.alpha = c.multi.alpha;
      this.zIndex = renderingIndex;
      cmd = this.cmd;
      cmd.isBitmap = true;
      cmd.renderer = this;
      cmd.matrix = m;
      cmd.maskMode = maskMode;
      this.context.factory.addCommand(renderingIndex, cmd);
    };

    return WebkitCSSBitmapRenderer;

  })();

  HTML5TextContext = (function() {
    function HTML5TextContext(factory, data, text) {
      var font;
      this.factory = factory;
      this.data = data;
      this.text = text;
      this.str = this.data.strings[this.text.stringId];
      this.textProperty = this.data.textProperties[this.text.textPropertyId];
      font = this.data.fonts[this.textProperty.fontId];
      this.textColor = this.data.colors[this.text.colorId];
      if (this.textProperty.strokeColorId !== -1) {
        this.strokeColor = this.data.colors[this.textProperty.strokeColorId];
      }
      if (this.textProperty.shadowColorId !== -1) {
        this.shadowColor = this.data.colors[this.textProperty.shadowColorId];
      }
      this.fontName = "" + this.data.strings[font.stringId] + ",sans-serif";
      this.fontChanged = true;
      this.letterSpacing = font.letterSpacing + this.textProperty.letterSpacing;
    }

    HTML5TextContext.prototype.destruct = function() {};

    return HTML5TextContext;

  })();

  HTML5TextRenderer = (function() {
    function HTML5TextRenderer(lwf, context, textObject) {
      var _ref;
      this.lwf = lwf;
      this.context = context;
      this.textObject = textObject;
      this.str = (_ref = this.textObject.parent[this.textObject.name]) != null ? _ref : this.context.str;
      if (this.str != null) {
        this.str = String(this.str);
      }
      this.matrixForCheck = new Matrix(0, 0, 0, 0, 0, 0);
      this.matrix = new Matrix();
      this.color = new Color;
      this.textRendered = false;
      this.textScale = this.lwf.textScale;
      this.currentShadowMarginY = 0;
      this.changed = false;
      this.initCanvas();
    }

    HTML5TextRenderer.prototype.destruct = function() {};

    HTML5TextRenderer.prototype.measureText = function(str) {
      var swidth;
      swidth = str.length <= 1 ? 0 : (str.length - 1) * this.letterSpacing;
      return this.canvasContext.measureText(str).width + swidth;
    };

    HTML5TextRenderer.prototype.fitText = function(line, words, lineStart, imin, imax) {
      var imid, start, str, w;
      if (imax < imin) {
        return;
      }
      imid = ((imin + imax) / 2) >> 0;
      start = lineStart === 0 ? 0 : words[lineStart - 1];
      str = line.slice(start, words[imid]);
      w = this.measureText(str);
      if (w <= this.maxWidth) {
        if (w > this.lineWidth) {
          this.index = imid;
          this.lineWidth = w;
        }
        this.fitText(line, words, lineStart, imid + 1, imax);
      }
      if (w >= this.lineWidth) {
        this.fitText(line, words, lineStart, imin, imid - 1);
      }
    };

    HTML5TextRenderer.prototype.adjustText = function(lines) {
      var c, i, imax, imin, line, newlines, prev, start, str, to, word, words, _i, _j, _k, _len, _len1, _ref;
      newlines = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        words = line.split(" ");
        line = "";
        for (_j = 0, _len1 = words.length; _j < _len1; _j++) {
          word = words[_j];
          if (word.length > 0) {
            if (line.length > 0) {
              line += " ";
            }
            line += word;
          }
        }
        if (this.measureText(line) > this.maxWidth) {
          words = [];
          prev = 0;
          for (i = _k = 1, _ref = line.length; 1 <= _ref ? _k < _ref : _k > _ref; i = 1 <= _ref ? ++_k : --_k) {
            c = line.charCodeAt(i);
            if (c === 0x20 || c >= 0x80 || prev >= 0x80) {
              words.push(i);
            }
            prev = c;
          }
          words.push(line.length);
          imin = 0;
          imax = words.length - 1;
          while (true) {
            this.index = null;
            this.lineWidth = 0;
            this.fitText(line, words, imin, imin, imax);
            if (this.index === null) {
              break;
            }
            start = imin === 0 ? 0 : words[imin - 1];
            if (line.charCodeAt(start) === 0x20) {
              ++start;
            }
            to = words[this.index];
            str = line.slice(start, to);
            if (this.index === imax) {
              line = str;
              break;
            }
            newlines.push(str);
            start = to + (line.charCodeAt(to) === 0x20 ? 1 : 0);
            str = line.slice(start);
            if (this.measureText(str) <= this.maxWidth) {
              line = str;
              break;
            }
            imin = this.index + 1;
          }
        }
        newlines.push(line);
      }
      return newlines;
    };

    HTML5TextRenderer.prototype.renderLines = function(ctx, lines, useStroke, shadowColor, offsetY) {
      var c, i, j, line, offset, x, y, _i, _j, _k, _ref, _ref1, _ref2;
      for (i = _i = 0, _ref = lines.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        line = lines[i];
        x = this.offsetX * this.lwf.textScale;
        if (this.letterSpacing !== 0) {
          switch (this.context.textProperty.align & Align.ALIGN_MASK) {
            case Align.RIGHT:
              x -= this.measureText(line);
              break;
            case Align.CENTER:
              x -= this.measureText(line) / 2;
          }
        }
        y = offsetY + (this.fontHeight + this.leading) * i * 96 / 72;
        if (useStroke) {
          if (shadowColor != null) {
            ctx.shadowColor = "rgba(0, 0, 0, 0)";
          }
          if (this.letterSpacing === 0) {
            ctx.strokeText(line, x, y);
          } else {
            offset = 0;
            for (j = _j = 0, _ref1 = line.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              c = line[j];
              ctx.strokeText(c, x + offset, y);
              offset += this.canvasContext.measureText(c).width + this.letterSpacing;
            }
          }
        }
        if (shadowColor != null) {
          ctx.shadowColor = shadowColor;
        }
        if (this.letterSpacing === 0) {
          ctx.fillText(line, x, y);
        } else {
          offset = 0;
          for (j = _k = 0, _ref2 = line.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
            c = line[j];
            ctx.fillText(c, x + offset, y);
            offset += this.canvasContext.measureText(c).width + this.letterSpacing;
          }
        }
      }
    };

    HTML5TextRenderer.prototype.renderText = function(textColor) {
      var c, canvas, context, ctx, first, h, height, img, last, lines, offsetY, property, r, shadowColor, useStroke, width, _i, _j;
      this.textRendered = true;
      context = this.context;
      canvas = this.canvas;
      ctx = this.canvasContext;
      lines = this.adjustText(this.str.split("\n"));
      property = context.textProperty;
      useStroke = context.strokeColor != null;
      if (context.shadowColor != null) {
        shadowColor = context.factory.convertRGB(context.shadowColor);
      }
      context.factory.clearCanvasRect(canvas, ctx);
      this.initCanvasContext(ctx, textColor);
      offsetY = this.fontHeight * 1.2;
      switch (property.align & Align.VERTICAL_MASK) {
        case Align.VERTICAL_BOTTOM:
        case Align.VERTICAL_MIDDLE:
          this.renderLines(ctx, lines, useStroke, "rgba(0, 0, 0, 0)", offsetY);
          img = ctx.getImageData(0, 0, canvas.width, canvas.height);
          width = canvas.width;
          height = canvas.height;
          first = null;
          last = null;
          r = 0;
          while ((first == null) && r < height) {
            for (c = _i = 0; 0 <= width ? _i < width : _i > width; c = 0 <= width ? ++_i : --_i) {
              if (img.data[r * width * 4 + c * 4 + 3] !== 0) {
                first = r;
                break;
              }
            }
            r++;
          }
          r = height;
          while ((last == null) && r > 0) {
            r--;
            for (c = _j = 0; 0 <= width ? _j < width : _j > width; c = 0 <= width ? ++_j : --_j) {
              if (img.data[r * width * 4 + c * 4 + 3] !== 0) {
                last = r;
                break;
              }
            }
          }
          if ((first != null) && (last != null)) {
            h = last - first + 1;
            switch (property.align & Align.VERTICAL_MASK) {
              case Align.VERTICAL_BOTTOM:
                offsetY += height - h - first - this.currentShadowMarginY;
                break;
              case Align.VERTICAL_MIDDLE:
                offsetY += (height - h) / 2 - first - this.currentShadowMarginY;
            }
          }
          context.factory.clearCanvasRect(canvas, ctx);
          if (context.factory.quirkyClearRect != null) {
            this.initCanvasContext(ctx, textColor);
          }
      }
      this.renderLines(ctx, lines, useStroke, shadowColor, offsetY);
    };

    HTML5TextRenderer.prototype.needsScale = function() {
      return true;
    };

    HTML5TextRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var blue, colorChanged, fontChanged, green, property, red, scale, scaleChanged, str, strChanged;
      this.matrixChanged = this.matrixForCheck.setWithComparing(m);
      if (this.matrixChanged) {
        if (this.needsScale()) {
          m = Utility.scaleMatrix(this.matrix, m, 1 / this.lwf.textScale, 0, 0);
        } else {
          m = Utility.copyMatrix(this.matrix, m);
        }
        if (this.context.shadowColor != null) {
          property = this.context.textProperty;
          scale = this.lwf.textScale;
          this.currentShadowMarginY = 0;
          switch (property.align & Align.VERTICAL_MASK) {
            case Align.VERTICAL_BOTTOM:
              if (property.shadowOffsetY > 0) {
                this.currentShadowMarginY = property.shadowOffsetY * scale;
              }
              this.currentShadowMarginY += property.shadowBlur * scale;
              break;
            case Align.VERTICAL_MIDDLE:
              break;
            default:
              if (property.shadowOffsetY < 0) {
                this.currentShadowMarginY = property.shadowOffsetY * scale;
              }
              this.currentShadowMarginY -= property.shadowBlur * scale;
          }
          m.translateY += m.scaleY * this.currentShadowMarginY;
        }
        if (!this.context.factory.textInSubpixel) {
          m.translateX = Math.round(m.translateX);
          m.translateY = Math.round(m.translateY);
        }
      }
      red = this.color.red;
      green = this.color.green;
      blue = this.color.blue;
      this.context.factory.convertColor(this.lwf, this.color, this.context.textColor, c);
      c = this.color;
      colorChanged = false;
      if (red !== c.red || green !== c.green || blue !== c.blue) {
        colorChanged = true;
      }
      fontChanged = false;
      if (this.context.fontChanged) {
        fontChanged = true;
        this.context.fontChanged = false;
      }
      strChanged = false;
      str = this.textObject.parent[this.textObject.name];
      if (str != null) {
        str = String(str);
      }
      if ((str != null) && str !== this.str) {
        strChanged = true;
        this.str = str;
        if (!this.context.factory.recycleTextCanvas) {
          this.initCanvas();
        }
      }
      scaleChanged = false;
      if (this.textScale !== this.lwf.textScale) {
        scaleChanged = true;
        this.initCanvas();
        this.textScale = this.lwf.textScale;
      }
      this.changed = false;
      if (!this.textRendered || colorChanged || fontChanged || strChanged || scaleChanged) {
        this.renderText(c);
        this.changed = true;
      }
    };

    HTML5TextRenderer.prototype.initCanvas = function() {
      var canvas, ctx, leftMargin, lm, property, rightMargin, rm, scale, sw, text, _ref;
      scale = this.lwf.textScale;
      property = this.context.textProperty;
      this.leading = property.leading * scale;
      this.fontHeight = property.fontHeight * scale;
      leftMargin = property.leftMargin / this.fontHeight;
      rightMargin = property.rightMargin / this.fontHeight;
      lm = 0;
      rm = 0;
      if (this.context.strokeColor != null) {
        lm = rm = property.strokeWidth / 2 * scale;
      }
      if (this.context.shadowColor != null) {
        sw = (property.shadowBlur - property.shadowOffsetX) * scale;
        if (sw > lm) {
          lm = sw;
        }
        sw = (property.shadowOffsetX + property.shadowBlur) * scale;
        if (sw > rm) {
          rm = sw;
        }
      }
      leftMargin += lm;
      rightMargin += rm;
      text = this.context.text;
      switch (property.align & Align.ALIGN_MASK) {
        case Align.RIGHT:
          this.align = "right";
          this.offsetX = text.width - rightMargin;
          break;
        case Align.CENTER:
          this.align = "center";
          this.offsetX = text.width / 2;
          break;
        default:
          this.align = "left";
          this.offsetX = leftMargin;
      }
      _ref = this.context.factory.resourceCache.createCanvas(this.context.text.width * scale, this.context.text.height * scale), canvas = _ref[0], ctx = _ref[1];
      this.maxWidth = canvas.width - (leftMargin + rightMargin);
      this.initCanvasContext(ctx);
      this.canvas = canvas;
      this.canvasContext = ctx;
      this.letterSpacing = ctx.measureText('M').width * this.context.letterSpacing;
    };

    HTML5TextRenderer.prototype.initCanvasContext = function(ctx, textColor) {
      var context, property, scale;
      ctx.font = "" + this.fontHeight + "px " + this.context.fontName;
      ctx.textAlign = this.align;
      ctx.textBaseline = "bottom";
      if (textColor == null) {
        return;
      }
      context = this.context;
      property = context.textProperty;
      scale = this.lwf.textScale;
      ctx.fillStyle = "rgb(" + textColor.red + "," + textColor.green + "," + textColor.blue + ")";
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      if (context.strokeColor != null) {
        ctx.strokeStyle = context.factory.convertRGB(context.strokeColor);
        ctx.lineWidth = property.strokeWidth * scale;
      }
      if (context.shadowColor != null) {
        ctx.shadowOffsetX = property.shadowOffsetX * scale;
        ctx.shadowOffsetY = property.shadowOffsetY * scale;
        ctx.shadowBlur = property.shadowBlur * scale;
      }
    };

    return HTML5TextRenderer;

  })();

  WebkitCSSTextContext = (function(_super) {
    __extends(WebkitCSSTextContext, _super);

    function WebkitCSSTextContext() {
      return WebkitCSSTextContext.__super__.constructor.apply(this, arguments);
    }

    return WebkitCSSTextContext;

  })(HTML5TextContext);

  WebkitCSSTextRenderer = (function(_super) {
    __extends(WebkitCSSTextRenderer, _super);

    function WebkitCSSTextRenderer(lwf, context, textObject) {
      this.lwf = lwf;
      this.context = context;
      this.textObject = textObject;
      WebkitCSSTextRenderer.__super__.constructor.call(this, this.lwf, this.context, this.textObject);
      this.alpha = -1;
      this.zIndex = -1;
      this.visible = false;
      this.node = null;
      this.currentCanvas = null;
      this.cmd = {};
    }

    WebkitCSSTextRenderer.prototype.destructor = function() {
      if (this.node != null) {
        this.node.parentNode.removeChild(this.node);
      }
    };

    WebkitCSSTextRenderer.prototype.destruct = function() {
      this.context.factory.destructRenderer(this);
    };

    WebkitCSSTextRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var cmd, maskMode, nodeChanged;
      if (this.visible === visible) {
        if (visible === false) {
          return;
        }
      } else {
        this.visible = visible;
        if (visible === false) {
          if (this.node != null) {
            this.node.style.visibility = "hidden";
          }
          return;
        } else {
          if (this.node != null) {
            this.node.style.visibility = "visible";
          }
        }
      }
      WebkitCSSTextRenderer.__super__.render.call(this, m, c, renderingIndex, renderingCount, visible);
      nodeChanged = false;
      if (this.node == null) {
        this.node = document.createElement("div");
        this.node.style.width = "" + this.canvas.width + "px";
        this.node.style.height = "" + this.canvas.height + "px";
        this.node.style.display = "block";
        this.node.style.pointerEvents = "none";
        this.node.style.position = "absolute";
        this.node.style.webkitTransformOrigin = "0px 0px";
        this.node.style.visibility = "visible";
        this.context.factory.stage.appendChild(this.node);
        nodeChanged = true;
      }
      if (typeof document.getCSSCanvasContext !== 'undefined' && this.currentCanvas !== this.canvas) {
        this.node.style.background = "-webkit-canvas(" + this.canvas.name + ") transparent";
        this.currentCanvas = this.canvas;
      } else if (this.changed || this.currentCanvas !== this.canvas) {
        this.node.style.background = "url(" + (this.canvas.toDataURL('image/png')) + ") transparent";
        this.currentCanvas = this.canvas;
      }
      maskMode = this.context.factory.maskMode;
      if (!nodeChanged && !this.matrixChanged && this.alpha === c.multi.alpha && this.zIndex === renderingIndex && maskMode === "normal" && this.node.parentNode === this.context.factory.stage) {
        return;
      }
      this.alpha = c.multi.alpha;
      this.zIndex = renderingIndex;
      cmd = this.cmd;
      cmd.isBitmap = false;
      cmd.renderer = this;
      cmd.matrix = this.matrix;
      cmd.maskMode = maskMode;
      this.context.factory.addCommand(renderingIndex, cmd);
    };

    return WebkitCSSTextRenderer;

  })(HTML5TextRenderer);

  WebkitCSSDomElementRenderer = (function() {
    function WebkitCSSDomElementRenderer(factory, node) {
      this.factory = factory;
      this.node = node;
      this.appended = false;
      this.node.style.visibility = "hidden";
      this.matrix = new Matrix(0, 0, 0, 0, 0, 0);
      this.matrixForDom = new Matrix(0, 0, 0, 0, 0, 0);
      this.matrixForRender = new Matrix(0, 0, 0, 0, 0, 0);
      this.alpha = -1;
      this.zIndex = -1;
      this.visible = false;
    }

    WebkitCSSDomElementRenderer.prototype.destructor = function() {
      if (this.appended) {
        this.factory.stage.parentNode.removeChild(this.node);
      }
    };

    WebkitCSSDomElementRenderer.prototype.destruct = function() {
      if (this.factory.resourceCache.constructor === WebkitCSSResourceCache) {
        this.factory.destructRenderer(this);
      } else {
        this.destructor();
      }
    };

    WebkitCSSDomElementRenderer.prototype.update = function(m, c) {};

    WebkitCSSDomElementRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var dpr, matrixChanged, rn, rs, style;
      if (this.visible === visible) {
        if (visible === false) {
          return;
        }
      } else {
        this.visible = visible;
        if (visible === false) {
          this.node.style.visibility = "hidden";
          return;
        } else {
          this.node.style.visibility = "visible";
        }
      }
      matrixChanged = this.matrix.setWithComparing(m);
      if (!matrixChanged && this.appended && this.alpha === c.multi.alpha && this.zIndex === renderingIndex + renderingCount) {
        return;
      }
      if (!this.appended) {
        this.appended = true;
        this.node.style.position = "absolute";
        this.node.style.webkitTransformOrigin = "0px 0px";
        this.node.style.display = "block";
        this.factory.stage.parentNode.appendChild(this.node);
      }
      this.alpha = c.multi.alpha;
      this.zIndex = renderingIndex + renderingCount;
      style = this.node.style;
      style.zIndex = this.zIndex;
      style.opacity = this.alpha;
      style.webkitTransform = "none";
      rs = this.factory.stage.getBoundingClientRect();
      rn = this.node.getBoundingClientRect();
      dpr = this.factory.resourceCache.constructor === WebkitCSSResourceCache ? 1 : window.devicePixelRatio;
      m = this.matrixForDom;
      m.scaleX = 1 / dpr;
      m.scaleY = 1 / dpr;
      m.translateX = rs.left - rn.left;
      m.translateY = rs.top - rn.top;
      m = Utility.calcMatrix(this.matrixForRender, this.matrixForDom, this.matrix);
      if (this.use3D) {
        style.webkitTransform = "matrix3d(" + ("" + m.scaleX + "," + m.skew1 + ",0,0,") + ("" + m.skew0 + "," + m.scaleY + ",0,0,") + "0,0,1,0," + ("" + m.translateX + "," + m.translateY + ",0,1)");
      } else {
        style.webkitTransform = "matrix(" + ("" + m.scaleX + "," + m.skew1 + "," + m.skew0 + "," + m.scaleY + ",") + ("" + m.translateX + "," + m.translateY + ")");
      }
    };

    return WebkitCSSDomElementRenderer;

  })();

  WebkitCSSLoader = (function() {
    function WebkitCSSLoader() {}

    WebkitCSSLoader.load = function(d) {
      var a, b, i, option, _i, _j, _ref, _ref1;
      if ((d == null) || typeof d !== "string") {
        return null;
      }
      option = d.charCodeAt(Format.Constant.OPTION_OFFSET) & 0xff;
      if ((option & Format.Constant.OPTION_COMPRESSED) === 0) {
        return Loader.load(d);
      }
      if (typeof Uint8Array !== 'undefined') {
        a = new ArrayBuffer(d.length);
        b = new Uint8Array(a);
        for (i = _i = 0, _ref = d.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          b[i] = d.charCodeAt(i) & 0xff;
        }
        return this.loadArrayBuffer(a);
      } else {
        a = new Array(d.length);
        for (i = _j = 0, _ref1 = d.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          a[i] = d.charCodeAt(i) & 0xff;
        }
        return this.loadArray(a);
      }
    };

    WebkitCSSLoader.loadArray = function(d) {
      var compressed, decompressed, e, header, option;
      if (d == null) {
        return null;
      }
      option = d[Format.Constant.OPTION_OFFSET];
      if ((option & Format.Constant.OPTION_COMPRESSED) === 0) {
        return Loader.loadArray(d);
      }
      header = d.slice(0, Format.Constant.HEADER_SIZE);
      compressed = d.slice(Format.Constant.HEADER_SIZE);
      try {
        decompressed = global["LWF"].LZMA.decompressFile(compressed);
      } catch (_error) {
        e = _error;
        return null;
      }
      d = header.concat(decompressed);
      return Loader.loadArray(d);
    };

    WebkitCSSLoader.loadArrayBuffer = function(d) {
      var compressed, decompressed, e, header, o, option;
      if (d == null) {
        return null;
      }
      o = new Uint8Array(d, Format.Constant.OPTION_OFFSET, 1);
      option = o[0];
      if ((option & Format.Constant.OPTION_COMPRESSED) === 0) {
        return Loader.loadArrayBuffer(d);
      }
      header = new Uint8Array(d.slice(0, Format.Constant.HEADER_SIZE));
      compressed = new Uint8Array(d.slice(Format.Constant.HEADER_SIZE));
      try {
        decompressed = global["LWF"].LZMA.decompressFile(compressed);
        decompressed = new Uint8Array(decompressed);
      } catch (_error) {
        e = _error;
        return null;
      }
      d = new Uint8Array(header.length + decompressed.length);
      d.set(header, 0);
      d.set(decompressed, Format.Constant.HEADER_SIZE);
      return Loader.loadArrayBuffer(d.buffer);
    };

    return WebkitCSSLoader;

  })();

  WebkitCSSResourceCache = (function() {
    var _instance;

    _instance = null;

    WebkitCSSResourceCache.get = function() {
      return _instance != null ? _instance : _instance = new this();
    };

    function WebkitCSSResourceCache() {
      this.cache = {};
      this.lwfInstanceIndex = 0;
      this.canvasIndex = 0;
    }

    WebkitCSSResourceCache.prototype.getRendererName = function() {
      return "WebkitCSS";
    };

    WebkitCSSResourceCache.prototype.clear = function() {
      var cache, k, kk, lwfInstance, _ref, _ref1;
      _ref = this.cache;
      for (k in _ref) {
        cache = _ref[k];
        _ref1 = cache.instances;
        for (kk in _ref1) {
          lwfInstance = _ref1[kk];
          lwfInstance.destroy();
        }
      }
      return this.cache = {};
    };

    WebkitCSSResourceCache.prototype.getTextureURL = function(settings, data, texture) {
      var imageMap, newUrl, prefix, queryString, suffix, url, _ref, _ref1, _ref2, _ref3;
      prefix = (_ref = (_ref1 = settings["imagePrefix"]) != null ? _ref1 : settings["prefix"]) != null ? _ref : "";
      suffix = (_ref2 = settings["imageSuffix"]) != null ? _ref2 : "";
      queryString = (_ref3 = settings["imageQueryString"]) != null ? _ref3 : "";
      if (queryString.length > 0) {
        queryString = "?" + queryString;
      }
      imageMap = settings["imageMap"];
      url = texture.filename;
      if (typeof imageMap === 'function') {
        newUrl = imageMap.call(settings, url);
        if (newUrl != null) {
          url = newUrl;
        }
      } else if (typeof imageMap === 'object') {
        newUrl = imageMap[url];
        if (newUrl != null) {
          url = newUrl;
        }
      }
      if (!(url.match(/^\//) || url.match(/^https?:\/\//))) {
        url = prefix + url;
      }
      url = url.replace(/(\.gif|\.png|\.jpg)/i, suffix + "$1" + queryString);
      return url;
    };

    WebkitCSSResourceCache.prototype.checkTextures = function(settings, data) {
      var a, b, colorOp, colorValue, g, h, m, ma, orig, pngFilename, r, re, re_add, re_add10, re_rgb, re_rgb10, re_rgba, re_rgba10, rotated, t, texture, u, v, w, x, y, _base, _i, _len, _ref;
      settings._alphaMap = {};
      settings._colorMap = {};
      settings._textures = [];
      re = new RegExp("_atlas_(.*)_info_" + "([0-9])_([0-9]+)_([0-9]+)_([0-9]+)_([0-9]+)_([0-9]+)_([0-9]+)", "i");
      re_rgb = new RegExp("(.*)_rgb_([0-9a-f]{6})(.*)$", "i");
      re_rgb10 = new RegExp("(.*)_rgb_([0-9]*),([0-9]*),([0-9]*)(.*)$", "i");
      re_rgba = new RegExp("(.*)_rgba_([0-9a-f]{8})(.*)$", "i");
      re_rgba10 = new RegExp("(.*)_rgba_([0-9]*),([0-9]*),([0-9]*),([0-9]*)(.*)$", "i");
      re_add = new RegExp("(.*)_add_([0-9a-f]{6})(.*)$", "i");
      re_add10 = new RegExp("(.*)_add_([0-9]*),([0-9]*),([0-9]*)(.*)$", "i");
      _ref = data.textures;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        texture = _ref[_i];
        orig = null;
        if ((m = texture.filename.match(re_rgb)) != null) {
          orig = m[1] + m[3];
          colorOp = "rgb";
          colorValue = m[2];
        } else if ((m = texture.filename.match(re_rgb10)) != null) {
          orig = m[1] + m[5];
          colorOp = "rgb";
          r = parseInt(m[2], 10).toString(16);
          g = parseInt(m[3], 10).toString(16);
          b = parseInt(m[4], 10).toString(16);
          colorValue = (r.length === 1 ? "0" : "") + r + (g.length === 1 ? "0" : "") + g + (b.length === 1 ? "0" : "") + b;
        } else if ((m = texture.filename.match(re_rgba)) != null) {
          orig = m[1] + m[3];
          colorOp = "rgba";
          colorValue = m[2];
        } else if ((m = texture.filename.match(re_rgba10)) != null) {
          orig = m[1] + m[6];
          colorOp = "rgba";
          r = parseInt(m[2], 10).toString(16);
          g = parseInt(m[3], 10).toString(16);
          b = parseInt(m[4], 10).toString(16);
          a = parseInt(m[5], 10).toString(16);
          colorValue = (r.length === 1 ? "0" : "") + r + (g.length === 1 ? "0" : "") + g + (b.length === 1 ? "0" : "") + b + (a.length === 1 ? "0" : "") + a;
        } else if ((m = texture.filename.match(re_add)) != null) {
          orig = m[1] + m[3];
          colorOp = "add";
          colorValue = m[2];
        } else if ((m = texture.filename.match(re_add10)) != null) {
          orig = m[1] + m[5];
          colorOp = "add";
          r = parseInt(m[2], 10).toString(16);
          g = parseInt(m[3], 10).toString(16);
          b = parseInt(m[4], 10).toString(16);
          colorValue = (r.length === 1 ? "0" : "") + r + (g.length === 1 ? "0" : "") + g + (b.length === 1 ? "0" : "") + b;
        }
        if (orig != null) {
          ma = texture.filename.match(re);
          if (ma != null) {
            orig = ma[1];
            rotated = ma[2] === "1" ? true : false;
            u = parseInt(ma[3], 10);
            v = parseInt(ma[4], 10);
            w = parseInt(ma[5], 10);
            h = parseInt(ma[6], 10);
            x = parseInt(ma[7], 10);
            y = parseInt(ma[8], 10);
          } else {
            rotated = false;
            u = 0;
            v = 0;
            w = null;
            h = null;
            x = 0;
            y = 0;
          }
          if ((_base = settings._colorMap)[orig] == null) {
            _base[orig] = [];
          }
          settings._colorMap[orig].push({
            filename: texture.filename,
            colorOp: colorOp,
            colorValue: colorValue,
            rotated: rotated,
            u: u,
            v: v,
            w: w,
            h: h,
            x: x,
            y: y
          });
          continue;
        }
        settings._textures.push(texture);
        m = texture.filename.match(/^(.*)_withalpha(.*\.)jpg(.*)$/i);
        if (m != null) {
          pngFilename = "" + m[1] + "_alpha" + m[2] + "png" + m[3];
          t = new Format.TextureReplacement(pngFilename);
          settings._textures.push(t);
          settings._alphaMap[texture.filename] = [texture, t];
          settings._alphaMap[t.filename] = [texture, t];
        }
      }
    };

    WebkitCSSResourceCache.prototype.onloaddata = function(settings, data, url) {
      var needsToLoadScript, _ref, _ref1;
      if (!((data != null) && data.check())) {
        settings.error.push({
          url: url,
          reason: "dataError"
        });
        settings["onload"].call(settings, null);
        return;
      }
      settings["name"] = data.name();
      this.checkTextures(settings, data);
      needsToLoadScript = data.useScript && (((_ref = global["LWF"]) != null ? (_ref1 = _ref["Script"]) != null ? _ref1[data.name()] : void 0 : void 0) == null);
      this.cache[settings["lwfUrl"]].data = data;
      settings.total = settings._textures.length + 1;
      if (needsToLoadScript) {
        settings.total++;
      }
      settings.loadedCount = 1;
      if (settings["onprogress"] != null) {
        settings["onprogress"].call(settings, settings.loadedCount, settings.total);
      }
      if (needsToLoadScript) {
        this.loadJS(settings, data);
      } else {
        this.loadImages(settings, data);
      }
    };

    WebkitCSSResourceCache.prototype.loadLWF = function(settings) {
      var data, lwfUrl, _ref;
      lwfUrl = settings["lwf"];
      if (!lwfUrl.match(/^\//)) {
        lwfUrl = ((_ref = settings["prefix"]) != null ? _ref : "") + lwfUrl;
      }
      settings["lwfUrl"] = lwfUrl;
      settings.error = [];
      if (this.cache[lwfUrl] != null) {
        data = this.cache[lwfUrl].data;
        if (data != null) {
          settings["name"] = data.name();
          this.checkTextures(settings, data);
          settings.total = settings._textures.length + 1;
          settings.loadedCount = 1;
          if (settings["onprogress"] != null) {
            settings["onprogress"].call(settings, settings.loadedCount, settings.total);
          }
          this.loadImages(settings, data);
          return;
        }
      }
      this.cache[lwfUrl] = {};
      this.loadLWFData(settings, lwfUrl);
    };

    WebkitCSSResourceCache.prototype.dispatchOnloaddata = function(settings, url, useWorker, useArrayBuffer, useWorkerWithArrayBuffer, data) {
      var e, i, m, re, scripts, src, workerJS, _i, _ref;
      if (useWorker) {
        workerJS = null;
        scripts = document.getElementsByTagName("script");
        re = new RegExp("(^|.*\/" + __FILE__ + ")$", "i");
        for (i = _i = 0, _ref = scripts.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (scripts[i].src === "") {
            continue;
          }
          src = scripts[i].src.split('?')[0];
          m = src.match(re);
          if (m != null) {
            workerJS = m[1];
            break;
          }
        }
        if (workerJS != null) {
          (function(_this) {
            return (function(workerJS) {
              var worker;
              worker = new Worker(workerJS);
              worker.onmessage = function(e) {
                data = new Data(e.data);
                worker = worker.onmessage = worker.onerror = null;
                return _this.onloaddata(settings, data, url);
              };
              worker.onerror = function(e) {
                settings.error.push({
                  url: workerJS,
                  reason: "error"
                });
                worker = worker.onmessage = worker.onerror = null;
                return settings["onload"].call(settings, null);
              };
              if (useWorkerWithArrayBuffer && data.type !== "base64") {
                return worker.webkitPostMessage(data.data);
              } else {
                return worker.postMessage(data.data);
              }
            });
          })(this)(workerJS);
        }
      }
      if (workerJS == null) {
        if (data.type === "base64") {
          try {
            data = global["LWF"].Base64.atobArray(data.data);
            data = global["LWF"].LZMA.decompressFile(data);
          } catch (_error) {
            e = _error;
            data = null;
          }
          data = WebkitCSSLoader.loadArray(data);
        } else if (useArrayBuffer) {
          data = WebkitCSSLoader.loadArrayBuffer(data.data);
        } else {
          data = WebkitCSSLoader.load(data.data);
        }
        this.onloaddata(settings, data, url);
      }
    };

    WebkitCSSResourceCache.prototype.loadLWFData = function(settings, url) {
      var data, head, lwfUrl, m, name, onload, script, str, useArrayBuffer, useWorker, useWorkerWithArrayBuffer, xhr, _base, _ref, _ref1;
      onload = settings["onload"];
      useWorker = false;
      useWorkerWithArrayBuffer = false;
      if (typeof Worker !== 'undefined' && ((settings["worker"] == null) || settings["worker"])) {
        useWorker = true;
        if (typeof Worker.prototype.webkitPostMessage !== "undefined") {
          useWorkerWithArrayBuffer = true;
        }
      }
      m = url.match(/([^\/]+)\.lwf\.js/i);
      if (m != null) {
        name = m[1].toLowerCase();
        str = (_ref = global["LWF"]) != null ? (_ref1 = _ref["DataScript"]) != null ? _ref1[name] : void 0 : void 0;
        if (str != null) {
          data = {
            type: "base64",
            data: str
          };
          this.dispatchOnloaddata(settings, url, useWorker, useArrayBuffer, useWorkerWithArrayBuffer, data);
          return;
        }
        head = document.getElementsByTagName('head')[0];
        script = document.createElement("script");
        script.type = "text/javascript";
        script.charset = "UTF-8";
        script.onabort = (function(_this) {
          return function() {
            settings.error.push({
              url: url,
              reason: "abort"
            });
            head.removeChild(script);
            script = script.onload = script.onabort = script.onerror = null;
            return onload.call(settings, null);
          };
        })(this);
        script.onerror = (function(_this) {
          return function() {
            settings.error.push({
              url: url,
              reason: "error"
            });
            head.removeChild(script);
            script = script.onload = script.onabort = script.onerror = null;
            return onload.call(settings, null);
          };
        })(this);
        script.onload = (function(_this) {
          return function() {
            var _ref2, _ref3;
            str = (_ref2 = global["LWF"]) != null ? (_ref3 = _ref2["DataScript"]) != null ? _ref3[name] : void 0 : void 0;
            head.removeChild(script);
            script = script.onload = script.onabort = script.onerror = null;
            if (str != null) {
              data = {
                type: "base64",
                data: str
              };
              return _this.dispatchOnloaddata(settings, url, useWorker, useArrayBuffer, useWorkerWithArrayBuffer, data);
            } else {
              settings.error.push({
                url: url,
                reason: "error"
              });
              return onload.call(settings, null);
            }
          };
        })(this);
        script.src = url;
        head.appendChild(script);
        lwfUrl = settings["lwfUrl"];
        if ((_base = this.cache[lwfUrl]).scripts == null) {
          _base.scripts = [];
        }
        this.cache[lwfUrl].scripts.push(script);
        return;
      }
      xhr = new XMLHttpRequest;
      xhr.open('GET', url, true);
      if (typeof xhr.responseType === 'string' && typeof Uint8Array !== 'undefined' && typeof Int32Array !== 'undefined' && typeof Float32Array !== 'undefined' && (!useWorker || useWorkerWithArrayBuffer)) {
        useArrayBuffer = true;
        xhr.responseType = "arraybuffer";
      } else {
        useArrayBuffer = false;
        xhr.overrideMimeType('text/plain; charset=x-user-defined');
      }
      xhr.onabort = (function(_this) {
        return function() {
          settings.error.push({
            url: url,
            reason: "abort"
          });
          xhr = xhr.onabort = xhr.onerror = xhr.onreadystatechange = null;
          return onload.call(settings, null);
        };
      })(this);
      xhr.onerror = (function(_this) {
        return function() {
          settings.error.push({
            url: url,
            reason: "error"
          });
          xhr = xhr.onabort = xhr.onerror = xhr.onreadystatechange = null;
          return onload.call(settings, null);
        };
      })(this);
      xhr.onreadystatechange = (function(_this) {
        return function() {
          var mm, protocol, _ref2;
          if (xhr.readyState !== 4) {
            return;
          }
          if (xhr.status === 0) {
            mm = url.match(/^([a-zA-Z][a-zA-Z0-9\+\-\.]*\:)./i);
            if (mm != null) {
              protocol = mm[1];
            } else {
              protocol = typeof global !== "undefined" && global !== null ? (_ref2 = global.location) != null ? _ref2.protocol : void 0 : void 0;
            }
            if (protocol === 'http:' || protocol === 'https:') {
              settings.error.push({
                url: url,
                reason: "networkError"
              });
              xhr = xhr.onabort = xhr.onerror = xhr.onreadystatechange = null;
              onload.call(settings, null);
            }
          } else if (!(xhr.status >= 200 && xhr.status < 300)) {
            settings.error.push({
              url: url,
              reason: "error"
            });
            xhr = xhr.onabort = xhr.onerror = xhr.onreadystatechange = null;
            onload.call(settings, null);
            return;
          }
          if (useArrayBuffer) {
            data = {
              type: "arraybuffer",
              data: xhr.response
            };
          } else {
            data = {
              type: "text",
              data: xhr.responseText
            };
          }
          _this.dispatchOnloaddata(settings, url, useWorker, useArrayBuffer, useWorkerWithArrayBuffer, data);
          return xhr = xhr.onabort = xhr.onerror = xhr.onreadystatechange = null;
        };
      })(this);
      xhr.send(null);
    };

    WebkitCSSResourceCache.prototype.loadJS = function(settings, data) {
      var head, lwfUrl, onload, onprogress, script, url, _base, _ref, _ref1;
      lwfUrl = settings["lwfUrl"];
      url = (_ref = settings["js"]) != null ? _ref : settings["lwf"].replace(/\.lwf(\.js)?/i, ".js");
      if (!url.match(/^\//)) {
        url = ((_ref1 = settings["prefix"]) != null ? _ref1 : "") + url;
      }
      onload = settings["onload"];
      onprogress = settings["onprogress"];
      script = document.createElement("script");
      script.type = "text/javascript";
      script.charset = "UTF-8";
      script.onabort = (function(_this) {
        return function() {
          delete _this.cache[lwfUrl];
          settings.error.push({
            url: url,
            reason: "abort"
          });
          script = script.onload = script.onabort = script.onerror = null;
          return onload.call(settings, null);
        };
      })(this);
      script.onerror = (function(_this) {
        return function() {
          delete _this.cache[lwfUrl];
          settings.error.push({
            url: url,
            reason: "error"
          });
          script = script.onload = script.onabort = script.onerror = null;
          return onload.call(settings, null);
        };
      })(this);
      script.onload = (function(_this) {
        return function() {
          settings.loadedCount++;
          if (onprogress != null) {
            onprogress.call(settings, settings.loadedCount, settings.total);
          }
          script = script.onload = script.onabort = script.onerror = null;
          return _this.loadImages(settings, data);
        };
      })(this);
      script.src = url;
      head = document.getElementsByTagName('head')[0];
      head.appendChild(script);
      if ((_base = this.cache[lwfUrl]).scripts == null) {
        _base.scripts = [];
      }
      this.cache[lwfUrl].scripts.push(script);
    };

    WebkitCSSResourceCache.prototype.loadImagesCallback = function(settings, imageCache, data) {
      settings.loadedCount++;
      if (settings["onprogress"] != null) {
        settings["onprogress"].call(settings, settings.loadedCount, settings.total);
      }
      if (settings.loadedCount === settings.total) {
        delete settings._alphaMap;
        delete settings._colorMap;
        delete settings._textures;
        if (settings.error.length > 0) {
          delete this.cache[settings["lwf"]];
          settings["onload"].call(settings, null);
        } else {
          this.newLWF(settings, imageCache, data);
        }
      }
    };

    WebkitCSSResourceCache.prototype.drawImage = function(ctx, image, o, u, v, w, h) {
      var m;
      if (o.rotated) {
        m = new Matrix();
        Utility.rotateMatrix(m, new Matrix(), 1, 0, w);
        ctx.setTransform(m.scaleX, m.skew1, m.skew0, m.scaleY, m.translateX, m.translateY);
      } else {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
      ctx.drawImage(image, u, v, w, h, 0, 0, w, h);
      ctx.setTransform(1, 0, 0, 1, 0, 0);
    };

    WebkitCSSResourceCache.prototype.getCanvasName = function() {
      return "__canvas__" + ++this.canvasIndex;
    };

    WebkitCSSResourceCache.prototype.createCanvas = function(w, h) {
      var canvas, ctx, name;
      name = this.getCanvasName();
      if (typeof document.getCSSCanvasContext !== 'undefined' && this.constructor === WebkitCSSResourceCache) {
        ctx = document.getCSSCanvasContext("2d", name, w, h);
        canvas = ctx.canvas;
      } else {
        canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;
        ctx = canvas.getContext('2d');
      }
      canvas.name = name;
      return [canvas, ctx];
    };

    WebkitCSSResourceCache.prototype.generateImages = function(settings, imageCache, texture, image) {
      var a, b, canvas, canvasAdd, ctx, ctxAdd, d, g, h, ih, iw, o, r, scaleX, scaleY, u, v, val, w, _i, _len, _ref, _ref1, _ref2;
      d = settings._colorMap[texture.filename];
      if (d != null) {
        scaleX = image.width / texture.width;
        scaleY = image.height / texture.height;
        for (_i = 0, _len = d.length; _i < _len; _i++) {
          o = d[_i];
          u = Math.round(o.u * scaleX);
          v = Math.round(o.v * scaleY);
          w = Math.round(((_ref = o.w) != null ? _ref : texture.width) * scaleX);
          h = Math.round(((_ref1 = o.h) != null ? _ref1 : texture.height) * scaleY);
          if (o.rotated) {
            iw = h;
            ih = w;
          } else {
            iw = w;
            ih = h;
          }
          _ref2 = this.createCanvas(w, h), canvas = _ref2[0], ctx = _ref2[1];
          switch (o.colorOp) {
            case "rgb":
              ctx.fillStyle = "#" + o.colorValue;
              ctx.fillRect(0, 0, w, h);
              ctx.globalCompositeOperation = 'destination-in';
              this.drawImage(ctx, image, o, u, v, iw, ih);
              break;
            case "rgba":
              this.drawImage(ctx, image, o, u, v, iw, ih);
              ctx.globalCompositeOperation = 'source-atop';
              val = o.colorValue;
              r = parseInt(val.substr(0, 2), 16);
              g = parseInt(val.substr(2, 2), 16);
              b = parseInt(val.substr(4, 2), 16);
              a = parseInt(val.substr(6, 2), 16) / 255;
              ctx.fillStyle = "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
              ctx.fillRect(0, 0, w, h);
              break;
            case "add":
              canvasAdd = document.createElement('canvas');
              canvasAdd.width = w;
              canvasAdd.height = h;
              ctxAdd = canvasAdd.getContext('2d');
              ctxAdd.fillStyle = "#" + o.colorValue;
              ctxAdd.fillRect(0, 0, w, h);
              ctxAdd.globalCompositeOperation = 'destination-in';
              this.drawImage(ctxAdd, image, o, u, v, iw, ih);
              this.drawImage(ctx, image, o, u, v, iw, ih);
              ctx.globalCompositeOperation = 'lighter';
              ctx.drawImage(canvasAdd, 0, 0, canvasAdd.width, canvasAdd.height, 0, 0, canvasAdd.width, canvasAdd.height);
          }
          ctx.globalCompositeOperation = 'source-over';
          imageCache[o.filename] = canvas;
        }
      }
    };

    WebkitCSSResourceCache.prototype.loadImages = function(settings, data) {
      var imageCache, texture, url, _fn, _i, _len, _ref;
      imageCache = {};
      if (data.textures.length === 0) {
        this.newLWF(settings, imageCache, data);
        return;
      }
      _ref = settings._textures;
      _fn = (function(_this) {
        return function(texture, url) {
          var image;
          image = new Image();
          image.onabort = function() {
            settings.error.push({
              url: url,
              reason: "abort"
            });
            image = image.onload = image.onabort = image.onerror = null;
            return _this.loadImagesCallback(settings, imageCache, data);
          };
          image.onerror = function() {
            settings.error.push({
              url: url,
              reason: "error"
            });
            image = image.onload = image.onabort = image.onerror = null;
            return _this.loadImagesCallback(settings, imageCache, data);
          };
          image.onload = function() {
            var alpha, alphaImg, canvas, ctx, d, jpg, jpgImg, _ref1;
            imageCache[texture.filename] = image;
            d = settings._alphaMap[texture.filename];
            if (d != null) {
              jpg = d[0];
              alpha = d[1];
              jpgImg = imageCache[jpg.filename];
              alphaImg = imageCache[alpha.filename];
              if ((jpgImg != null) && (alphaImg != null)) {
                _ref1 = _this.createCanvas(jpgImg.width, jpgImg.height), canvas = _ref1[0], ctx = _ref1[1];
                ctx.drawImage(jpgImg, 0, 0, jpgImg.width, jpgImg.height, 0, 0, jpgImg.width, jpgImg.height);
                ctx.globalCompositeOperation = 'destination-in';
                ctx.drawImage(alphaImg, 0, 0, alphaImg.width, alphaImg.height, 0, 0, jpgImg.width, jpgImg.height);
                ctx.globalCompositeOperation = 'source-over';
                delete imageCache[jpg.filename];
                delete imageCache[alpha.filename];
                imageCache[jpg.filename] = canvas;
                _this.generateImages(settings, imageCache, jpg, canvas);
              }
            } else {
              _this.generateImages(settings, imageCache, texture, image);
            }
            image = image.onload = image.onabort = image.onerror = null;
            return _this.loadImagesCallback(settings, imageCache, data);
          };
          return image.src = url;
        };
      })(this);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        texture = _ref[_i];
        url = this.getTextureURL(settings, data, texture);
        _fn(texture, url);
      }
    };

    WebkitCSSResourceCache.prototype.newFactory = function(settings, cache, data) {
      var _ref, _ref1, _ref2, _ref3;
      return new WebkitCSSRendererFactory(data, this, cache, settings["stage"], (_ref = settings["textInSubpixel"]) != null ? _ref : false, (_ref1 = settings["use3D"]) != null ? _ref1 : true, (_ref2 = settings["recycleTextCanvas"]) != null ? _ref2 : true, (_ref3 = settings["quirkyClearRect"]) != null ? _ref3 : false);
    };

    WebkitCSSResourceCache.prototype.onloadLWF = function(settings, lwf) {
      var factory;
      factory = lwf.rendererFactory;
      if (settings["setBackgroundColor"] != null) {
        factory.setBackgroundColor(settings["setBackgroundColor"]);
      } else if (settings["useBackgroundColor"]) {
        factory.setBackgroundColor(lwf);
      }
      if (settings["fitForHeight"]) {
        factory.fitForHeight(lwf);
      } else if (settings["fitForWidth"]) {
        factory.fitForWidth(lwf);
      }
      settings["onload"].call(settings, lwf);
    };

    WebkitCSSResourceCache.prototype.newLWF = function(settings, imageCache, data) {
      var cache, embeddedScript, factory, lwf, lwfUrl, parentLWF, _ref, _ref1;
      lwfUrl = settings["lwfUrl"];
      cache = this.cache[lwfUrl];
      factory = this.newFactory(settings, imageCache, data);
      if (data.useScript) {
        embeddedScript = (_ref = global["LWF"]) != null ? (_ref1 = _ref["Script"]) != null ? _ref1[data.name()] : void 0 : void 0;
      }
      lwf = new LWF(data, factory, embeddedScript, settings["privateData"]);
      if (settings["active"] != null) {
        lwf.active = settings["active"];
      }
      lwf.url = settings["lwfUrl"];
      lwf.lwfInstanceId = ++this.lwfInstanceIndex;
      if (cache.instances == null) {
        cache.instances = {};
      }
      cache.instances[lwf.lwfInstanceId] = lwf;
      parentLWF = settings["parentLWF"];
      if (parentLWF != null) {
        parentLWF.loadedLWFs[lwf.lwfInstanceId] = lwf;
      }
      if (settings["preferredFrameRate"] != null) {
        if (settings["execLimit"] != null) {
          lwf.setPreferredFrameRate(settings["preferredFrameRate"], settings["execLimit"]);
        } else {
          lwf.setPreferredFrameRate(settings["preferredFrameRate"]);
        }
      }
      this.onloadLWF(settings, lwf);
    };

    WebkitCSSResourceCache.prototype.unloadLWF = function(lwf) {
      var cache, e, empty, head, k, script, v, _i, _len, _ref, _ref1;
      cache = this.cache[lwf.url];
      if (cache != null) {
        if (lwf.lwfInstanceId) {
          delete cache.instances[lwf.lwfInstanceId];
        }
        empty = true;
        _ref = cache.instances;
        for (k in _ref) {
          v = _ref[k];
          empty = false;
          break;
        }
        if (empty) {
          try {
            if (cache.scripts != null) {
              head = document.getElementsByTagName('head')[0];
              _ref1 = cache.scripts;
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                script = _ref1[_i];
                head.removeChild(script);
              }
            }
          } catch (_error) {
            e = _error;
          }
          delete this.cache[lwf.url];
        }
      }
    };

    WebkitCSSResourceCache.prototype.loadLWFs = function(settingsArray, onloadall) {
      var errors, loadTotal, loadedCount, onload, settings, _fn, _i, _len, _results;
      loadTotal = settingsArray.length;
      loadedCount = 0;
      errors = null;
      _fn = (function(_this) {
        return function(onload) {
          return settings["onload"] = function(lwf) {
            if (onload != null) {
              onload(lwf);
            }
            if (settings.error.length > 0) {
              if (errors == null) {
                errors = [];
              }
              errors = errors.concat(settings.error);
            }
            ++loadedCount;
            if (loadTotal === loadedCount) {
              return onloadall(errors);
            }
          };
        };
      })(this);
      _results = [];
      for (_i = 0, _len = settingsArray.length; _i < _len; _i++) {
        settings = settingsArray[_i];
        onload = settings["onload"];
        _fn(onload);
        _results.push(this.loadLWF(settings));
      }
      return _results;
    };

    WebkitCSSResourceCache.prototype.getCache = function() {
      return this.cache;
    };

    WebkitCSSResourceCache.prototype.setParticleConstructor = function(ctor) {
      this.particleConstructor = ctor;
    };

    WebkitCSSResourceCache.prototype.setDOMElementConstructor = function(ctor) {
      this.domElementConstructor = ctor;
    };

    return WebkitCSSResourceCache;

  })();

  if (typeof global !== "undefined") {
    global["LWF"]["WebkitCSSRendererFactory"] = WebkitCSSRendererFactory;
    global["LWF"]["WebkitCSSResourceCache"] = WebkitCSSResourceCache;
    global["LWF"]["useWebkitCSSRenderer"] = function() {
      return global["LWF"]["ResourceCache"] = WebkitCSSResourceCache;
    };
    global["LWF"]["LWF"]["useWebkitCSSRenderer"] = global["LWF"]["useWebkitCSSRenderer"];
  }

  WebkitCSSRendererFactory.prototype["convertColor"] = WebkitCSSRendererFactory.prototype.convertColor;

  WebkitCSSRendererFactory.prototype["fitForHeight"] = WebkitCSSRendererFactory.prototype.fitForHeight;

  WebkitCSSRendererFactory.prototype["fitForWidth"] = WebkitCSSRendererFactory.prototype.fitForWidth;

  WebkitCSSRendererFactory.prototype["scaleForHeight"] = WebkitCSSRendererFactory.prototype.scaleForHeight;

  WebkitCSSRendererFactory.prototype["scaleForWidth"] = WebkitCSSRendererFactory.prototype.scaleForWidth;

  WebkitCSSRendererFactory.prototype["setBackgroundColor"] = WebkitCSSRendererFactory.prototype.setBackgroundColor;

  WebkitCSSResourceCache.prototype["clear"] = WebkitCSSResourceCache.prototype.clear;

  WebkitCSSResourceCache.prototype["getCache"] = WebkitCSSResourceCache.prototype.getCache;

  WebkitCSSResourceCache.prototype["getRendererName"] = WebkitCSSResourceCache.prototype.getRendererName;

  WebkitCSSResourceCache.prototype["loadLWF"] = WebkitCSSResourceCache.prototype.loadLWF;

  WebkitCSSResourceCache.prototype["loadLWFs"] = WebkitCSSResourceCache.prototype.loadLWFs;

  WebkitCSSResourceCache.prototype["unloadLWF"] = WebkitCSSResourceCache.prototype.unloadLWF;

  WebkitCSSResourceCache.prototype["setParticleConstructor"] = WebkitCSSResourceCache.prototype.setParticleConstructor;

  WebkitCSSResourceCache.prototype["setDOMElementConstructor"] = WebkitCSSResourceCache.prototype.setDOMElementConstructor;

  if ((typeof window === "undefined" || window === null) && (typeof self !== "undefined" && self !== null)) {
    self.onmessage = function(event) {
      var data, e;
      if (typeof self.webkitPostMessage !== "undefined" && typeof event.data === "object") {
        data = WebkitCSSLoader.loadArrayBuffer(event.data);
        self.webkitPostMessage(data);
      } else {
        data = event.data;
        if (data[0] === 'L' && data[1] === 'W' && data[2] === 'F') {
          data = WebkitCSSLoader.load(data);
        } else {
          try {
            data = global["LWF"].Base64.atobArray(data);
            data = global["LWF"].LZMA.decompressFile(data);
          } catch (_error) {
            e = _error;
            data = null;
          }
          data = WebkitCSSLoader.loadArray(data);
        }
        if (typeof self.webkitPostMessage !== "undefined") {
          self.webkitPostMessage(data);
        } else {
          self.postMessage(data);
        }
      }
      return self.close();
    };
  }

  CanvasRenderCommand = (function() {
    function CanvasRenderCommand() {
      this.renderCount = 0;
      this.renderingIndex = 0;
      this.alpha = 0;
      this.blendMode = 0;
      this.maskMode = 0;
      this.matrix = null;
      this.image = null;
      this.pattern = null;
      this.u = 0;
      this.v = 0;
      this.w = 0;
      this.h = 0;
    }

    return CanvasRenderCommand;

  })();

  CanvasRendererFactory = (function(_super) {
    __extends(CanvasRendererFactory, _super);

    function CanvasRendererFactory(data, resourceCache, cache, stage, textInSubpixel, needsClear, quirkyClearRect) {
      var bitmap, bitmapEx, text, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      this.resourceCache = resourceCache;
      this.cache = cache;
      this.stage = stage;
      this.textInSubpixel = textInSubpixel;
      this.needsClear = needsClear;
      this.quirkyClearRect = quirkyClearRect;
      this.blendMode = "normal";
      this.maskMode = "normal";
      this.stage.style.webkitUserSelect = "none";
      this.stage.style.webkitTransform = "translateZ(0)";
      this.stageContext = this.stage.getContext("2d");
      if (this.stage.width === 0 && this.stage.height === 0) {
        this.stage.width = data.header.width;
        this.stage.height = data.header.height;
      }
      this.bitmapContexts = [];
      _ref = data.bitmaps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bitmap = _ref[_i];
        if (bitmap.textureFragmentId === -1) {
          continue;
        }
        bitmapEx = new Format.BitmapEx();
        bitmapEx.matrixId = bitmap.matrixId;
        bitmapEx.textureFragmentId = bitmap.textureFragmentId;
        bitmapEx.u = 0;
        bitmapEx.v = 0;
        bitmapEx.w = 1;
        bitmapEx.h = 1;
        bitmapEx.attribute = 0;
        this.bitmapContexts.push(new CanvasBitmapContext(this, data, bitmapEx));
      }
      this.bitmapExContexts = [];
      _ref1 = data.bitmapExs;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        bitmapEx = _ref1[_j];
        if (bitmapEx.textureFragmentId === -1) {
          continue;
        }
        this.bitmapExContexts.push(new CanvasBitmapContext(this, data, bitmapEx));
      }
      this.textContexts = [];
      _ref2 = data.texts;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        text = _ref2[_k];
        this.textContexts.push(new CanvasTextContext(this, data, text));
      }
      this.initCommands();
    }

    CanvasRendererFactory.prototype.destruct = function() {
      var context, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      _ref = this.bitmapContexts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        context = _ref[_i];
        context.destruct();
      }
      _ref1 = this.bitmapExContexts;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        context = _ref1[_j];
        context.destruct();
      }
      _ref2 = this.textContexts;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        context = _ref2[_k];
        context.destruct();
      }
    };

    CanvasRendererFactory.prototype.resetGlobalCompositeOperation = function(ctx) {
      ctx.globalCompositeOperation = "source-over";
      this.renderBlendMode = "normal";
    };

    CanvasRendererFactory.prototype.setGlobalCompositeOperation = function(ctx, blendMode) {
      if (this.renderBlendMode !== blendMode) {
        this.renderBlendMode = blendMode;
        switch (this.renderBlendMode) {
          case "add":
            ctx.globalCompositeOperation = "lighter";
            break;
          case "normal":
            ctx.globalCompositeOperation = "source-over";
        }
      }
    };

    CanvasRendererFactory.prototype.renderMask = function(blendMode) {
      var ctx;
      ctx = this.maskCanvas.getContext('2d');
      ctx.globalCompositeOperation = this.maskComposition;
      this.renderBlendMode = null;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.drawImage(this.layerCanvas, 0, 0, this.layerCanvas.width, this.layerCanvas.height, 0, 0, this.layerCanvas.width, this.layerCanvas.height);
      ctx = this.stageContext;
      this.setGlobalCompositeOperation(ctx, blendMode);
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.drawImage(this.maskCanvas, 0, 0, this.maskCanvas.width, this.maskCanvas.height, 0, 0, this.maskCanvas.width, this.maskCanvas.height);
    };

    CanvasRendererFactory.prototype.render = function(ctx, cmd) {
      var cleared, h, m, u, v, w;
      if (this.renderMaskMode !== cmd.maskMode) {
        switch (cmd.maskMode) {
          case "erase":
          case "mask":
          case "alpha":
            if (this.renderMaskMode === "layer" && this.renderMasked) {
              this.renderMask(cmd.blendMode);
            }
            this.renderMasked = true;
            this.maskComposition = cmd.maskMode === "erase" ? "source-out" : "source-in";
            if (this.maskCanvas == null) {
              this.maskCanvas = document.createElement('canvas');
              this.maskCanvas.width = this.stage.width;
              this.maskCanvas.height = this.stage.height;
              cleared = true;
            } else {
              cleared = false;
            }
            ctx = this.maskCanvas.getContext('2d');
            this.resetGlobalCompositeOperation(ctx);
            if (!cleared) {
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              this.clearCanvasRect(this.stage, ctx);
            }
            break;
          case "layer":
            if (this.renderMasked) {
              if (this.layerCanvas == null) {
                this.layerCanvas = document.createElement('canvas');
                this.layerCanvas.width = this.stage.width;
                this.layerCanvas.height = this.stage.height;
                cleared = true;
              } else {
                cleared = false;
              }
              ctx = this.layerCanvas.getContext('2d');
              this.resetGlobalCompositeOperation(ctx);
              if (!cleared) {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.clearCanvasRect(this.stage, ctx);
              }
            } else {
              ctx = this.stageContext;
              this.resetGlobalCompositeOperation(ctx);
            }
            break;
          case "normal":
            ctx = this.stageContext;
            this.resetGlobalCompositeOperation(ctx);
            if (this.renderMaskMode === "layer" && this.renderMasked) {
              this.renderMask(this.renderBlendMode);
            }
        }
        this.renderMaskMode = cmd.maskMode;
      }
      this.setGlobalCompositeOperation(ctx, cmd.blendMode);
      if (cmd.alpha !== 1) {
        ctx.globalAlpha = cmd.alpha;
      }
      m = cmd.matrix;
      ctx.setTransform(m.scaleX, m.skew1, m.skew0, m.scaleY, m.translateX, m.translateY);
      u = cmd.u;
      v = cmd.v;
      w = cmd.w;
      h = cmd.h;
      if ((cmd.pattern != null) && (w > cmd.image.width || h > cmd.image.height)) {
        ctx.translate(-u, -v);
        ctx.rect(u, v, w, h);
        ctx.fillStyle = cmd.pattern;
        ctx.fill();
      } else {
        ctx.drawImage(cmd.image, u, v, w, h, 0, 0, w, h);
      }
      if (cmd.alpha !== 1) {
        ctx.globalAlpha = 1;
      }
      return ctx;
    };

    CanvasRendererFactory.prototype.endRender = function(lwf) {
      var cmd, ctx, rIndex, renderCount, scmd, srIndex, _i, _j, _ref, _ref1;
      ctx = this.stageContext;
      if (lwf.parent != null) {
        this.addCommandToParent(lwf);
        return;
      }
      if (this.needsClear) {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (this.clearColor != null) {
          if (this.clearColor[3] === 'a') {
            this.clearCanvasRect(this.stage, ctx);
          }
          ctx.fillStyle = this.clearColor;
          ctx.fillRect(0, 0, this.stage.width, this.stage.height);
        } else {
          this.clearCanvasRect(this.stage, ctx);
        }
      }
      ctx.globalAlpha = 1;
      this.resetGlobalCompositeOperation(ctx);
      this.renderMaskMode = "normal";
      this.renderMasked = false;
      renderCount = lwf.renderCount;
      for (rIndex = _i = 0, _ref = this.commands.length; 0 <= _ref ? _i < _ref : _i > _ref; rIndex = 0 <= _ref ? ++_i : --_i) {
        cmd = this.commands[rIndex];
        if ((cmd == null) || cmd.renderingIndex !== rIndex || cmd.renderCount !== renderCount) {
          continue;
        }
        if (cmd.subCommands != null) {
          for (srIndex = _j = 0, _ref1 = cmd.subCommands.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; srIndex = 0 <= _ref1 ? ++_j : --_j) {
            scmd = cmd.subCommands[srIndex];
            if ((scmd == null) || scmd.renderingIndex !== srIndex || scmd.renderCount !== renderCount) {
              continue;
            }
            ctx = this.render(ctx, scmd);
          }
        }
        ctx = this.render(ctx, cmd);
      }
      if (this.renderMaskMode === "layer" && this.renderMasked) {
        this.renderMask(this.renderBlendMode);
      }
      this.initCommands();
    };

    CanvasRendererFactory.prototype.setBlendMode = function(blendMode) {
      this.blendMode = blendMode;
    };

    CanvasRendererFactory.prototype.setMaskMode = function(maskMode) {
      this.maskMode = maskMode;
    };

    CanvasRendererFactory.prototype.constructBitmap = function(lwf, objectId, bitmap) {
      var context;
      context = this.bitmapContexts[objectId];
      if (context) {
        return new CanvasBitmapRenderer(context);
      }
    };

    CanvasRendererFactory.prototype.constructBitmapEx = function(lwf, objectId, bitmapEx) {
      var context;
      context = this.bitmapExContexts[objectId];
      if (context) {
        return new CanvasBitmapRenderer(context);
      }
    };

    CanvasRendererFactory.prototype.constructText = function(lwf, objectId, text) {
      var context;
      context = this.textContexts[objectId];
      if (context) {
        return new CanvasTextRenderer(lwf, context, text);
      }
    };

    CanvasRendererFactory.prototype.constructParticle = function(lwf, objectId, particle) {
      var ctor, particleData;
      ctor = this.resourceCache.particleConstructor;
      particleData = lwf.data.particleDatas[particle.particleDataId];
      if (ctor != null) {
        return ctor(lwf, lwf.data.strings[particleData.stringId]);
      }
    };

    CanvasRendererFactory.prototype.getStageSize = function() {
      return [this.stage.width, this.stage.height];
    };

    CanvasRendererFactory.prototype.setBackgroundColor = function(v) {
      var a, b, g, r, _ref;
      _ref = this.parseBackgroundColor(v), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
      this.clearColor = "rgba(" + r + "," + g + "," + b + "," + (a / 255) + ")";
    };

    return CanvasRendererFactory;

  })(WebkitCSSRendererFactory);

  CanvasBitmapContext = (function() {
    function CanvasBitmapContext(factory, data, bitmapEx) {
      var bh, bu, bv, bw, h, imageScale, imageWidth, repeat, texture, u, v, w, withPadding, x, y;
      this.factory = factory;
      this.data = data;
      this.fragment = this.data.textureFragments[bitmapEx.textureFragmentId];
      texture = this.data.textures[this.fragment.textureId];
      this.image = this.factory.cache[texture.filename];
      imageWidth = this.image.width;
      withPadding = texture.filename.match(/_withpadding/) ? true : false;
      if (withPadding) {
        imageWidth -= 2;
      }
      imageScale = imageWidth / texture.width;
      this.scale = 1 / (texture.scale * imageScale);
      repeat = null;
      if ((bitmapEx.attribute & Format.BitmapEx.Attribute.REPEAT_S) !== 0) {
        repeat = "repeat-x";
      }
      if ((bitmapEx.attribute & Format.BitmapEx.Attribute.REPEAT_T) !== 0) {
        repeat = repeat != null ? "repeat" : "repeat-y";
      }
      this.pattern = repeat != null ? this.factory.stageContext.createPattern(this.image, repeat) : null;
      x = this.fragment.x;
      y = this.fragment.y;
      u = this.fragment.u;
      v = this.fragment.v;
      w = this.fragment.w;
      h = this.fragment.h;
      if (withPadding) {
        x -= 1;
        y -= 1;
        w += 2;
        h += 2;
      }
      bu = bitmapEx.u * w;
      bv = bitmapEx.v * h;
      bw = bitmapEx.w;
      bh = bitmapEx.h;
      x += bu;
      y += bv;
      u += bu;
      v += bv;
      w *= bw;
      h *= bh;
      this.x = Math.round(x * imageScale);
      this.y = Math.round(y * imageScale);
      this.u = Math.round(u * imageScale);
      this.v = Math.round(v * imageScale);
      if (this.fragment.rotated) {
        this.w = Math.round(h * imageScale);
        this.h = Math.round(w * imageScale);
      } else {
        this.w = Math.round(w * imageScale);
        this.h = Math.round(h * imageScale);
      }
      if (this.u + this.w > this.image.width) {
        this.w = this.image.width - this.u;
      }
      if (this.v + this.h > this.image.height) {
        this.h = this.image.height - this.v;
      }
      this.imageHeight = h * imageScale;
    }

    CanvasBitmapContext.prototype.destruct = function() {};

    return CanvasBitmapContext;

  })();

  CanvasBitmapRenderer = (function() {
    function CanvasBitmapRenderer(context) {
      var fragment;
      this.context = context;
      fragment = this.context.fragment;
      this.matrix = new Matrix(0, 0, 0, 0, 0, 0);
      if (fragment.rotated || this.context.x !== 0 || this.context.y !== 0 || this.context.scale !== 1) {
        this.matrixForAtlas = new Matrix();
      }
      this.cmd = new CanvasRenderCommand();
    }

    CanvasBitmapRenderer.prototype.destruct = function() {};

    CanvasBitmapRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var cmd, f, fragment, scale, x, y;
      if (!visible || c.multi.alpha === 0) {
        return;
      }
      if (this.matrix.setWithComparing(m)) {
        m = this.matrix;
        fragment = this.context.fragment;
        x = this.context.x;
        y = this.context.y;
        scale = this.context.scale;
        if (fragment.rotated) {
          m = Utility.rotateMatrix(this.matrixForAtlas, m, scale, x, y + this.context.imageHeight);
        } else if (scale !== 1 || x !== 0 || y !== 0) {
          m = Utility.scaleMatrix(this.matrixForAtlas, m, scale, x, y);
        }
      } else {
        if (this.matrixForAtlas != null) {
          m = this.matrixForAtlas;
        }
      }
      this.alpha = c.multi.alpha;
      f = this.context.factory.lwf.getRendererFactory();
      fragment = this.context.fragment;
      cmd = this.cmd;
      cmd.alpha = this.alpha;
      cmd.blendMode = f.blendMode;
      cmd.maskMode = f.maskMode;
      cmd.matrix = m;
      cmd.image = this.context.image;
      cmd.pattern = this.context.pattern;
      cmd.u = this.context.u;
      cmd.v = this.context.v;
      cmd.w = this.context.w;
      cmd.h = this.context.h;
      this.context.factory.addCommand(renderingIndex, cmd);
    };

    return CanvasBitmapRenderer;

  })();

  CanvasTextContext = (function(_super) {
    __extends(CanvasTextContext, _super);

    function CanvasTextContext() {
      return CanvasTextContext.__super__.constructor.apply(this, arguments);
    }

    return CanvasTextContext;

  })(HTML5TextContext);

  CanvasTextRenderer = (function(_super) {
    __extends(CanvasTextRenderer, _super);

    function CanvasTextRenderer() {
      CanvasTextRenderer.__super__.constructor.apply(this, arguments);
      this.cmd = new CanvasRenderCommand();
    }

    CanvasTextRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var cmd, f;
      if (!visible || c.multi.alpha === 0) {
        return;
      }
      CanvasTextRenderer.__super__.render.call(this, m, c, renderingIndex, renderingCount, visible);
      f = this.context.factory.lwf.getRendererFactory();
      cmd = this.cmd;
      cmd.alpha = c.multi.alpha;
      cmd.blendMode = f.blendMode;
      cmd.maskMode = f.maskMode;
      cmd.matrix = this.matrix;
      cmd.image = this.canvas;
      cmd.pattern = null;
      cmd.u = 0;
      cmd.v = 0;
      cmd.w = this.canvas.width;
      cmd.h = this.canvas.height;
      this.context.factory.addCommand(renderingIndex, cmd);
    };

    return CanvasTextRenderer;

  })(HTML5TextRenderer);

  CanvasResourceCache = (function(_super) {
    __extends(CanvasResourceCache, _super);

    function CanvasResourceCache() {
      return CanvasResourceCache.__super__.constructor.apply(this, arguments);
    }

    CanvasResourceCache.prototype.getRendererName = function() {
      return "Canvas";
    };

    CanvasResourceCache.prototype.newFactory = function(settings, cache, data) {
      var _ref, _ref1, _ref2;
      return new CanvasRendererFactory(data, this, cache, settings.stage, (_ref = settings["textInSubpixel"]) != null ? _ref : false, (_ref1 = settings["needsClear"]) != null ? _ref1 : true, (_ref2 = settings["quirkyClearRect"]) != null ? _ref2 : false);
    };

    CanvasResourceCache.prototype.generateImages = function(settings, imageCache, texture, image) {
      var canvas, ctx, h, m, w;
      m = texture.filename.match(/_withpadding/);
      if (m != null) {
        w = image.width + 2;
        h = image.height + 2;
        canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;
        canvas.name = this.getCanvasName();
        ctx = canvas.getContext('2d');
        canvas.withPadding = true;
        ctx.drawImage(image, 0, 0, image.width, image.height, 1, 1, image.width, image.height);
        imageCache[texture.filename] = canvas;
      }
      CanvasResourceCache.__super__.generateImages.call(this, settings, imageCache, texture, image);
    };

    return CanvasResourceCache;

  })(WebkitCSSResourceCache);

  if (typeof global !== "undefined") {
    global["LWF"]["CanvasRendererFactory"] = CanvasRendererFactory;
    global["LWF"]["CanvasResourceCache"] = CanvasResourceCache;
    global["LWF"]["useCanvasRenderer"] = function() {
      return global["LWF"]["ResourceCache"] = CanvasResourceCache;
    };
    global["LWF"]["LWF"]["useCanvasRenderer"] = global["LWF"]["useCanvasRenderer"];
  }

  CanvasRendererFactory.prototype["convertColor"] = CanvasRendererFactory.prototype.convertColor;

  CanvasRendererFactory.prototype["fitForHeight"] = CanvasRendererFactory.prototype.fitForHeight;

  CanvasRendererFactory.prototype["fitForWidth"] = CanvasRendererFactory.prototype.fitForWidth;

  CanvasRendererFactory.prototype["scaleForHeight"] = CanvasRendererFactory.prototype.scaleForHeight;

  CanvasRendererFactory.prototype["scaleForWidth"] = CanvasRendererFactory.prototype.scaleForWidth;

  CanvasRendererFactory.prototype["setBackgroundColor"] = CanvasRendererFactory.prototype.setBackgroundColor;

  CanvasResourceCache.prototype["clear"] = CanvasResourceCache.prototype.clear;

  CanvasResourceCache.prototype["getCache"] = CanvasResourceCache.prototype.getCache;

  CanvasResourceCache.prototype["getRendererName"] = CanvasResourceCache.prototype.getRendererName;

  CanvasResourceCache.prototype["loadLWF"] = CanvasResourceCache.prototype.loadLWF;

  CanvasResourceCache.prototype["loadLWFs"] = CanvasResourceCache.prototype.loadLWFs;

  CanvasResourceCache.prototype["unloadLWF"] = CanvasResourceCache.prototype.unloadLWF;

  CanvasResourceCache.prototype["setParticleConstructor"] = CanvasResourceCache.prototype.setParticleConstructor;

  CanvasResourceCache.prototype["setDOMElementConstructor"] = CanvasResourceCache.prototype.setDOMElementConstructor;

  SHADERS = {
    "simple": {
      "attributes": 5,
      "aTextureCoordSize": 3,
      "vertex": "\nattribute vec2 aVertexPosition;\nattribute vec3 aTextureCoord;\nuniform mat4 uPMatrix;\nuniform mat4 uMatrix;\nvarying vec3 vTextureCoord;\nvoid main() {\n  gl_Position = uPMatrix * uMatrix * vec4(aVertexPosition, 0, 1);\n  vTextureCoord = aTextureCoord;\n}\n",
      "fragment": "\nprecision mediump float;\nvarying vec3 vTextureCoord;\nuniform sampler2D uTexture;\nvoid main() {\n  gl_FragColor = vec4(1, 1, 1, vTextureCoord.z) *\n    texture2D(uTexture, vTextureCoord.xy);\n}\n"
    },
    "vertexColor": {
      "attributes": 8,
      "aTextureCoordSize": 2,
      "vertex": "\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nuniform mat4 uPMatrix;\nuniform mat4 uMatrix;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvoid main() {\n  gl_Position = uPMatrix * uMatrix * vec4(aVertexPosition, 0, 1);\n  vTextureCoord = aTextureCoord;\n  vColor = aColor;\n}\n",
      "fragment": "\nprecision mediump float;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nuniform sampler2D uTexture;\nvoid main() {\n  gl_FragColor = vColor * texture2D(uTexture, vTextureCoord);\n}\n"
    },
    "additionalColor": {
      "attributes": 12,
      "aTextureCoordSize": 2,
      "vertex": "\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute vec4 aAdditionalColor;\nuniform mat4 uPMatrix;\nuniform mat4 uMatrix;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec4 vAdditionalColor;\nvoid main() {\n  gl_Position = uPMatrix * uMatrix * vec4(aVertexPosition, 0, 1);\n  vTextureCoord = aTextureCoord;\n  vColor = aColor;\n  vAdditionalColor = aAdditionalColor;\n}\n",
      "fragment": "\nprecision mediump float;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec4 vAdditionalColor;\nuniform sampler2D uTexture;\nvoid main() {\n  gl_FragColor = vColor *\n    texture2D(uTexture, vTextureCoord) + vAdditionalColor;\n}\n"
    }
  };

  WebGLRenderCommand = (function() {
    function WebGLRenderCommand(context, texture, matrix) {
      this.renderCount = 0;
      this.renderingIndex = 0;
      this.context = context;
      this.texture = texture;
      this.matrix = matrix;
      this.colorTransform = null;
      this.blendMode = 0;
      this.maskMode = 0;
    }

    return WebGLRenderCommand;

  })();

  WebGLRendererContext = (function() {
    function WebGLRendererContext() {
      this.refCount = 1;
      this.glContext = null;
      this.textures = {};
      this.vertexBuffer = null;
      this.indexBuffer = null;
      this.shaders = null;
    }

    return WebGLRendererContext;

  })();

  WebGLShader = (function() {
    function WebGLShader(gl, name, data) {
      var fragmentShader, vertexShader;
      this.name = name;
      this.attributes = data["attributes"];
      this.aTextureCoordSize = data["aTextureCoordSize"];
      vertexShader = this.loadShader(gl, gl.VERTEX_SHADER, data["vertex"]);
      fragmentShader = this.loadShader(gl, gl.FRAGMENT_SHADER, data["fragment"]);
      this.shaderProgram = gl.createProgram();
      gl.attachShader(this.shaderProgram, vertexShader);
      gl.attachShader(this.shaderProgram, fragmentShader);
      gl.linkProgram(this.shaderProgram);
      if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {
        alert("Unable to initialize the shader program.");
      }
      gl.useProgram(this.shaderProgram);
      this.aVertexPosition = gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
      this.aTextureCoord = gl.getAttribLocation(this.shaderProgram, "aTextureCoord");
      this.uPMatrix = gl.getUniformLocation(this.shaderProgram, "uPMatrix");
      this.uMatrix = gl.getUniformLocation(this.shaderProgram, "uMatrix");
      this.uTexture = gl.getUniformLocation(this.shaderProgram, "uTexture");
      switch (this.name) {
        case "vertexColor":
          this.aColor = gl.getAttribLocation(this.shaderProgram, "aColor");
          this.aAdditionalColor = null;
          this.isVertexColor = true;
          this.isAdditionalColor = false;
          break;
        case "additionalColor":
          this.aColor = gl.getAttribLocation(this.shaderProgram, "aColor");
          this.aAdditionalColor = gl.getAttribLocation(this.shaderProgram, "aAdditionalColor");
          this.isVertexColor = false;
          this.isAdditionalColor = true;
          break;
        default:
          this.aColor = null;
          this.aAdditionalColor = null;
          this.isVertexColor = false;
          this.isAdditionalColor = false;
      }
    }

    WebGLShader.prototype.loadShader = function(gl, type, program) {
      var shader;
      shader = gl.createShader(type);
      gl.shaderSource(shader, program);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
      }
      return shader;
    };

    WebGLShader.prototype.use = function(gl, pMatrix) {
      var vertexBufferSize;
      gl.useProgram(this.shaderProgram);
      this.setMatrix(gl, pMatrix);
      vertexBufferSize = 4 * this.attributes;
      gl.vertexAttribPointer(this.aVertexPosition, 2, gl.FLOAT, false, vertexBufferSize, 0);
      gl.enableVertexAttribArray(this.aVertexPosition);
      gl.vertexAttribPointer(this.aTextureCoord, this.aTextureCoordSize, gl.FLOAT, false, vertexBufferSize, 8);
      gl.enableVertexAttribArray(this.aTextureCoord);
      if (this.isVertexColor) {
        gl.vertexAttribPointer(this.aColor, 4, gl.FLOAT, false, vertexBufferSize, 16);
        gl.enableVertexAttribArray(this.aColor);
      } else if (this.isAdditionalColor) {
        gl.vertexAttribPointer(this.aColor, 4, gl.FLOAT, false, vertexBufferSize, 16);
        gl.enableVertexAttribArray(this.aColor);
        gl.vertexAttribPointer(this.aAdditionalColor, 4, gl.FLOAT, false, vertexBufferSize, 32);
        gl.enableVertexAttribArray(this.aAdditionalColor);
      }
      return this;
    };

    WebGLShader.prototype.setMatrix = function(gl, pMatrix) {
      gl.uniformMatrix4fv(this.uPMatrix, false, pMatrix);
    };

    WebGLShader.prototype.disable = function(gl) {
      gl.disableVertexAttribArray(this.aVertexPosition);
      gl.disableVertexAttribArray(this.aTextureCoord);
      if (this.isVertexColor) {
        gl.disableVertexAttribArray(this.aColor);
      } else if (this.isAdditionalColor) {
        gl.disableVertexAttribArray(this.aColor);
        gl.disableVertexAttribArray(this.aAdditionalColor);
      }
    };

    return WebGLShader;

  })();

  WebGLRendererFactory = (function(_super) {
    __extends(WebGLRendererFactory, _super);

    WebGLRendererFactory.rendererContexts = {};

    WebGLRendererFactory.prototype.initGL = function() {
      var gl, k, params, rendererContext, v, _ref;
      rendererContext = WebGLRendererFactory.rendererContexts[this.stage.id];
      if (rendererContext != null) {
        ++rendererContext.refCount;
        this.glContext = rendererContext.glContext;
        this.textures = rendererContext.textures;
        this.vertexBuffer = rendererContext.vertexBuffer;
        this.indexBuffer = rendererContext.indexBuffer;
        this.shaders = rendererContext.shaders;
        return;
      }
      rendererContext = new WebGLRendererContext();
      this.textures = rendererContext.textures;
      WebGLRendererFactory.rendererContexts[this.stage.id] = rendererContext;
      this.stage.style.webkitUserSelect = "none";
      if (this.stage.width === 0 && this.stage.height === 0) {
        this.stage.width = this.data.header.width;
        this.stage.height = this.data.header.height;
      }
      params = {
        alpha: false,
        antialias: false,
        depth: false,
        premultipliedAlpha: true,
        preserveDrawingBuffer: false
      };
      this.glContext = (_ref = this.stage.getContext("webgl", params)) != null ? _ref : this.stage.getContext("experimental-webgl", params);
      rendererContext.glContext = this.glContext;
      gl = this.glContext;
      this.vertexBuffer = gl.createBuffer();
      this.indexBuffer = gl.createBuffer();
      rendererContext.vertexBuffer = this.vertexBuffer;
      rendererContext.indexBuffer = this.indexBuffer;
      this.bindVertexBuffer(gl, this.vertexBuffer);
      this.bindIndexBuffer(gl, this.indexBuffer);
      this.shaders = {};
      rendererContext.shaders = this.shaders;
      this.currentShader = null;
      for (k in SHADERS) {
        v = SHADERS[k];
        this.shaders[k] = new WebGLShader(gl, k, v);
      }
      gl.enable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.DITHER);
      gl.disable(gl.SCISSOR_TEST);
      gl.activeTexture(gl.TEXTURE0);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
    };

    WebGLRendererFactory.prototype.destructGL = function() {
      var d, gl, k, rendererContext, _ref;
      rendererContext = WebGLRendererFactory.rendererContexts[this.stage.id];
      if (--rendererContext.refCount > 0) {
        return;
      }
      gl = this.glContext;
      gl.deleteBuffer(this.indexBuffer);
      gl.deleteBuffer(this.vertexBuffer);
      _ref = this.textures;
      for (k in _ref) {
        d = _ref[k];
        gl.deleteTexture(d[0]);
      }
      delete WebGLRendererFactory.rendererContexts[this.stage.id];
    };

    WebGLRendererFactory.prototype.setTexParameter = function(gl, repeatS, repeatT) {
      if (repeatS == null) {
        repeatS = false;
      }
      if (repeatT == null) {
        repeatT = false;
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, repeatS ? gl.REPEAT : gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, repeatT ? gl.REPEAT : gl.CLAMP_TO_EDGE);
    };

    WebGLRendererFactory.prototype.setViewport = function(gl, lwf) {
      var bottom, far, left, near, right, top;
      this.viewportChanged = this.propertyMatrix.setWithComparing(lwf.property.matrix);
      if ((this.pMatrix == null) || this.viewportChanged || this.w !== this.stage.width || this.h !== this.stage.height) {
        this.w = this.stage.width;
        this.h = this.stage.height;
        gl.viewport(0, 0, this.w, this.h);
        right = this.w;
        left = 0;
        top = 0;
        bottom = this.h;
        far = 1;
        near = -1;
        this.pMatrix = new Float32Array([2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, -2 / (far - near), 0, -(right + left) / (right - left), -(top + bottom) / (top - bottom), -(far + near) / (far - near), 1]);
      }
    };

    function WebGLRendererFactory(data, resourceCache, cache, stage, textInSubpixel, needsClear, useVertexColor, useAlwaysAdditionalColorShader) {
      var bitmap, bitmapEx, text, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      this.data = data;
      this.resourceCache = resourceCache;
      this.cache = cache;
      this.stage = stage;
      this.textInSubpixel = textInSubpixel;
      this.needsClear = needsClear;
      this.useVertexColor = useVertexColor;
      this.useAlwaysAdditionalColorShader = useAlwaysAdditionalColorShader;
      this.maxAttributes = this.useVertexColor ? 12 : 5;
      this.initGL();
      this.drawCalls = 0;
      this.blendMode = "normal";
      this.maskMode = "normal";
      this.matrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      this.propertyMatrix = new Matrix;
      this.vertexData = new Float32Array(1);
      this.indexData = new Uint16Array(1);
      if (this.useVertexColor) {
        this.color = new Float32Array(8);
      }
      this.backGroundColor = [0, 0, 0, 1];
      this.bitmapContexts = [];
      _ref = data.bitmaps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bitmap = _ref[_i];
        if (bitmap.textureFragmentId === -1) {
          continue;
        }
        bitmapEx = new Format.BitmapEx();
        bitmapEx.matrixId = bitmap.matrixId;
        bitmapEx.textureFragmentId = bitmap.textureFragmentId;
        bitmapEx.u = 0;
        bitmapEx.v = 0;
        bitmapEx.w = 1;
        bitmapEx.h = 1;
        bitmapEx.attribute = 0;
        this.bitmapContexts.push(new WebGLBitmapContext(this, data, bitmapEx));
      }
      this.bitmapExContexts = [];
      _ref1 = data.bitmapExs;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        bitmapEx = _ref1[_j];
        if (bitmapEx.textureFragmentId === -1) {
          continue;
        }
        this.bitmapExContexts.push(new WebGLBitmapContext(this, data, bitmapEx));
      }
      this.textContexts = [];
      _ref2 = data.texts;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        text = _ref2[_k];
        this.textContexts.push(new WebGLTextContext(this, data, text));
      }
      this.initCommands();
    }

    WebGLRendererFactory.prototype.destruct = function() {
      var context, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      this.bindedTexture = null;
      this.currentTexture = null;
      this.deleteMask(this.glContext);
      this.destructGL();
      _ref = this.bitmapContexts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        context = _ref[_i];
        context.destruct();
      }
      _ref1 = this.bitmapExContexts;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        context = _ref1[_j];
        context.destruct();
      }
      _ref2 = this.textContexts;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        context = _ref2[_k];
        context.destruct();
      }
    };

    WebGLRendererFactory.prototype.init = function(lwf) {
      lwf.useVertexColor = this.useVertexColor;
      WebGLRendererFactory.__super__.init.call(this, lwf);
    };

    WebGLRendererFactory.prototype.beginRender = function(lwf) {
      WebGLRendererFactory.__super__.beginRender.call(this, lwf);
      this.lwf = lwf;
      if (lwf.parent != null) {
        return;
      }
      this.faces = 0;
    };

    WebGLRendererFactory.prototype.bindTexture = function(gl, texture) {
      if (this.bindedTexture !== texture) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        this.bindedTexture = texture;
      }
    };

    WebGLRendererFactory.prototype.blendFunc = function(gl, blendSrcFactor, blendDstFactor, blendEquation) {
      if (this.setSrcFactor !== blendSrcFactor || this.setDstFactor !== blendDstFactor) {
        this.setSrcFactor = blendSrcFactor;
        this.setDstFactor = blendDstFactor;
        gl.blendFunc(blendSrcFactor, blendDstFactor);
      }
      if (this.setEquation !== blendEquation) {
        this.setEquation = blendEquation;
        gl.blendEquationSeparate(blendEquation, gl.FUNC_ADD);
      }
    };

    WebGLRendererFactory.prototype.bindVertexBuffer = function(gl, buffer) {
      if (this.bindedVertexBuffer !== buffer) {
        this.bindedVertexBuffer = buffer;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      }
    };

    WebGLRendererFactory.prototype.bindIndexBuffer = function(gl, buffer) {
      if (this.bindedIndexBuffer !== buffer) {
        this.bindedIndexBuffer = buffer;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
      }
    };

    WebGLRendererFactory.prototype.setClearColor = function(gl) {
      var a, b, g, r, _ref;
      _ref = this.backGroundColor, r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
      gl.clearColor(r / 255, g / 255, b / 255, a / 255);
    };

    WebGLRendererFactory.prototype.addCommand = function(rIndex, cmd) {
      WebGLRendererFactory.__super__.addCommand.call(this, rIndex, cmd);
      if (this.lwf.parent != null) {
        return;
      }
      ++this.faces;
    };

    WebGLRendererFactory.prototype.endRender = function(lwf) {
      var cmd, gl, i, indexOffset, indices, offset, rIndex, renderCount, scmd, srIndex, vertices, _i, _j, _k, _ref, _ref1, _ref2;
      if (lwf.parent != null) {
        this.addCommandToParent(lwf);
        return;
      }
      this.currentTexture = null;
      this.bindedTexture = null;
      this.setSrcFactor = null;
      this.setDstFactor = null;
      this.setEquation = null;
      this.bindedVertexBuffer = null;
      this.bindedIndexBuffer = null;
      this.currentBlendMode = "normal";
      gl = this.glContext;
      this.setViewport(gl, lwf);
      if (this.needsClear) {
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
      vertices = this.faces * 4 * this.maxAttributes;
      this.faces = 0;
      this.drawCalls = 0;
      if (vertices > this.vertexData.length) {
        vertices *= 3;
        if (vertices > 65536 * this.maxAttributes) {
          vertices = 65536 * this.maxAttributes;
        }
        indices = vertices / (4 * this.maxAttributes) * 6;
        if (vertices !== this.vertexData.length) {
          this.vertexData = new Float32Array(vertices);
          this.indexData = new Uint16Array(indices);
          offset = 0;
          indexOffset = 0;
          for (i = _i = 0, _ref = indices / 6; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            this.indexData[offset + 0] = indexOffset + 0;
            this.indexData[offset + 1] = indexOffset + 1;
            this.indexData[offset + 2] = indexOffset + 2;
            this.indexData[offset + 3] = indexOffset + 2;
            this.indexData[offset + 4] = indexOffset + 1;
            this.indexData[offset + 5] = indexOffset + 3;
            offset += 6;
            indexOffset += 4;
          }
          this.bindIndexBuffer(gl, this.indexBuffer);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexData, gl.STATIC_DRAW);
        }
      }
      this.renderMaskMode = "normal";
      this.renderMasked = false;
      renderCount = lwf.renderCount;
      for (rIndex = _j = 0, _ref1 = this.commands.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; rIndex = 0 <= _ref1 ? ++_j : --_j) {
        cmd = this.commands[rIndex];
        if ((cmd == null) || cmd.renderingIndex !== rIndex || cmd.renderCount !== renderCount) {
          continue;
        }
        if (cmd.subCommands != null) {
          for (srIndex = _k = 0, _ref2 = cmd.subCommands.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; srIndex = 0 <= _ref2 ? ++_k : --_k) {
            scmd = cmd.subCommands[srIndex];
            if ((scmd == null) || scmd.renderingIndex !== srIndex || scmd.renderCount !== renderCount) {
              continue;
            }
            this.render(gl, scmd);
          }
        }
        this.render(gl, cmd);
      }
      this.renderMesh(gl);
      if (this.renderMaskMode !== "normal") {
        if (this.renderMaskMode === "layer" && this.renderMasked) {
          this.renderMask(gl);
        } else {
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
      }
      this.initCommands();
    };

    WebGLRendererFactory.prototype.render = function(gl, cmd) {
      var alpha, blendMode, c, cc, context, i, m, mm0, mm1, mm2, mm3, mm4, mm5, offset, shader, texture, uv, uvx, uvy, v, vertexData, voffset, vx, vy, x, y, _i;
      if (this.renderMaskMode !== cmd.maskMode) {
        this.renderMesh(gl);
        this.generateMask(gl);
        switch (cmd.maskMode) {
          case "erase":
          case "mask":
          case "alpha":
            if (this.renderMaskMode === "layer" && this.renderMasked) {
              this.renderMask(gl);
            }
            this.renderMasked = true;
            this.maskSrcFactor = cmd.maskMode === "erase" ? gl.ONE_MINUS_DST_ALPHA : gl.DST_ALPHA;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.maskFrameBuffer);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            this.setClearColor(gl);
            break;
          case "layer":
            if (this.renderMasked) {
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.layerFrameBuffer);
              gl.clearColor(0, 0, 0, 0);
              gl.clear(gl.COLOR_BUFFER_BIT);
              this.setClearColor(gl);
            } else {
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            break;
          default:
            if (this.renderMaskMode === "layer" && this.renderMasked) {
              this.renderMask(gl);
            } else {
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
        }
        this.renderMaskMode = cmd.maskMode;
      }
      context = cmd.context;
      texture = cmd.texture;
      m = cmd.matrix;
      c = cmd.colorTransform;
      blendMode = cmd.blendMode;
      if (this.useVertexColor) {
        if (this.useAlwaysAdditionalColorShader || c.hasAdd()) {
          shader = this.shaders["additionalColor"];
        } else {
          shader = this.shaders["vertexColor"];
        }
      } else {
        shader = this.shaders["simple"];
      }
      if (texture !== this.currentTexture || shader !== this.currentShader || blendMode !== this.currentBlendMode || this.faces * 4 * this.maxAttributes >= this.vertexData.length) {
        this.renderMesh(gl);
        this.currentTexture = texture;
        this.currentBlendMode = blendMode;
        switch (blendMode) {
          case "add":
            this.blendSrcFactor = context.preMultipliedAlpha ? gl.ONE : gl.SRC_ALPHA;
            this.blendDstFactor = gl.ONE;
            this.blendEquation = gl.FUNC_ADD;
            break;
          case "multiply":
            this.blendSrcFactor = gl.DST_COLOR;
            this.blendDstFactor = gl.ONE_MINUS_SRC_ALPHA;
            this.blendEquation = gl.FUNC_ADD;
            break;
          case "screen":
            this.blendSrcFactor = gl.ONE_MINUS_DST_COLOR;
            this.blendDstFactor = gl.ONE;
            this.blendEquation = gl.FUNC_ADD;
            break;
          case "subtract":
            this.blendSrcFactor = context.preMultipliedAlpha ? gl.ONE : gl.SRC_ALPHA;
            this.blendDstFactor = gl.ONE;
            this.blendEquation = gl.FUNC_REVERSE_SUBTRACT;
            break;
          default:
            this.blendSrcFactor = context.preMultipliedAlpha ? gl.ONE : gl.SRC_ALPHA;
            this.blendDstFactor = gl.ONE_MINUS_SRC_ALPHA;
            this.blendEquation = gl.FUNC_ADD;
        }
        if (shader !== this.currentShader) {
          if (this.currentShader != null) {
            this.currentShader.disable(gl);
          }
          this.currentShader = shader.use(gl, this.pMatrix);
        } else if (this.viewportChanged) {
          this.currentShader.setMatrix(gl, this.pMatrix);
        }
      }

      /*
      alpha = c.multi.alpha
      if @useVertexColor
        red = c.multi.red
        green = c.multi.green
        blue = c.multi.blue
        addRed = c.add.red
        addGreen = c.add.green
        addBlue = c.add.blue
        addAlpha = c.add.alpha
        if context.preMultipliedAlpha
          red *= alpha
          green *= alpha
          blue *= alpha
      else
        red = 1
        green = 1
        blue = 1
       */
      if (this.useVertexColor) {
        cc = this.color;
        cc[0] = c.multi._[0];
        cc[1] = c.multi._[1];
        cc[2] = c.multi._[2];
        cc[3] = c.multi._[3];
        if (context.preMultipliedAlpha) {
          cc[0] *= cc[3];
          cc[1] *= cc[3];
          cc[2] *= cc[3];
        }
        if (this.currentShader.isAdditionalColor) {
          cc[4] = c.add._[0];
          cc[5] = c.add._[1];
          cc[6] = c.add._[2];
          cc[7] = c.add._[3];
        }
      } else {
        alpha = c.multi._[3];
      }

      /*
      scaleX = m.scaleX
      skew0 = m.skew0
      translateX = m.translateX
      
      skew1 = m.skew1
      scaleY = m.scaleY
      translateY = m.translateY
      
      translateZ = 0
       */
      v = context.vertexData;
      uv = context.uv;
      mm0 = m._[0];
      mm1 = m._[1];
      mm2 = m._[2];
      mm3 = m._[3];
      mm4 = m._[4];
      mm5 = m._[5];
      voffset = this.faces++ * 4 * this.currentShader.attributes;
      vertexData = this.vertexData;
      for (i = _i = 0; _i < 4; i = ++_i) {

        /*
        x = vertexData[i].x
        y = vertexData[i].y
        px = x * scaleX + y * skew0 + translateX
        py = x * skew1 + y * scaleY + translateY
        pz = translateZ
         */
        x = i * 2 + 0;
        y = i * 2 + 1;
        vx = v[x];
        vy = v[y];
        uvx = uv[x];
        uvy = uv[y];
        offset = voffset + i * this.currentShader.attributes;
        if (this.useVertexColor) {
          vertexData[offset + 0] = vx * mm0 + vy * mm2 + mm4;
          vertexData[offset + 1] = vx * mm1 + vy * mm3 + mm5;
          vertexData[offset + 2] = uvx;
          vertexData[offset + 3] = uvy;
          vertexData[offset + 4] = cc[0];
          vertexData[offset + 5] = cc[1];
          vertexData[offset + 6] = cc[2];
          vertexData[offset + 7] = cc[3];
          if (this.currentShader.isAdditionalColor) {
            vertexData[offset + 8] = cc[4];
            vertexData[offset + 9] = cc[5];
            vertexData[offset + 10] = cc[6];
            vertexData[offset + 11] = cc[7];
          }
        } else {
          vertexData[offset + 0] = vx * mm0 + vy * mm2 + mm4;
          vertexData[offset + 1] = vx * mm1 + vy * mm3 + mm5;
          vertexData[offset + 2] = uvx;
          vertexData[offset + 3] = uvy;
          vertexData[offset + 4] = alpha;
        }
      }
    };

    WebGLRendererFactory.prototype.renderMesh = function(gl) {
      if (this.currentTexture === null || this.currentShader === null || this.faces === 0) {
        return;
      }
      this.bindTexture(gl, this.currentTexture);
      this.blendFunc(gl, this.blendSrcFactor, this.blendDstFactor, this.blendEquation);
      if (this.bindedVertexBuffer === this.vertexBuffer) {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexData);
      } else {
        this.bindVertexBuffer(gl, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.DYNAMIC_DRAW);
      }
      if (this.bindedIndexBuffer !== this.indexBuffer) {
        this.bindIndexBuffer(gl, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexData, gl.STATIC_DRAW);
      }
      gl.uniformMatrix4fv(this.currentShader.uMatrix, false, this.matrix);
      gl.drawElements(gl.TRIANGLES, this.faces * 6, gl.UNSIGNED_SHORT, 0);
      this.faces = 0;
      ++this.drawCalls;
    };

    WebGLRendererFactory.prototype.setBlendMode = function(blendMode) {
      this.blendMode = blendMode;
    };

    WebGLRendererFactory.prototype.setMaskMode = function(maskMode) {
      this.maskMode = maskMode;
    };

    WebGLRendererFactory.prototype.generateMask = function(gl) {
      var framebuffer, framebuffers, i, texture, textures, _i;
      if ((this.maskTexture != null) && this.maskTextureWidth === this.w && this.maskTextureHeight === this.h) {
        return;
      }
      this.maskMatrix = new Float32Array([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, this.h, 0, 1]);
      this.maskTexture = gl.createTexture();
      this.maskTextureWidth = this.w;
      this.maskTextureHeight = this.h;
      this.layerTexture = gl.createTexture();
      textures = [this.maskTexture, this.layerTexture];
      this.maskFrameBuffer = gl.createFramebuffer();
      this.layerFrameBuffer = gl.createFramebuffer();
      framebuffers = [this.maskFrameBuffer, this.layerFrameBuffer];
      for (i = _i = 0; _i < 2; i = ++_i) {
        texture = textures[i];
        this.bindTexture(gl, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.w, this.h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        this.setTexParameter(gl);
        framebuffer = framebuffers[i];
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      this.maskVertexData = new Float32Array([this.w, this.h, 1, 1, 1, this.w, 0, 1, 0, 1, 0, this.h, 0, 1, 1, 0, 0, 0, 0, 1]);
    };

    WebGLRendererFactory.prototype.deleteMask = function(gl) {
      if (this.maskTexture == null) {
        return;
      }
      gl.deleteFramebuffer(this.maskFrameBuffer);
      gl.deleteFramebuffer(this.layerFrameBuffer);
      this.maskFrameBuffer = null;
      this.layerFrameBuffer = null;
      gl.deleteTexture(this.maskTexture);
      gl.deleteTexture(this.layerTexture);
      this.maskTexture = null;
      this.layerTexture = null;
    };

    WebGLRendererFactory.prototype.renderMask = function(gl) {
      if (this.currentShader != null) {
        this.currentShader.disable(gl);
      }
      this.currentShader = this.shaders["simple"].use(gl, this.pMatrix);
      this.bindVertexBuffer(gl, this.vertexBuffer);
      this.maskVertexData[this.currentShader.attributes * 0 + 0] = this.w;
      this.maskVertexData[this.currentShader.attributes * 0 + 1] = this.h;
      this.maskVertexData[this.currentShader.attributes * 1 + 0] = this.w;
      this.maskVertexData[this.currentShader.attributes * 2 + 1] = this.h;
      if (this.bindedVertexBuffer === this.vertexBuffer) {
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.maskVertexData);
      } else {
        this.bindVertexBuffer(gl, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.maskVertexData, gl.DYNAMIC_DRAW);
      }
      this.maskMatrix[13] = this.h;
      gl.uniformMatrix4fv(this.currentShader.uMatrix, false, this.maskMatrix);
      this.bindIndexBuffer(gl, this.indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexData, gl.STATIC_DRAW);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.maskFrameBuffer);
      this.bindTexture(gl, this.layerTexture);
      this.blendFunc(gl, this.maskSrcFactor, gl.ZERO, gl.FUNC_ADD);
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
      ++this.drawCalls;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      this.bindTexture(gl, this.maskTexture);
      this.blendFunc(gl, gl.ONE, this.blendDstFactor, gl.FUNC_ADD);
      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
      ++this.drawCalls;
    };

    WebGLRendererFactory.prototype.constructBitmap = function(lwf, objectId, bitmap) {
      var context;
      context = this.bitmapContexts[objectId];
      if (context) {
        return new WebGLBitmapRenderer(context);
      }
    };

    WebGLRendererFactory.prototype.constructBitmapEx = function(lwf, objectId, bitmapEx) {
      var context;
      context = this.bitmapExContexts[objectId];
      if (context) {
        return new WebGLBitmapRenderer(context);
      }
    };

    WebGLRendererFactory.prototype.constructText = function(lwf, objectId, text) {
      var context;
      context = this.textContexts[objectId];
      if (context) {
        return new WebGLTextRenderer(lwf, context, text);
      }
    };

    WebGLRendererFactory.prototype.constructParticle = function(lwf, objectId, particle) {
      var ctor, particleData;
      ctor = this.resourceCache.particleConstructor;
      particleData = lwf.data.particleDatas[particle.particleDataId];
      if (ctor != null) {
        return ctor(lwf, lwf.data.strings[particleData.stringId]);
      }
    };

    WebGLRendererFactory.prototype.getStageSize = function() {
      return [this.stage.width, this.stage.height];
    };

    WebGLRendererFactory.prototype.setBackgroundColor = function(v) {
      var a, b, g, r, _ref;
      _ref = this.parseBackgroundColor(v), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
      this.backGroundColor = [r, g, b, a];
      this.setClearColor(this.glContext);
    };

    return WebGLRendererFactory;

  })(WebkitCSSRendererFactory);

  WebGLBitmapContext = (function() {
    function WebGLBitmapContext(factory, data, bitmapEx) {
      var attribute, bh, bu, bv, bw, d, filename, fragment, gl, h, image, key, repeat_s, repeat_t, scale, texdata, th, tw, u, u0, u1, v, v0, v1, w, x, x0, x1, y, y0, y1, _ref;
      this.factory = factory;
      this.data = data;
      fragment = data.textureFragments[bitmapEx.textureFragmentId];
      texdata = data.textures[fragment.textureId];
      this.preMultipliedAlpha = texdata.format === Format.Constant.TEXTUREFORMAT_PREMULTIPLIEDALPHA;
      filename = texdata.filename;
      image = this.factory.cache[filename];
      key = (_ref = image.src) != null ? _ref : image.name;
      repeat_s = (bitmapEx.attribute & Format.BitmapEx.Attribute.REPEAT_S) !== 0;
      if (repeat_s) {
        key += "_REPEAT_S";
      }
      repeat_t = (bitmapEx.attribute & Format.BitmapEx.Attribute.REPEAT_T) !== 0;
      if (repeat_s) {
        key += "_REPEAT_T";
      }
      d = this.factory.textures[key];
      if (d != null) {
        this.texture = d[0], scale = d[1], attribute = d[2];
      } else {
        scale = 1 / texdata.scale;
        gl = this.factory.glContext;
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        this.factory.setTexParameter(gl, repeat_s, repeat_t);
        this.factory.textures[key] = [this.texture, scale, bitmapEx.attribute];
      }
      tw = texdata.width;
      th = texdata.height;
      x = fragment.x;
      y = fragment.y;
      u = fragment.u;
      v = fragment.v;
      w = fragment.w;
      h = fragment.h;
      bu = bitmapEx.u * w;
      bv = bitmapEx.v * h;
      bw = bitmapEx.w;
      bh = bitmapEx.h;
      x += bu;
      y += bv;
      u += bu;
      v += bv;
      w *= bw;
      h *= bh;
      x0 = x * scale;
      y0 = y * scale;
      x1 = (x + w) * scale;
      y1 = (y + h) * scale;

      /*
      @vertexData = [
        {x:x1, y:y1},
        {x:x1, y:y0},
        {x:x0, y:y1},
        {x:x0, y:y0}
      ]
       */
      this.vertexData = new Float32Array(2 * 4);
      this.vertexData[0] = x1;
      this.vertexData[1] = y1;
      this.vertexData[2] = x1;
      this.vertexData[3] = y0;
      this.vertexData[4] = x0;
      this.vertexData[5] = y1;
      this.vertexData[6] = x0;
      this.vertexData[7] = y0;
      this.uv = new Float32Array(2 * 4);
      if (fragment.rotated === 0) {
        u0 = u / tw;
        v0 = v / th;
        u1 = (u + w) / tw;
        v1 = (v + h) / th;

        /*
        @uv = [
          {u:u1, v:v1},
          {u:u1, v:v0},
          {u:u0, v:v1},
          {u:u0, v:v0}
        ]
         */
        this.uv[0] = u1;
        this.uv[1] = v1;
        this.uv[2] = u1;
        this.uv[3] = v0;
        this.uv[4] = u0;
        this.uv[5] = v1;
        this.uv[6] = u0;
        this.uv[7] = v0;
      } else {
        u0 = u / tw;
        v0 = v / th;
        u1 = (u + h) / tw;
        v1 = (v + w) / th;

        /*
        @uv = [
          {u:u0, v:v1},
          {u:u1, v:v1},
          {u:u0, v:v0},
          {u:u1, v:v0}
        ]
         */
        this.uv[0] = u0;
        this.uv[1] = v1;
        this.uv[2] = u1;
        this.uv[3] = v1;
        this.uv[4] = u0;
        this.uv[5] = v0;
        this.uv[6] = u1;
        this.uv[7] = v0;
      }
    }

    WebGLBitmapContext.prototype.destruct = function() {};

    return WebGLBitmapContext;

  })();

  WebGLBitmapRenderer = (function() {
    function WebGLBitmapRenderer(context) {
      this.context = context;
      this.cmd = new WebGLRenderCommand(this.context, this.context.texture, null);
    }

    WebGLBitmapRenderer.prototype.destruct = function() {};

    WebGLBitmapRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var cmd, f, factory;
      if (!visible || c.multi.alpha === 0) {
        return;
      }
      f = this.context.factory.lwf.getRendererFactory();
      factory = this.context.factory;
      cmd = this.cmd;
      cmd.matrix = m;
      cmd.colorTransform = c;
      cmd.blendMode = f.blendMode;
      cmd.maskMode = f.maskMode;
      factory.addCommand(renderingIndex, cmd);
    };

    return WebGLBitmapRenderer;

  })();

  WebGLResourceCache = (function(_super) {
    __extends(WebGLResourceCache, _super);

    function WebGLResourceCache() {
      return WebGLResourceCache.__super__.constructor.apply(this, arguments);
    }

    WebGLResourceCache.prototype.getRendererName = function() {
      return "WebGL";
    };

    WebGLResourceCache.prototype.newFactory = function(settings, cache, data) {
      var _ref, _ref1, _ref2, _ref3;
      return new WebGLRendererFactory(data, this, cache, settings.stage, (_ref = settings["textInSubpixel"]) != null ? _ref : false, (_ref1 = settings["needsClear"]) != null ? _ref1 : true, (_ref2 = settings["useVertexColor"]) != null ? _ref2 : true, (_ref3 = settings["useAlwaysAdditionalColorShader"]) != null ? _ref3 : false);
    };

    return WebGLResourceCache;

  })(WebkitCSSResourceCache);

  WebGLTextContext = (function(_super) {
    __extends(WebGLTextContext, _super);

    function WebGLTextContext(factory, data, text) {
      var dh, dw, th, tw, u0, u1, v0, v1, x0, x1, y0, y1;
      this.factory = factory;
      this.data = data;
      this.text = text;
      WebGLTextContext.__super__.constructor.call(this, this.factory, this.data, this.text);
      this.preMultipliedAlpha = false;
      tw = this.text.width;
      th = this.text.height;
      x0 = 0;
      y0 = 0;
      x1 = tw;
      y1 = th;

      /*
      @vertexData = [
        {x:x1, y:y1},
        {x:x1, y:y0},
        {x:x0, y:y1},
        {x:x0, y:y0}
      ]
       */
      this.vertexData = new Float32Array(2 * 4);
      this.vertexData[0] = x1;
      this.vertexData[1] = y1;
      this.vertexData[2] = x1;
      this.vertexData[3] = y0;
      this.vertexData[4] = x0;
      this.vertexData[5] = y1;
      this.vertexData[6] = x0;
      this.vertexData[7] = y0;
      dw = 2.0 * tw;
      dh = 2.0 * th;
      u0 = 1 / dw;
      v0 = 1 / dh;
      u1 = u0 + (tw * 2 - 2) / dw;
      v1 = v0 + (th * 2 - 1) / dh;

      /*
      @uv = [
        {u:u1, v:v1},
        {u:u1, v:v0},
        {u:u0, v:v1},
        {u:u0, v:v0}
      ]
       */
      this.uv = new Float32Array(2 * 4);
      this.uv[0] = u1;
      this.uv[1] = v1;
      this.uv[2] = u1;
      this.uv[3] = v0;
      this.uv[4] = u0;
      this.uv[5] = v1;
      this.uv[6] = u0;
      this.uv[7] = v0;
    }

    return WebGLTextContext;

  })(HTML5TextContext);

  WebGLTextRenderer = (function(_super) {
    __extends(WebGLTextRenderer, _super);

    function WebGLTextRenderer(lwf, context, textObject) {
      this.lwf = lwf;
      this.context = context;
      this.textObject = textObject;
      WebGLTextRenderer.__super__.constructor.call(this, this.lwf, this.context, this.textObject);
      this.cmd = new WebGLRenderCommand(this.context, null, this.matrix);
    }

    WebGLTextRenderer.prototype.destruct = function() {
      var gl;
      gl = this.context.factory.glContext;
      if (this.texture) {
        gl.deleteTexture(this.texture);
      }
    };

    WebGLTextRenderer.prototype.needsScale = function() {
      return false;
    };

    WebGLTextRenderer.prototype.render = function(m, c, renderingIndex, renderingCount, visible) {
      var cmd, f, factory;
      if (!visible || c.multi.alpha === 0) {
        return;
      }
      WebGLTextRenderer.__super__.render.call(this, m, c, renderingIndex, renderingCount, visible);
      f = this.context.factory.lwf.getRendererFactory();
      factory = this.context.factory;
      cmd = this.cmd;
      cmd.texture = this.texture;
      cmd.colorTransform = c;
      cmd.blendMode = f.blendMode;
      cmd.maskMode = f.maskMode;
      factory.addCommand(renderingIndex, cmd);
    };

    WebGLTextRenderer.prototype.renderText = function(textColor) {
      var gl;
      WebGLTextRenderer.__super__.renderText.call(this, textColor);
      gl = this.context.factory.glContext;
      if (this.texture == null) {
        this.texture = gl.createTexture();
      }
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas);
      this.context.factory.setTexParameter(gl);
    };

    return WebGLTextRenderer;

  })(HTML5TextRenderer);

  if (typeof global !== "undefined") {
    global["LWF"]["WebGLRendererFactory"] = WebGLRendererFactory;
    global["LWF"]["WebGLResourceCache"] = WebGLResourceCache;
    global["LWF"]["useWebGLRenderer"] = function() {
      return global["LWF"]["ResourceCache"] = WebGLResourceCache;
    };
    global["LWF"]["LWF"]["useWebGLRenderer"] = global["LWF"]["useWebGLRenderer"];
  }

  WebGLRendererFactory.prototype["convertColor"] = WebGLRendererFactory.prototype.convertColor;

  WebGLRendererFactory.prototype["fitForHeight"] = WebGLRendererFactory.prototype.fitForHeight;

  WebGLRendererFactory.prototype["fitForWidth"] = WebGLRendererFactory.prototype.fitForWidth;

  WebGLRendererFactory.prototype["scaleForHeight"] = WebGLRendererFactory.prototype.scaleForHeight;

  WebGLRendererFactory.prototype["scaleForWidth"] = WebGLRendererFactory.prototype.scaleForWidth;

  WebGLRendererFactory.prototype["setBackgroundColor"] = WebGLRendererFactory.prototype.setBackgroundColor;

  WebGLResourceCache.prototype["clear"] = WebGLResourceCache.prototype.clear;

  WebGLResourceCache.prototype["getCache"] = WebGLResourceCache.prototype.getCache;

  WebGLResourceCache.prototype["getRendererName"] = WebGLResourceCache.prototype.getRendererName;

  WebGLResourceCache.prototype["loadLWF"] = WebGLResourceCache.prototype.loadLWF;

  WebGLResourceCache.prototype["loadLWFs"] = WebGLResourceCache.prototype.loadLWFs;

  WebGLResourceCache.prototype["unloadLWF"] = WebGLResourceCache.prototype.unloadLWF;

  WebGLResourceCache.prototype["setParticleConstructor"] = WebGLResourceCache.prototype.setParticleConstructor;

  WebGLResourceCache.prototype["setDOMElementConstructor"] = WebGLResourceCache.prototype.setDOMElementConstructor;

}).call(this);
/**
 * @author sole / http://soledadpenades.com
 * @author mrdoob / http://mrdoob.com
 * @author Robert Eisele / http://www.xarg.org
 * @author Philippe / http://philippe.elsass.me
 * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html
 * @author Paul Lewis / http://www.aerotwist.com/
 * @author lechecacharro
 * @author Josh Faul / http://jocafa.com/
 * @author egraether / http://egraether.com/
 * @author endel / http://endel.me
 * @author GREE, Inc.
 *
 * The MIT License
 *
 * Copyright (c) 2010-2012 Tween.js authors.
 * Copyright (c) 2012 GREE, Inc.
 *
 * Easing equations
 *   Copyright (c) 2001 Robert Penner http://robertpenner.com/easing/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function() {

var TWEENLWF = {};

TWEENLWF.REVISION = '10';

TWEENLWF.Tween = function ( target ) {

	this.lwf = target.lwf;
	this.object = target;
	this.valuesStart = {};
	this.valuesEnd = {};
	this.valuesStartRepeat = {};
	this.duration = 0;
	this.repeat = 0;
	this.delayTime = 0;
	this.startTime = null;
	this.easingFunction = TWEENLWF.Easing.Linear.None;
	this.interpolationFunction = TWEENLWF.Interpolation.Linear;
	this.chainedTweens = [];
	this.onStartCallback = null;
	this.onStartCallbackFired = false;
	this.onUpdateCallback = null;
	this.onCompleteCallback = null;

	if ( this.lwf._tweens === null ) {

		this.lwf._tweens = [];

		if ( this.lwf._tweenMode === "lwf" ) {

			this.lwf.addExecHandler( TWEENLWF._tweenExecHandler );

		} else {

			this.lwf.addMovieEventHandler( "_root", {

				"enterFrame": TWEENLWF._tweenMovieHandler

			});

		}

	}

	this.to = function ( properties, duration ) {

		if ( duration !== undefined ) {

			this.duration = duration * this.lwf.tick;

		}

		this.valuesEnd = properties;

		return this;

	};

	this.start = function () {

		this.lwf._tweens.push( this );

		this.onStartCallbackFired = false;

		this.startTime = this.lwf.time;
		this.startTime += this.delayTime;

		for ( var property in this.valuesEnd ) {

			// This prevents the engine from interpolating null values
			if ( this.object[ property ] === null ) {

				continue;

			}

			// check if an Array was provided as property value
			if ( this.valuesEnd[ property ] instanceof Array ) {

				if ( this.valuesEnd[ property ].length === 0 ) {

					continue;

				}

				// create a local copy of the Array with the start value at the front
				this.valuesEnd[ property ] = [ this.object[ property ] ].concat( this.valuesEnd[ property ] );

			}

			this.valuesStart[ property ] = this.object[ property ];

			if( ( this.valuesStart[ property ] instanceof Array ) === false ) {
				this.valuesStart[ property ] *= 1.0; // Ensures we're using numbers, not strings
			}

			this.valuesStartRepeat[ property ] = this.valuesStart[ property ] || 0;

		}

		return this;

	};

	this.stop = function () {

		var i = this.lwf._tweens.indexOf( this );

		if ( i !== -1 ) {

			this.lwf._tweens.splice( i, 1 );

			if ( this.lwf._tweens.length == 0 ) {

				this.lwf.stopTweens();

			}

		}

		return this;

	};

	this.delay = function ( amount ) {

		this.delayTime = amount * this.lwf.tick;
		return this;

	};

	this.repeat = function ( times ) {

		this.repeat = times;
		return this;

	};

	this.easing = function ( easing ) {

		this.easingFunction = easing;
		return this;

	};

	this.interpolation = function ( interpolation ) {

		this.interpolationFunction = interpolation;
		return this;

	};

	this.chain = function ( chainedTween ) {

		if ( typeof chainedTween !== "undefined" && chainedTween !== null ) {

			this.chainedTweens.push( chainedTween );
			return this;

		} else {

			chainedTween = new TWEENLWF.Tween( this.object );
			this.chainedTweens.push( chainedTween );
			return chainedTween;

		}

	};

	this.onStart = function ( callback ) {

		this.onStartCallback = callback;
		return this;

	};

	this.onUpdate = function ( callback ) {

		this.onUpdateCallback = callback;
		return this;

	};

	this.onComplete = function ( callback ) {

		this.onCompleteCallback = callback;
		return this;

	};

	this.update = function ( time ) {

		if ( time < this.startTime ) {

			return true;

		}

		if ( this.object[ "lwf" ] === null ) {

			return false;

		}

		if ( this.onStartCallbackFired === false ) {

			if ( this.onStartCallback !== null ) {

				this.onStartCallback.call( this.object );

			}

			this.onStartCallbackFired = true;

		}

		var duration = this.duration <= 0 ? this.lwf.tick : this.duration;

		var elapsed = ( time - this.startTime ) / duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		var value = this.easingFunction( elapsed );

		for ( var property in this.valuesEnd ) {

			var start = this.valuesStart[ property ] || 0;
			var end = this.valuesEnd[ property ];

			if ( end instanceof Array ) {

				this.object[ property ] = this.interpolationFunction( end, value );

			} else {

				if ( typeof(end) === "string" ) {
					end = start + parseFloat(end, 10);
				}

				this.object[ property ] = start + ( end - start ) * value;

			}

		}

		if ( this.onUpdateCallback !== null ) {

			this.onUpdateCallback.call( this.object, value );

		}

		if ( elapsed == 1 ) {

			if ( this.repeat > 0 ) {

				if( isFinite( this.repeat ) ) {
					this.repeat--;
				}

				// reassign starting values, restart by making startTime = now
				for( var property in this.valuesStartRepeat ) {

					if ( typeof( this.valuesEnd[ property ] ) === "string" ) {
						this.valuesStartRepeat[ property ] = this.valuesStartRepeat[ property ] + parseFloat(this.valuesEnd[ property ], 10);
					}

					this.valuesStart[ property ] = this.valuesStartRepeat[ property ];

				}

				this.startTime = time + this.delayTime;

				return true;

			} else {

				if ( this.onCompleteCallback !== null ) {

					this.onCompleteCallback.call( this.object );

				}

				for ( var i = 0, l = this.chainedTweens.length; i < l; i ++ ) {

					this.chainedTweens[ i ].start( time );

				}

				return false;

			}

		}

		return true;

	};

	this[ "to" ] = this.to;
	this[ "start" ] = this.start;
	this[ "stop" ] = this.stop;
	this[ "delay" ] = this.delay;
	this[ "easing" ] = this.easing;
	this[ "interpolation" ] = this.interpolation;
	this[ "chain" ] = this.chain;
	this[ "onStart" ] = this.onStart;
	this[ "onUpdate" ] = this.onUpdate;
	this[ "onComplete" ] = this.onComplete;
	this[ "update" ] = this.update;

};

TWEENLWF.Easing = {

	Linear: {

		None: function ( k ) {

			return k;

		}

	},

	Quadratic: {

		In: function ( k ) {

			return k * k;

		},

		Out: function ( k ) {

			return k * ( 2 - k );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
			return - 0.5 * ( --k * ( k - 2 ) - 1 );

		}

	},

	Cubic: {

		In: function ( k ) {

			return k * k * k;

		},

		Out: function ( k ) {

			return --k * k * k + 1;

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
			return 0.5 * ( ( k -= 2 ) * k * k + 2 );

		}

	},

	Quartic: {

		In: function ( k ) {

			return k * k * k * k;

		},

		Out: function ( k ) {

			return 1 - ( --k * k * k * k );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
			return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );

		}

	},

	Quintic: {

		In: function ( k ) {

			return k * k * k * k * k;

		},

		Out: function ( k ) {

			return --k * k * k * k * k + 1;

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
			return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

		}

	},

	Sinusoidal: {

		In: function ( k ) {

			return 1 - Math.cos( k * Math.PI / 2 );

		},

		Out: function ( k ) {

			return Math.sin( k * Math.PI / 2 );

		},

		InOut: function ( k ) {

			return 0.5 * ( 1 - Math.cos( Math.PI * k ) );

		}

	},

	Exponential: {

		In: function ( k ) {

			return k === 0 ? 0 : Math.pow( 1024, k - 1 );

		},

		Out: function ( k ) {

			return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );

		},

		InOut: function ( k ) {

			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
			return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );

		}

	},

	Circular: {

		In: function ( k ) {

			return 1 - Math.sqrt( 1 - k * k );

		},

		Out: function ( k ) {

			return Math.sqrt( 1 - ( --k * k ) );

		},

		InOut: function ( k ) {

			if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
			return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);

		}

	},

	Elastic: {

		In: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );

		},

		Out: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );

		},

		InOut: function ( k ) {

			var s, a = 0.1, p = 0.4;
			if ( k === 0 ) return 0;
			if ( k === 1 ) return 1;
			if ( !a || a < 1 ) { a = 1; s = p / 4; }
			else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
			if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
			return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;

		}

	},

	Back: {

		In: function ( k ) {

			var s = 1.70158;
			return k * k * ( ( s + 1 ) * k - s );

		},

		Out: function ( k ) {

			var s = 1.70158;
			return --k * k * ( ( s + 1 ) * k + s ) + 1;

		},

		InOut: function ( k ) {

			var s = 1.70158 * 1.525;
			if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
			return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

		}

	},

	Bounce: {

		In: function ( k ) {

			return 1 - TWEENLWF.Easing.Bounce.Out( 1 - k );

		},

		Out: function ( k ) {

			if ( k < ( 1 / 2.75 ) ) {

				return 7.5625 * k * k;

			} else if ( k < ( 2 / 2.75 ) ) {

				return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

			} else if ( k < ( 2.5 / 2.75 ) ) {

				return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

			} else {

				return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

			}

		},

		InOut: function ( k ) {

			if ( k < 0.5 ) return TWEENLWF.Easing.Bounce.In( k * 2 ) * 0.5;
			return TWEENLWF.Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;

		}

	}

};

TWEENLWF.Interpolation = {

	Linear: function ( v, k ) {

		var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEENLWF.Interpolation.Utils.Linear;

		if ( k < 0 ) return fn( v[ 0 ], v[ 1 ], f );
		if ( k > 1 ) return fn( v[ m ], v[ m - 1 ], m - f );

		return fn( v[ i ], v[ i + 1 > m ? m : i + 1 ], f - i );

	},

	Bezier: function ( v, k ) {

		var b = 0, n = v.length - 1, pw = Math.pow, bn = TWEENLWF.Interpolation.Utils.Bernstein, i;

		for ( i = 0; i <= n; i++ ) {
			b += pw( 1 - k, n - i ) * pw( k, i ) * v[ i ] * bn( n, i );
		}

		return b;

	},

	CatmullRom: function ( v, k ) {

		var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEENLWF.Interpolation.Utils.CatmullRom;

		if ( v[ 0 ] === v[ m ] ) {

			if ( k < 0 ) i = Math.floor( f = m * ( 1 + k ) );

			return fn( v[ ( i - 1 + m ) % m ], v[ i ], v[ ( i + 1 ) % m ], v[ ( i + 2 ) % m ], f - i );

		} else {

			if ( k < 0 ) return v[ 0 ] - ( fn( v[ 0 ], v[ 0 ], v[ 1 ], v[ 1 ], -f ) - v[ 0 ] );
			if ( k > 1 ) return v[ m ] - ( fn( v[ m ], v[ m ], v[ m - 1 ], v[ m - 1 ], f - m ) - v[ m ] );

			return fn( v[ i ? i - 1 : 0 ], v[ i ], v[ m < i + 1 ? m : i + 1 ], v[ m < i + 2 ? m : i + 2 ], f - i );

		}

	},

	Utils: {

		Linear: function ( p0, p1, t ) {

			return ( p1 - p0 ) * t + p0;

		},

		Bernstein: function ( n , i ) {

			var fc = TWEENLWF.Interpolation.Utils.Factorial;
			return fc( n ) / fc( i ) / fc( n - i );

		},

		Factorial: ( function () {

			var a = [ 1 ];

			return function ( n ) {

				var s = 1, i;
				if ( a[ n ] ) return a[ n ];
				for ( i = n; i > 1; i-- ) s *= i;
				return a[ n ] = s;

			};

		} )(),

		CatmullRom: function ( p0, p1, p2, p3, t ) {

			var v0 = ( p2 - p0 ) * 0.5, v1 = ( p3 - p1 ) * 0.5, t2 = t * t, t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

		}

	}

};

var lwfPrototype = global[ "LWF" ][ "LWF" ].prototype;

lwfPrototype[ "setTweenMode" ] = function( mode ) {

	this._tweenMode = mode;

};

lwfPrototype.stopTweens = function() {

	if ( this._tweens !== null ) {

		this._tweens = null;

		this.removeExecHandler( TWEENLWF._tweenExecHandler );
		this.removeMovieEventHandler( "_root", {
			
			"enterFrame": TWEENLWF._tweenMovieHandler

		});

	}

};

lwfPrototype[ "stopTweens" ] = lwfPrototype.stopTweens;

TWEENLWF._tweenUpdater = function() {

	if ( this._tweens === null )
		return;

	var i = 0;
	var num_tweens = this._tweens.length;
	var time = this.time;

	while ( i < num_tweens ) {

		if ( this._tweens[ i ].update( time ) ) {

			i ++;

		} else {

			this._tweens.splice( i, 1 );
			num_tweens --;

		}

	}

	if ( this._tweens.length == 0 ) {

		this.stopTweens();

	}

};

TWEENLWF._tweenExecHandler = function() {

	TWEENLWF._tweenUpdater.call( this );

};

TWEENLWF._tweenMovieHandler = function() {

	TWEENLWF._tweenUpdater.call( this.lwf );

};

var moviePrototype = global[ "LWF" ][ "Movie" ].prototype;

moviePrototype[ "addTween" ] = function() {

	var tween = new TWEENLWF.Tween( this );

	return tween;

};

moviePrototype[ "stopTweens" ] = function() {

	if ( typeof this.lwf === "undefined" || this.lwf === null ||
			this.lwf._tweens === null ) {

		return this;

	}

	var tweens = this.lwf._tweens;

	var i = 0;
	var num_tweens = tweens.length;

	while ( i < num_tweens ) {

		if ( tweens[ i ].object === this ) {

			tweens.splice( i, 1 );
			num_tweens --;

		} else {

			i ++;

		}

	}

	if ( tweens.length == 0 ) {

		this.lwf.stopTweens();

	}

	return this;

};

var bitmapClipPrototype = global[ "LWF" ][ "BitmapClip" ].prototype;
bitmapClipPrototype[ "addTween" ] = moviePrototype[ "addTween" ];
bitmapClipPrototype[ "stopTweens" ] = moviePrototype[ "stopTweens" ];

global[ "LWF" ][ "Tween" ] = TWEENLWF.Tween;
global[ "LWF" ][ "Tween" ][ "Easing" ] = TWEENLWF.Easing;
var e = global[ "LWF" ][ "Tween" ][ "Easing" ];
e[ "Linear" ] = TWEENLWF.Easing.Linear;
e[ "Linear" ][ "None" ] = TWEENLWF.Easing.Linear.None;
e[ "Quadratic" ] = TWEENLWF.Easing.Quadratic;
e[ "Quadratic" ][ "In" ] = TWEENLWF.Easing.Quadratic.In;
e[ "Quadratic" ][ "Out" ] = TWEENLWF.Easing.Quadratic.Out;
e[ "Quadratic" ][ "InOut" ] = TWEENLWF.Easing.Quadratic.InOut;
e[ "Cubic" ] = TWEENLWF.Easing.Cubic;
e[ "Cubic" ][ "In" ] = TWEENLWF.Easing.Cubic.In;
e[ "Cubic" ][ "Out" ] = TWEENLWF.Easing.Cubic.Out;
e[ "Cubic" ][ "InOut" ] = TWEENLWF.Easing.Cubic.InOut;
e[ "Quartic" ] = TWEENLWF.Easing.Quartic;
e[ "Quartic" ][ "In" ] = TWEENLWF.Easing.Quartic.In;
e[ "Quartic" ][ "Out" ] = TWEENLWF.Easing.Quartic.Out;
e[ "Quartic" ][ "InOut" ] = TWEENLWF.Easing.Quartic.InOut;
e[ "Quintic" ] = TWEENLWF.Easing.Quintic;
e[ "Quintic" ][ "In" ] = TWEENLWF.Easing.Quintic.In;
e[ "Quintic" ][ "Out" ] = TWEENLWF.Easing.Quintic.Out;
e[ "Quintic" ][ "InOut" ] = TWEENLWF.Easing.Quintic.InOut;
e[ "Sinusoidal" ] = TWEENLWF.Easing.Sinusoidal;
e[ "Sinusoidal" ][ "In" ] = TWEENLWF.Easing.Sinusoidal.In;
e[ "Sinusoidal" ][ "Out" ] = TWEENLWF.Easing.Sinusoidal.Out;
e[ "Sinusoidal" ][ "InOut" ] = TWEENLWF.Easing.Sinusoidal.InOut;
e[ "Exponential" ] = TWEENLWF.Easing.Exponential;
e[ "Exponential" ][ "In" ] = TWEENLWF.Easing.Exponential.In;
e[ "Exponential" ][ "Out" ] = TWEENLWF.Easing.Exponential.Out;
e[ "Exponential" ][ "InOut" ] = TWEENLWF.Easing.Exponential.InOut;
e[ "Circular" ] = TWEENLWF.Easing.Circular;
e[ "Circular" ][ "In" ] = TWEENLWF.Easing.Circular.In;
e[ "Circular" ][ "Out" ] = TWEENLWF.Easing.Circular.Out;
e[ "Circular" ][ "InOut" ] = TWEENLWF.Easing.Circular.InOut;
e[ "Elastic" ] = TWEENLWF.Easing.Elastic;
e[ "Elastic" ][ "In" ] = TWEENLWF.Easing.Elastic.In;
e[ "Elastic" ][ "Out" ] = TWEENLWF.Easing.Elastic.Out;
e[ "Elastic" ][ "InOut" ] = TWEENLWF.Easing.Elastic.InOut;
e[ "Back" ] = TWEENLWF.Easing.Back;
e[ "Back" ][ "In" ] = TWEENLWF.Easing.Back.In;
e[ "Back" ][ "Out" ] = TWEENLWF.Easing.Back.Out;
e[ "Back" ][ "InOut" ] = TWEENLWF.Easing.Back.InOut;
e[ "Bounce" ] = TWEENLWF.Easing.Bounce;
e[ "Bounce" ][ "In" ] = TWEENLWF.Easing.Bounce.In;
e[ "Bounce" ][ "Out" ] = TWEENLWF.Easing.Bounce.Out;
e[ "Bounce" ][ "InOut" ] = TWEENLWF.Easing.Bounce.InOut;

global[ "LWF" ][ "Tween" ][ "Interpolation" ] = TWEENLWF.Interpolation;
var i = global[ "LWF" ][ "Tween" ][ "Interpolation" ];
i[ "Linear" ] = TWEENLWF.Interpolation.Linear;
i[ "Bezier" ] = TWEENLWF.Interpolation.Bezier;
i[ "CatmullRom" ] = TWEENLWF.Interpolation.CatmullRom;
i[ "Utils" ] = TWEENLWF.Interpolation.Utils;
i[ "Utils" ][ "Linear" ] = TWEENLWF.Interpolation.Utils.Linear;
i[ "Utils" ][ "Bernstein" ] = TWEENLWF.Interpolation.Utils.Bernstein;
i[ "Utils" ][ "Factorial" ] = TWEENLWF.Interpolation.Utils.Factorial;
i[ "Utils" ][ "CatmullRom" ] = TWEENLWF.Interpolation.Utils.CatmullRom;

}).call(this);
(function() {

var Base64 = {};

/**
 * @const
 * @type {string}
 */
Base64.Character =  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

/**
 * @const
 * @type {string}
 */
Base64.RangeError = "INVALID_CHARACTER_ERR";

Base64.btoaArray = {};

/**
 * @const
 * @type {(Uint8Array|Array.<number>)}
 */
Base64.btoaArray.CharacterTable = (
/**
 * @param {string} chars
 * @return {(Uint8Array|Array.<number>)}
 */
function(chars) {
  /** @type {(Uint8Array|Array.<number>)} */
  var array =
    new (typeof Uint8Array !== 'undefined' ? Uint8Array : Array)(chars.length);
  /** @type {number} */
  var i;
  /** @type {number} */
  var il;

  for (i = 0, il = array.length; i < il; ++i) {
    array[i] = chars.charCodeAt(i);
  }

  return array;
})(Base64.Character);

/**
 * @param {string} str base64 encoded string.
 * @return {Array.<number>|Uint8Array} decoded byte-array.
 */
Base64.atobArray = function(str) {
  /** @type {number} */
  var buffer = 0;
  /** @type {number} */
  var pos = 0;
  /** @type {number} */
  var length = str.length;
  /** @type {(Uint8Array|Array.<number>)} */
  var out;
  /** @type {number} */
  var outpos = 0;
  /** @type {number} */
  var bitlen = 0;
  /** @type {Array.<number>|Int16Array} */
  var decode = Base64.atobArray.DecodeTable;
  /** @type {number} */
  var decoded;
  /** @type {number} */
  var tmp;
  /** @type {number} */
  var mod;

  // remove padding
  while (str.charAt(length-1) === '=') {
    --length;
  }
  mod = length % 4;

  // create output buffer
  out = new (typeof Uint8Array !== 'undefined' ? Uint8Array : Array)(
    ((length + 3) / 4 | 0) * 3 - [0, 0, 2, 1][mod]
  );

  // check range
  if (length % 4 === 1 || (str.length > 0 && length === 0)) {
    throw new Error(Base64.RangeError);
  }

  while (pos < length) {
    tmp = str.charCodeAt(pos++);
    decoded = tmp < 256 ? decode[tmp] : -1;

    // check character range
    if (decoded === -1) {
      throw new Error(Base64.RangeError);
    }

    // add buffer (6bit)
    buffer = (buffer << 6) + decoded;
    bitlen += 6;

    // decode byte
    if (bitlen >= 8) {
      bitlen -= 8;

      // extract byte
      tmp = buffer >> bitlen;

      // decode character
      out[outpos++] = tmp;

      // remove character bits
      buffer ^= tmp << bitlen;
    }
  }

  return out;
};

/**
 * @const
 * @type {(Array.<number>|Int16Array)}
 */
Base64.atobArray.DecodeTable = (
/**
 * @param {Uint8Array|Array.<number>} encodeTable character table.
 * @return {Int16Array|Array.<number>} decode table.
 */
function(encodeTable) {
  /** @type {(Int16Array|Array.<number>)} */
  var table = new (typeof Int16Array !== 'undefined' ? Int16Array : Array)(256);
  /** @type {number} */
  var i;
  /** @type {Array.<number>} */
  var array = encodeTable instanceof Array ?
    encodeTable : Array.prototype.slice.call(encodeTable);

  for (i = 0; i < 0xff; ++i) {
    table[i] = array.indexOf(i);
  }

  return table;
})(Base64.btoaArray.CharacterTable);

global["LWF"].Base64 = Base64;

}).call(this);
(function() {

var RangeCoder = {};
var LZ = {};
var LZMA = {};

  // typed array / Buffer compatibility.
  var makeBuffer = function(len) {
      var b = [], i;
      for (i=0; i<len; i++) { b[i] = 0; }
      return b;
  };
  if (typeof(Uint8Array) !== 'undefined') {
    makeBuffer = function(len) { return new Uint8Array(len); };
  }
(function() {
// largest 32/24/16/8-bit numbers.
var MAX32 = 0xFFFFFFFF;
var MAX24 = 0x00FFFFFF;
var MAX16 = 0x0000FFFF;
var MAX8  = 0x000000FF;
var MASK24= 0xFF000000; // 32-bit inverse of MAX24

var kNumBitModelTotalBits = 11;
var kBitModelTotal = (1 << kNumBitModelTotalBits);
var kNumMoveBits = 5;

var kNumMoveReducingBits = 2;
var kNumBitPriceShiftBits = 6;

var Encoder = function(stream){
  this.init();
  if (stream) { this.setStream(stream); }
};
Encoder.prototype.setStream = function(stream) {
  this._stream = stream;
};
Encoder.prototype.releaseStream = function() {
  this._stream = null;
};
Encoder.prototype.init = function() {
  // The cache/cache_size variables are used to properly handle
  // carries, and represent a number defined by a big-endian sequence
  // starting with the cache value, and followed by cache_size 0xff
  // bytes, which has been shifted out of the low register, but hasn't
  // been written yet, because it could be incremented by one due to a
  // carry.

  // Note that the first byte output will always be 0 due to the fact
  // that cache and low are initialized to 0, and the encoder
  // implementation; the decoder ignores this byte.
  this._position = 0;
  this.low = 0; // unsigned 33-bit integer
  this.range = MAX32; // unsigned 32-bit integer
  // cacheSize needs to be large enough to store the full uncompressed
  // size; javascript's 2^53 limit should be enough
  this._cacheSize = 1;
  this._cache = 0; // unsigned 8-bit
};
Encoder.prototype.flushData = function() {
  var i;
  for (i=0; i<5; i++) {
    this.shiftLow();
  }
};
Encoder.prototype.flushStream = function() {
  if (this._stream.flush) {
    this._stream.flush();
  }
};
Encoder.prototype.shiftLow = function() {
  // "normalization"
  var overflow = (this.low > MAX32) ? 1 : 0;
  if (this.low < MASK24 || overflow) {
    this._position += this._cacheSize;
    var temp = this._cache;
    do {
      this._stream.writeByte((temp + overflow) & MAX8);
      temp = MAX8;
    } while (--this._cacheSize !== 0);
    // set cache to bits 24-31 of 'low'
    this._cache = this.low >>> 24; // this truncates correctly
    // set cache_size to 0 (do/while loop did this)
  }
  this._cacheSize++;
  // 'lowest 24 bits of low, shifted left by 8'
  // careful, '<< 8' can flip sign of 'low'
  this.low = (this.low & MAX24) * 256;
};

Encoder.prototype.encodeDirectBits = function(v, numTotalBits) {
  var i, mask;
  mask = 1 << (numTotalBits-1);
  for (i = numTotalBits - 1; i >= 0; i--, mask>>>=1) {
    this.range >>>= 1; // range is unsigned 32-bit int
    if (v & mask) {
      this.low += this.range;
    }
    if (this.range <= MAX24) {
      this.range *= 256; // careful not to flip sign
      this.shiftLow();
    }
  }
};

Encoder.prototype.getProcessedSizeAdd = function() {
  return this._cacheSize + this._position + 4;
};

Encoder.initBitModels = function(probs, len) {
  var i;
  if (len && !probs) {
    if (typeof(Uint16Array)!=='undefined') {
      probs = new Uint16Array(len);
    } else {
      probs = [];
      probs.length = len;
    }
  }
  for (i=0; i < probs.length; i++)
    probs[i] = (kBitModelTotal >>> 1); // 0.5 probability
  return probs;
};

Encoder.prototype.encode = function(probs, index, symbol) {
  var prob = probs[index];
  var newBound = (this.range >>> kNumBitModelTotalBits) * prob;
  if (symbol === 0) {
    this.range = newBound;
    probs[index] = prob + ((kBitModelTotal - prob) >>> kNumMoveBits);
  } else {
    this.low += newBound;
    this.range -= newBound;
    probs[index] = prob - (prob >>> kNumMoveBits);
  }
  if (this.range <= MAX24) {
    this.range *= 256; // careful not to flip sign
    this.shiftLow();
  }
};

var ProbPrices = [];
if (typeof(Uint32Array)!=='undefined') {
  ProbPrices = new Uint32Array(kBitModelTotal >>> kNumMoveReducingBits);
}
(function() {
  var kNumBits = (kNumBitModelTotalBits - kNumMoveReducingBits);
  var i, j;
  for (i = kNumBits - 1; i >= 0; i--) {
    var start = 1 << (kNumBits - i - 1);
    var end = 1 << (kNumBits - i);
    for (j = start; j < end; j++) {
      ProbPrices[j] = (i << kNumBitPriceShiftBits) +
        (((end - j) << kNumBitPriceShiftBits) >>> (kNumBits - i - 1));
    }
  }
})();

Encoder.getPrice = function(prob, symbol) {
  return ProbPrices[(((prob - symbol) ^ ((-symbol))) & (kBitModelTotal - 1)) >>> kNumMoveReducingBits];
};
Encoder.getPrice0 = function(prob) {
  return ProbPrices[prob >>> kNumMoveReducingBits];
};
Encoder.getPrice1 = function(prob) {
  return ProbPrices[(kBitModelTotal - prob) >>> kNumMoveReducingBits];
};

// export constants for use in Encoder.
Encoder.kNumBitPriceShiftBits = kNumBitPriceShiftBits;

RangeCoder.Encoder = Encoder;
var Decoder = function(stream){
  if (stream) {
    this.setStream(stream);
    this.init();
  }
};

Decoder.prototype.setStream = function(stream){
  this._stream = stream;
};

Decoder.prototype.releaseStream = function(){
  this._stream = null;
};

Decoder.prototype.init = function(){
  var i = 5;

  this._code = 0;
  this._range = -1;

  while(i --){
    this._code = (this._code << 8) | this._stream.readByte();
  }
};

Decoder.prototype.decodeDirectBits = function(numTotalBits){
  var result = 0, i = numTotalBits, t;

  while(i --){
    this._range >>>= 1;
    t = (this._code - this._range) >>> 31;
    this._code -= this._range & (t - 1);
    result = (result << 1) | (1 - t);

    if ( (this._range & 0xff000000) === 0){
      this._code = (this._code << 8) | this._stream.readByte();
      this._range <<= 8;
    }
  }

  return result;
};

Decoder.prototype.decodeBit = function(probs, index){
  var prob = probs[index],
      newBound = (this._range >>> 11) * prob;

  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){
    this._range = newBound;
    probs[index] += (2048 - prob) >>> 5;
    if ( (this._range & 0xff000000) === 0){
      this._code = (this._code << 8) | this._stream.readByte();
      this._range <<= 8;
    }
    return 0;
  }

  this._range -= newBound;
  this._code -= newBound;
  probs[index] -= prob >>> 5;
  if ( (this._range & 0xff000000) === 0){
    this._code = (this._code << 8) | this._stream.readByte();
    this._range <<= 8;
  }
  return 1;
};

RangeCoder.Decoder = Decoder;
var BitTreeEncoder = function(numBitLevels) {
  this._numBitLevels = numBitLevels;
  this.init();
};
BitTreeEncoder.prototype.init = function() {
  this._models = Encoder.initBitModels(null, 1 << this._numBitLevels);
};

BitTreeEncoder.prototype.encode = function(rangeEncoder, symbol) {
  var m = 1, bitIndex;
  for (bitIndex = this._numBitLevels; bitIndex > 0; ) {
    bitIndex--;
    var bit = (symbol >>> bitIndex) & 1;
    rangeEncoder.encode(this._models, m, bit);
    m = (m << 1) | bit;
  }
};

BitTreeEncoder.prototype.reverseEncode = function(rangeEncoder, symbol) {
  var m = 1, i;
  for (i = 0; i < this._numBitLevels; i++) {
    var bit = symbol & 1;
    rangeEncoder.encode(this._models, m, bit);
    m = (m << 1) | bit;
    symbol >>>= 1;
  }
};

BitTreeEncoder.reverseEncode = function(models, startIndex, rangeEncoder, numBitLevels, symbol) {
  var m = 1, i;
  for (i = 0; i < numBitLevels; i++) {
    var bit = symbol & 1;
    rangeEncoder.encode(models, startIndex + m, bit);
    m = (m << 1) | bit;
    symbol >>>= 1;
  }
};

BitTreeEncoder.prototype.getPrice = function(symbol) {
  var price = 0, m = 1, bitIndex;
  for (bitIndex = this._numBitLevels; bitIndex > 0; ) {
    bitIndex--;
    var bit = (symbol >>> bitIndex) & 1;
    price += Encoder.getPrice(this._models[m], bit);
    m = (m << 1) | bit;
  }
  return price;
};

BitTreeEncoder.prototype.reverseGetPrice = function(symbol) {
  var price = 0, m = 1, bitIndex;
  for (bitIndex = this._numBitLevels; bitIndex > 0; bitIndex--) {
    var bit = (symbol & 1);
    symbol >>>= 1;
    price += Encoder.getPrice(this._models[m], bit);
    m = (m << 1) | bit;
  }
  return price;
};

BitTreeEncoder.reverseGetPrice = function(models, startIndex,
                                          numBitLevels, symbol) {
  var price = 0, m = 1, bitIndex;
  for (bitIndex = numBitLevels; bitIndex > 0; bitIndex--) {
    var bit = (symbol & 1);
    symbol >>>= 1;
    price += Encoder.getPrice(models[startIndex + m], bit);
    m = (m << 1) | bit;
  }
  return price;
};

RangeCoder.BitTreeEncoder = BitTreeEncoder;
var BitTreeDecoder = function(numBitLevels){
  this._numBitLevels = numBitLevels;
  this.init();
};

BitTreeDecoder.prototype.init = function(){
  this._models = Encoder.initBitModels(null, 1 << this._numBitLevels);
};

BitTreeDecoder.prototype.decode = function(rangeDecoder){
  var m = 1, i = this._numBitLevels;

  while(i --){
    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);
  }
  return m - (1 << this._numBitLevels);
};

BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){
  var m = 1, symbol = 0, i = 0, bit;

  for (; i < this._numBitLevels; ++ i){
    bit = rangeDecoder.decodeBit(this._models, m);
    m = (m << 1) | bit;
    symbol |= (bit << i);
  }
  return symbol;
};

BitTreeDecoder.reverseDecode = function(models, startIndex, rangeDecoder,
                                        numBitLevels) {
  var m = 1, symbol = 0, i = 0, bit;

  for (; i < numBitLevels; ++ i){
    bit = rangeDecoder.decodeBit(models, startIndex + m);
    m = (m << 1) | bit;
    symbol |= (bit << i);
  }
  return symbol;
};

RangeCoder.BitTreeDecoder = BitTreeDecoder;
}).call(this);
(function() {

var InWindow = function(keepSizeBefore, keepSizeAfter, keepSizeReserve, stream){
  if (arguments.length >= 4) {
    // typical initialization sequence
    var args = Array.prototype.slice.call(arguments, 0);
    var _stream = args.pop();
    this.create.apply(this, args);
    this.setStream(_stream);
    this.init();
  }
};

InWindow.prototype.moveBlock = function() {
  var i;
  var offset = this._bufferOffset + this._pos + this._keepSizeBefore;
  // we need one additional byte, since MovePos moves on 1 byte.
  if (offset > 0) {
    offset--;
  }

  var numBytes = this._bufferOffset + this._streamPos - offset;
  for (i = 0; i < numBytes; i++) {
    this._bufferBase[i] = this._bufferBase[offset + i];
  }
  this._bufferOffset -= offset;
};

InWindow.prototype.readBlock = function() {
  if (this._streamEndWasReached) {
    return;
  }
  while (true) {
    var size = -this._bufferOffset + this._blockSize - this._streamPos;
    if (size === 0) {
      return;
    }
    var numReadBytes =
      this._stream.read(this._bufferBase,
                        this._bufferOffset + this._streamPos,
                        size);
    if (numReadBytes <= 0) {
      this._posLimit = this._streamPos;
      var pointerToPosition = this._bufferOffset + this._posLimit;
      if (pointerToPosition > this._pointerToLastSafePosition) {
        this._posLimit = this._pointerToLastSafePosition - this._bufferOffset;
      }

      this._streamEndWasReached = true;
      return;
    }
    this._streamPos += numReadBytes;
    if (this._streamPos >= this._pos + this._keepSizeAfter) {
      this._posLimit = this._streamPos - this._keepSizeAfter;
    }
  }
};

InWindow.prototype.free = function() {
  this._bufferBase = null;
};

InWindow.prototype.create = function(keepSizeBefore, keepSizeAfter, keepSizeReserve) {
  this._keepSizeBefore = keepSizeBefore;
  this._keepSizeAfter = keepSizeAfter;
  var blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserve;
  if ((!this._bufferBase) || this._blockSize !== blockSize) {
    this.free();
    this._blockSize = blockSize;
    this._bufferBase = makeBuffer(this._blockSize);
  }
  this._pointerToLastSafePosition = this._blockSize - keepSizeAfter;
};

InWindow.prototype.setStream = function(stream) {
  this._stream = stream;
};

InWindow.prototype.releaseStream = function() {
  this._stream = null;
};

InWindow.prototype.init = function() {
  this._bufferOffset = 0;
  this._pos = 0;
  this._streamPos = 0;
  this._streamEndWasReached = false;
  this.readBlock();
};

InWindow.prototype.movePos = function() {
  this._pos++;
  if (this._pos > this._posLimit) {
    var pointerToPosition = this._bufferOffset + this._pos;
    if (pointerToPosition > this._pointerToLastSafePosition) {
      this.moveBlock();
    }
    this.readBlock();
  }
};

InWindow.prototype.getIndexByte = function(index) {
  return this._bufferBase[this._bufferOffset + this._pos + index];
};

// index + limit have not to exceed _keepSizeAfter
InWindow.prototype.getMatchLen = function(index, distance, limit) {
  var pby, i;
  if (this._streamEndWasReached) {
    if (this._pos + index + limit > this._streamPos) {
      limit = this._streamPos - (this._pos + index);
    }
  }
  distance++;
  pby = this._bufferOffset + this._pos + index;
  for (i=0; i < limit && this._bufferBase[pby + i] === this._bufferBase[pby + i - distance]; ) {
    i++;
  }
  return i;
};

InWindow.prototype.getNumAvailableBytes = function() {
  return this._streamPos - this._pos;
};

InWindow.prototype.reduceOffsets = function(subValue) {
  this._bufferOffset += subValue;
  this._posLimit -= subValue;
  this._pos -= subValue;
  this._streamPos -= subValue;
};

LZ.InWindow = InWindow;
var OutWindow = function(){
  this._windowSize = 0;
};

OutWindow.prototype.create = function(windowSize){
  if ( (!this._buffer) || (this._windowSize !== windowSize) ){
    this._buffer = makeBuffer(windowSize);
  }
  this._windowSize = windowSize;
  this._pos = 0;
  this._streamPos = 0;
};

OutWindow.prototype.flush = function(){
  var size = this._pos - this._streamPos;
  if (size !== 0){
    while(size --){
      this._stream.writeByte(this._buffer[this._streamPos ++]);
    }
    if (this._pos >= this._windowSize){
      this._pos = 0;
    }
    this._streamPos = this._pos;
  }
};

OutWindow.prototype.releaseStream = function(){
  this.flush();
  this._stream = null;
};

OutWindow.prototype.setStream = function(stream){
  this.releaseStream();
  this._stream = stream;
};

OutWindow.prototype.init = function(solid){
  if (!solid){
    this._streamPos = 0;
    this._pos = 0;
  }
};

OutWindow.prototype.copyBlock = function(distance, len){
  var pos = this._pos - distance - 1;
  if (pos < 0){
    pos += this._windowSize;
  }
  while(len --){
    if (pos >= this._windowSize){
      pos = 0;
    }
    this._buffer[this._pos ++] = this._buffer[pos ++];
    if (this._pos >= this._windowSize){
      this.flush();
    }
  }
};

OutWindow.prototype.putByte = function(b){
  this._buffer[this._pos ++] = b;
  if (this._pos >= this._windowSize){
    this.flush();
  }
};

OutWindow.prototype.getByte = function(distance){
  var pos = this._pos - distance - 1;
  if (pos < 0){
    pos += this._windowSize;
  }
  return this._buffer[pos];
};

LZ.OutWindow = OutWindow;
var CrcTable = (function() {
  var table = [];
  if (typeof(Uint32Array)!=='undefined') {
    table = new Uint32Array(256);
  }

  var kPoly = 0xEDB88320, i, j, r;
  for (i = 0; i < 256; i++) {
    r = i;
    for (j = 0; j < 8; j++) {
      if ((r & 1) !== 0) {
        r = (r >>> 1) ^ kPoly;
      } else {
        r >>>= 1;
      }
    }
    table[i] = r;
  }

  return table;
})();
//console.assert(CrcTable.length === 256);

// constants
var kHash2Size = 1 << 10, kHash3Size = 1 << 16, kBT2HashSize = 1 << 16;
var kStartMaxLen = 1, kHash3Offset = kHash2Size, kEmptyHashValue = 0;
var kMaxValForNormalize = (1 << 30) - 1;

function BinTree() {
  InWindow.call(this);
  this._cyclicBufferSize = 0;

  this._son = [];
  this._hash = [];

  this._cutValue = 0xFF;
  this._hashSizeSum = 0;

  this.HASH_ARRAY = true;

  this.kNumHashDirectBytes = 0;
  this.kMinMatchCheck = 4;
  this.kFixHashSize = kHash2Size + kHash3Size;

  if (arguments.length >= 6) {
    var args = Array.prototype.slice.call(arguments, 0);
    this.setType(args.shift());
    var stream = args.pop();
    this.create.apply(this, args);
    this.setStream(stream);
    this.init();
  }
}
// a little bit of sugar for super-method invocations.
var _super_ = InWindow.prototype;
BinTree.prototype = Object.create(_super_);

BinTree.prototype.setType = function(numHashBytes) {
  this.HASH_ARRAY = numHashBytes > 2;
  if (this.HASH_ARRAY) {
    this.kNumHashDirectBytes = 0;
    this.kMinMatchCheck = 4;
    this.kFixHashSize = kHash2Size + kHash3Size;
  } else {
    this.kNumHashDirectBytes = 2;
    this.kMinMatchCheck = 2 + 1;
    this.kFixHashSize = 0;
  }
};

BinTree.prototype.init = function() {
  var i;
  _super_.init.call(this);
  for (i = 0; i < this._hashSizeSum; i++) {
    this._hash[i] = kEmptyHashValue;
  }
  this._cyclicBufferPos = 0;
  this.reduceOffsets(-1);
};

BinTree.prototype.movePos = function() {
  if (++this._cyclicBufferPos >= this._cyclicBufferSize) {
    this._cyclicBufferPos = 0;
  }
  _super_.movePos.call(this);
  if (this._pos === kMaxValForNormalize) {
    this.normalize();
  }
};

BinTree.prototype.create = function(historySize, keepAddBufferBefore, matchMaxLen, keepAddBufferAfter) {
  var windowReservSize, cyclicBufferSize, hs;

  if (historySize > kMaxValForNormalize - 256) {
    //console.assert(false, 'Unsupported historySize');
    return false;
  }
  this._cutValue = 16 + (matchMaxLen >>> 1);

  windowReservSize = (historySize + keepAddBufferBefore +
                       matchMaxLen + keepAddBufferAfter) / 2 + 256;

  _super_.create.call(this, historySize + keepAddBufferBefore,
                      matchMaxLen + keepAddBufferAfter,
                      windowReservSize);

  this._matchMaxLen = matchMaxLen;

  cyclicBufferSize = historySize + 1;
  if (this._cyclicBufferSize !== cyclicBufferSize) {
    this._cyclicBufferSize = cyclicBufferSize;
    this._son = [];
    this._son.length = cyclicBufferSize * 2;
  }

  hs = kBT2HashSize;

  if (this.HASH_ARRAY) {
    hs = historySize - 1;
    hs |= hs >>> 1;
    hs |= hs >>> 2;
    hs |= hs >>> 4;
    hs |= hs >>> 8;
    hs >>>= 1;
    hs |= 0xFFFF;
    if (hs > (1 << 24)) {
      hs >>>= 1;
    }
    this._hashMask = hs;
    hs++;
    hs += this.kFixHashSize;
  }
  if (hs !== this._hashSizeSum) {
    this._hashSizeSum = hs;
    this._hash = [];
    this._hash.length = this._hashSizeSum;
  }
  return true;
};

BinTree.prototype.getMatches = function(distances) {
  var lenLimit;
  if (this._pos + this._matchMaxLen <= this._streamPos) {
    lenLimit = this._matchMaxLen;
  } else {
    lenLimit = this._streamPos - this._pos;
    if (lenLimit < this.kMinMatchCheck) {
      this.movePos();
      return 0;
    }
  }

  var offset = 0;
  var matchMinPos = (this._pos > this._cyclicBufferSize) ? (this._pos - this._cyclicBufferSize) : 0;
  var cur = this._bufferOffset + this._pos;
  var maxLen = kStartMaxLen; // to avoid items for len < hashSize
  var hashValue = 0, hash2Value = 0, hash3Value = 0;

  if (this.HASH_ARRAY) {
    var temp = CrcTable[this._bufferBase[cur]] ^ this._bufferBase[cur + 1];
    hash2Value = temp & (kHash2Size - 1);
    temp ^= this._bufferBase[cur + 2] << 8;
    hash3Value = temp & (kHash3Size - 1);
    hashValue = (temp ^ (CrcTable[this._bufferBase[cur + 3]] << 5)) & this._hashMask;
  } else {
    hashValue = this._bufferBase[cur] ^ (this._bufferBase[cur + 1] << 8);
  }

  var curMatch = this._hash[this.kFixHashSize + hashValue];
  if (this.HASH_ARRAY) {
    var curMatch2 = this._hash[hash2Value];
    var curMatch3 = this._hash[kHash3Offset + hash3Value];
    this._hash[hash2Value] = this._pos;
    this._hash[kHash3Offset + hash3Value] = this._pos;
    if (curMatch2 > matchMinPos) {
      if (this._bufferBase[this._bufferOffset + curMatch2] === this._bufferBase[cur]) {
        distances[offset++] = maxLen = 2;
        distances[offset++] = this._pos - curMatch2 - 1;
      }
    }
    if (curMatch3 > matchMinPos) {
      if (this._bufferBase[this._bufferOffset + curMatch3] === this._bufferBase[cur]) {
        if (curMatch3 === curMatch2) {
          offset -= 2;
        }
        distances[offset++] = maxLen = 3;
        distances[offset++] = this._pos - curMatch3 - 1;
        curMatch2 = curMatch3;
      }
    }
    if (offset !== 0 && curMatch2 === curMatch) {
      offset -= 2;
      maxLen = kStartMaxLen;
    }
  }

  this._hash[this.kFixHashSize + hashValue] = this._pos;

  var ptr0 = (this._cyclicBufferPos << 1) + 1;
  var ptr1 = (this._cyclicBufferPos << 1);

  var len0, len1;
  len0 = len1 = this.kNumHashDirectBytes;

  if (this.kNumHashDirectBytes !== 0) {
    if (curMatch > matchMinPos) {
      if (this._bufferBase[this._bufferOffset + curMatch + this.kNumHashDirectBytes] !==
          this._bufferBase[cur + this.kNumHashDirectBytes]) {
        distances[offset++] = maxLen = this.kNumHashDirectBytes;
        distances[offset++] = this._pos - curMatch - 1;
      }
    }
  }

  var count = this._cutValue;

  while (true) {
    if (curMatch <= matchMinPos || count-- === 0) {
      this._son[ptr0] = this._son[ptr1] = kEmptyHashValue;
      break;
    }

    var delta = this._pos - curMatch;
    var cyclicPos = ((delta <= this._cyclicBufferPos) ?
                 (this._cyclicBufferPos - delta) :
                 (this._cyclicBufferPos - delta + this._cyclicBufferSize)) << 1;

    var pby1 = this._bufferOffset + curMatch;
    var len = Math.min(len0, len1);
    if (this._bufferBase[pby1 + len] === this._bufferBase[cur + len]) {
      while (++len !== lenLimit) {
        if (this._bufferBase[pby1 + len] !== this._bufferBase[cur + len]) {
          break;
        }
      }
      if (maxLen < len) {
        distances[offset++] = maxLen = len;
        distances[offset++] = delta - 1;
        if (len === lenLimit) {
          this._son[ptr1] = this._son[cyclicPos];
          this._son[ptr0] = this._son[cyclicPos + 1];
          break;
        }
      }
    }
    if (this._bufferBase[pby1 + len] < this._bufferBase[cur + len]) {
      this._son[ptr1] = curMatch;
      ptr1 = cyclicPos + 1;
      curMatch = this._son[ptr1];
      len1 = len;
    } else {
      this._son[ptr0] = curMatch;
      ptr0 = cyclicPos;
      curMatch = this._son[ptr0];
      len0 = len;
    }
  }

  this.movePos();
  return offset;
};

BinTree.prototype.skip = function(num) {
  var lenLimit, matchMinPos, cur, curMatch, hashValue, hash2Value, hash3Value, temp;
  var ptr0, ptr1, len0, len1, count, delta, cyclicPos, pby1, len;
  do {
    if (this._pos + this._matchMaxLen <= this._streamPos) {
      lenLimit = this._matchMaxLen;
    } else {
      lenLimit = this._streamPos - this._pos;
      if (lenLimit < this.kMinMatchCheck) {
        this.movePos();
        continue;
      }
    }

    matchMinPos = this._pos > this._cyclicBufferSize ? (this._pos - this._cyclicBufferSize) : 0;
    cur = this._bufferOffset + this._pos;

    if (this.HASH_ARRAY) {
      temp = CrcTable[this._bufferBase[cur]] ^ this._bufferBase[cur + 1];
      hash2Value = temp & (kHash2Size - 1);
      this._hash[hash2Value] = this._pos;
      temp ^= this._bufferBase[cur + 2] << 8;
      hash3Value = temp & (kHash3Size - 1);
      this._hash[kHash3Offset + hash3Value] = this._pos;
      hashValue = (temp ^ (CrcTable[this._bufferBase[cur + 3]] << 5)) & this._hashMask;
    } else {
      hashValue = this._bufferBase[cur] ^ (this._bufferBase[cur + 1] << 8);
    }

    curMatch = this._hash[this.kFixHashSize + hashValue];
    this._hash[this.kFixHashSize + hashValue] = this._pos;

    ptr0 = (this._cyclicBufferPos << 1) + 1;
    ptr1 = (this._cyclicBufferPos << 1);

    len0 = len1 = this.kNumHashDirectBytes;

    count = this._cutValue;
    while (true) {
      if (curMatch <= matchMinPos || count-- === 0) {
        this._son[ptr0] = this._son[ptr1] = kEmptyHashValue;
        break;
      }

      delta = this._pos - curMatch;
      cyclicPos = (delta <= this._cyclicBufferPos ?
                   (this._cyclicBufferPos - delta) :
                   (this._cyclicBufferPos - delta + this._cyclicBufferSize)) << 1;

      pby1 = this._bufferOffset + curMatch;
      len = (len0 < len1) ? len0 : len1;
      if (this._bufferBase[pby1 + len] === this._bufferBase[cur + len]) {
        while (++len !== lenLimit) {
          if (this._bufferBase[pby1 + len] !== this._bufferBase[cur + len]) {
            break;
          }
        }
        if (len === lenLimit) {
          this._son[ptr1] = this._son[cyclicPos];
          this._son[ptr0] = this._son[cyclicPos + 1];
          break;
        }
      }
      if (this._bufferBase[pby1 + len] < this._bufferBase[cur + len]) {
        this._son[ptr1] = curMatch;
        ptr1 = cyclicPos + 1;
        curMatch = this._son[ptr1];
        len1 = len;
      } else {
        this._son[ptr0] = curMatch;
        ptr0 = cyclicPos;
        curMatch = this._son[ptr0];
        len0 = len;
      }
    }
    this.movePos();
  } while (--num !== 0);
};

BinTree.prototype.normalizeLinks = function(items, numItems, subValue) {
  var i, value;
  for (i = 0; i < numItems; i++) {
    value = items[i];
    if (value <= subValue) {
      value = kEmptyHashValue;
    } else {
      value -= subValue;
    }
    items[i] = value;
  }
};

BinTree.prototype.normalize = function() {
  var subValue = this._pos - this._cyclicBufferSize;
  this.normalizeLinks(this._son, this._cyclicBufferSize * 2, subValue);
  this.normalizeLinks(this._hash, this._hashSizeSum, subValue);
  this.reduceOffsets(subValue);
};

BinTree.prototype.setCutValue = function(cutValue) {
  this._cutValue = cutValue;
};

LZ.BinTree = BinTree;
}).call(this);
(function() {

  var Base = Object.create(null);
  Base.kNumRepDistances = 4;
  Base.kNumStates = 12;

  Base.stateInit = function() {
    return 0;
  };

  Base.stateUpdateChar = function(index) {
    if (index < 4) {
      return 0;
    }
    if (index < 10) {
      return index - 3;
    }
    return index - 6;
  };

  Base.stateUpdateMatch = function(index) {
    return (index < 7 ? 7 : 10);
  };

  Base.stateUpdateRep = function(index) {
    return (index < 7 ? 8 : 11);
  };

  Base.stateUpdateShortRep = function(index) {
    return (index < 7 ? 9 : 11);
  };

  Base.stateIsCharState = function(index) {
    return index < 7;
  };

  Base.kNumPosSlotBits = 6;
  Base.kDicLogSizeMin = 0;
  // Base.kDicLogSizeMax = 28;
  // Base.kDistTableSizeMax = Base.kDicLogSizeMax * 2;

  Base.kNumLenToPosStatesBits = 2; // it's for speed optimization
  Base.kNumLenToPosStates = 1 << Base.kNumLenToPosStatesBits;

  Base.kMatchMinLen = 2;

  Base.getLenToPosState = function(len) {
    len -= Base.kMatchMinLen;
    if (len < Base.kNumLenToPosStates) {
      return len;
    }
    return (Base.kNumLenToPosStates - 1);
  };

  Base.kNumAlignBits = 4;
  Base.kAlignTableSize = 1 << Base.kNumAlignBits;
  Base.kAlignMask = (Base.kAlignTableSize - 1);

  Base.kStartPosModelIndex = 4;
  Base.kEndPosModelIndex = 14;
  Base.kNumPosModels = Base.kEndPosModelIndex - Base.kStartPosModelIndex;

  Base.kNumFullDistances = 1 << (Base.kEndPosModelIndex / 2);

  Base.kNumLitPosStatesBitsEncodingMax = 4;
  Base.kNumLitContextBitsMax = 8;

  Base.kNumPosStatesBitsMax = 4;
  Base.kNumPosStatesMax = (1 << Base.kNumPosStatesBitsMax);
  Base.kNumPosStatesBitsEncodingMax = 4;
  Base.kNumPosStatesEncodingMax = (1 << Base.kNumPosStatesBitsEncodingMax);

  Base.kNumLowLenBits = 3;
  Base.kNumMidLenBits = 3;
  Base.kNumHighLenBits = 8;
  Base.kNumLowLenSymbols = 1 << Base.kNumLowLenBits;
  Base.kNumMidLenSymbols = 1 << Base.kNumMidLenBits;
  Base.kNumLenSymbols = Base.kNumLowLenSymbols + Base.kNumMidLenSymbols +
    (1 << Base.kNumHighLenBits);
  Base.kMatchMaxLen = Base.kMatchMinLen + Base.kNumLenSymbols - 1;

LZMA.Base = Base;
// shortcuts
var initBitModels = RangeCoder.Encoder.initBitModels;

// constants
var EMatchFinderTypeBT2 = 0;
var EMatchFinderTypeBT4 = 1;

var kInfinityPrice = 0xFFFFFFF;
var kDefaultDictionaryLogSize = 22;
var kNumFastBytesDefault = 0x20;

var kNumOpts = 1 << 12;

var kPropSize = 5;

var g_FastPos = (function() {
  var g_FastPos = makeBuffer(1 << 11);
  var kFastSlots = 22;
  var c = 2;
  var slotFast;
  g_FastPos[0] = 0;
  g_FastPos[1] = 1;
  for (slotFast = 2; slotFast < kFastSlots; slotFast++) {
    var j, k = 1 << ((slotFast >> 1) - 1);
    for (j = 0; j < k; j++,c++) {
      g_FastPos[c] = slotFast;
    }
  }
  return g_FastPos;
})();

var getPosSlot = function(pos) {
  if (pos < (1 << 11)) {
    return g_FastPos[pos];
  }
  if (pos < (1 << 21)) {
    return g_FastPos[pos >>> 10] + 20;
  }
  return g_FastPos[pos >>> 20] + 40;
};

var getPosSlot2 = function(pos) {
  if (pos < (1 << 17)) {
    return g_FastPos[pos >>> 6] + 12;
  }
  if (pos < (1 << 27)) {
    return g_FastPos[pos >>> 16] + 32;
  }
  return g_FastPos[pos >>> 26] + 52;
};

var Encoder = function() {
  var i;
  this._state = Base.stateInit();
  this._previousByte = 0;
  this._repDistances = []; // XXX use Uint32Array?
  this._repDistances.length = Base.kNumRepDistances;

  // these fields are defined much lower in the original Java source file
  this._optimum = [];
  this._matchFinder = null;
  this._rangeEncoder = new RangeCoder.Encoder();

  this._isMatch = initBitModels(null, Base.kNumStates << Base.kNumPosStatesBitsMax);
  this._isRep = initBitModels(null, Base.kNumStates);
  this._isRepG0 = initBitModels(null, Base.kNumStates);
  this._isRepG1 = initBitModels(null, Base.kNumStates);
  this._isRepG2 = initBitModels(null, Base.kNumStates);
  this._isRep0Long = initBitModels(null, Base.kNumStates << Base.kNumPosStatesBitsMax);

  this._posSlotEncoder = [];

  this._posEncoders = initBitModels(null, Base.kNumFullDistances-Base.kEndPosModelIndex);

  this._posAlignEncoder = new RangeCoder.BitTreeEncoder(Base.kNumAlignBits);

  this._lenEncoder = new Encoder.LenPriceTableEncoder();
  this._repMatchLenEncoder = new Encoder.LenPriceTableEncoder();

  this._literalEncoder = new Encoder.LiteralEncoder();

  this._matchDistances = [];
  this._matchDistances.length = Base.kMatchMaxLen*2 + 2;
  for (i=0; i < this._matchDistances.length; i++) {
      this._matchDistances[i] = 0;
  }

  this._numFastBytes = kNumFastBytesDefault;
  this._longestMatchLength = 0;
  this._numDistancePairs = 0;

  this._additionalOffset = 0;
  this._optimumEndIndex = 0;
  this._optimumCurrentIndex = 0;

  this._longestMatchWasFound = false;

  this._posSlotPrices = [];
  this._distancesPrices = [];
  this._alignPrices = [];
  this._alignPriceCount = 0;

  this._distTableSize = kDefaultDictionaryLogSize * 2;

  this._posStateBits = 2;
  this._posStateMask = 4 - 1;
  this._numLiteralPosStateBits = 0;
  this._numLiteralContextBits = 3;

  this._dictionarySize = (1 << kDefaultDictionaryLogSize);
  this._dictionarySizePrev = 0xFFFFFFFF;
  this._numFastBytesPrev = 0xFFFFFFFF;

  // note that this is a 53-bit variable, not 64-bit.  This sets the maximum
  // encoded file size.
  this.nowPos64 = 0;
  this._finished = false;
  this._inStream = null;

  this._matchFinderType = EMatchFinderTypeBT4;
  this._writeEndMark = false;
  this._needReleaseMFStream = false;

  // ...and even further down we find these:
  this.reps = [];
  this.repLens = [];
  this.backRes = 0;

  // ...keep going, eventually we find the constructor:
  for (i = 0; i < kNumOpts; i++) {
    this._optimum[i] = new Encoder.Optimal();
  }
  for (i = 0; i < Base.kNumLenToPosStates; i++) {
    this._posSlotEncoder[i] = new RangeCoder.BitTreeEncoder(Base.kNumPosSlotBits);
  }

  this._matchPriceCount = 0;

  // ...and just above the 'Code' method, we find:
  this.processedInSize = [0];
  this.processedOutSize = [0];
  this.finished = [false];
};
Encoder.prototype.baseInit = function() {
  var i;
  this._state = Base.stateInit();
  this._previousByte = 0;
  for (i = 0; i < Base.kNumRepDistances; i++) {
    this._repDistances[i] = 0;
  }
};

var LiteralEncoder = Encoder.LiteralEncoder = function() {
  this._coders = null;
  this._numPrevBits = -1;
  this._numPosBits = -1;
  this._posMask = 0;
};

LiteralEncoder.Encoder2 = function() {
  this._encoders = initBitModels(null, 0x300);
};

LiteralEncoder.Encoder2.prototype.init = function() {
  initBitModels(this._encoders);
};

LiteralEncoder.Encoder2.prototype.encode = function(rangeEncoder, symbol) {
  var context = 1, i;
  for (i = 7; i >= 0; i--) {
    var bit = (symbol >>> i) & 1;
    rangeEncoder.encode(this._encoders, context, bit);
    context = (context << 1) | bit;
  }
};

LiteralEncoder.Encoder2.prototype.encodeMatched = function(rangeEncoder, matchByte, symbol) {
  var context = 1, same = true, i;
  for (i = 7; i>= 0; i--) {
    var bit = (symbol >> i) & 1;
    var state = context;
    if (same) {
      var matchBit = (matchByte >>> i) & 1;
      state += (1 + matchBit) << 8;
      same = (matchBit === bit);
    }
    rangeEncoder.encode(this._encoders, state, bit);
    context = (context << 1) | bit;
  }
};

LiteralEncoder.Encoder2.prototype.getPrice = function(matchMode, matchByte, symbol) {
  var price = 0;
  var context = 1;
  var i = 7;
  var bit, matchBit;
  if (matchMode) {
    for (; i >= 0; i--) {
      matchBit = (matchByte >>> i) & 1;
      bit = (symbol >>> i) & 1;
      price += RangeCoder.Encoder.getPrice(this._encoders[((1 + matchBit) << 8) + context], bit);
      context = (context << 1) | bit;
      if (matchBit !== bit) {
        i--;
        break;
      }
    }
  }
  for (; i >= 0; i--) {
    bit = (symbol >>> i) & 1;
    price += RangeCoder.Encoder.getPrice(this._encoders[context], bit);
    context = (context << 1) | bit;
  }
  return price;
};

LiteralEncoder.prototype.create = function(numPosBits, numPrevBits) {
  var i;
  if (this._coders &&
      this._numPrevBits === numPrevBits &&
      this._numPosBits === numPosBits) {
    return;
  }

  this._numPosBits = numPosBits;
  this._posMask = (1 << numPosBits) - 1;
  this._numPrevBits = numPrevBits;
  var numStates = 1 << (this._numPrevBits + this._numPosBits);
  this._coders = [];
  for (i = 0; i < numStates; i++) {
    this._coders[i] = new LiteralEncoder.Encoder2();
  }
};

LiteralEncoder.prototype.init = function() {
  var numStates = 1 << (this._numPrevBits + this._numPosBits), i;
  for (i = 0; i < numStates; i++) {
    this._coders[i].init();
  }
};

LiteralEncoder.prototype.getSubCoder = function(pos, prevByte) {
  return this._coders[((pos & this._posMask) << this._numPrevBits) + (prevByte >> (8 - this._numPrevBits))];
};

var LenEncoder = Encoder.LenEncoder = function() {
  var posState;
  this._choice = initBitModels(null, 2);
  this._lowCoder = [];
  this._midCoder = [];
  this._highCoder = new RangeCoder.BitTreeEncoder(Base.kNumHighLenBits);

  for (posState = 0; posState < Base.kNumPosStatesEncodingMax; posState++) {
    this._lowCoder[posState] = new RangeCoder.BitTreeEncoder(Base.kNumLowLenBits);
    this._midCoder[posState] = new RangeCoder.BitTreeEncoder(Base.kNumMidLenBits);
  }
};

LenEncoder.prototype.init = function(numPosStates) {
  var posState;
  initBitModels(this._choice);
  for (posState = 0; posState < numPosStates; posState++) {
    this._lowCoder[posState].init();
    this._midCoder[posState].init();
  }
  this._highCoder.init();
};

LenEncoder.prototype.encode = function(rangeEncoder, symbol, posState) {
  if (symbol < Base.kNumLowLenSymbols) {
    rangeEncoder.encode(this._choice, 0, 0);
    this._lowCoder[posState].encode(rangeEncoder, symbol);
  } else {
    symbol -= Base.kNumLowLenSymbols;
    rangeEncoder.encode(this._choice, 0, 1);
    if (symbol < Base.kNumMidLenSymbols) {
      rangeEncoder.encode(this._choice, 1, 0);
      this._midCoder[posState].encode(rangeEncoder, symbol);
    } else {
      rangeEncoder.encode(this._choice, 1, 1);
      this._highCoder.encode(rangeEncoder, symbol - Base.kNumMidLenSymbols);
    }
  }
};

LenEncoder.prototype.setPrices = function(posState, numSymbols, prices, st) {
  var a0 = RangeCoder.Encoder.getPrice0(this._choice[0]);
  var a1 = RangeCoder.Encoder.getPrice1(this._choice[0]);
  var b0 = a1 + RangeCoder.Encoder.getPrice0(this._choice[1]);
  var b1 = a1 + RangeCoder.Encoder.getPrice1(this._choice[1]);
  var i;
  for (i = 0; i < Base.kNumLowLenSymbols; i++) {
    if (i >= numSymbols) {
      return;
    }
    prices[st + i] = a0 + this._lowCoder[posState].getPrice(i);
  }
  for (; i < Base.kNumLowLenSymbols + Base.kNumMidLenSymbols; i++) {
    if (i >= numSymbols) {
      return;
    }
    prices[st + i] = b0 + this._midCoder[posState].getPrice(i - Base.kNumLowLenSymbols);
  }
  for (; i < numSymbols; i++) {
    prices[st + i] = b1 + this._highCoder.getPrice(i - Base.kNumLowLenSymbols - Base.kNumMidLenSymbols);
  }
};

var kNumLenSpecSymbols = Base.kNumLowLenSymbols + Base.kNumMidLenSymbols;

var LenPriceTableEncoder = Encoder.LenPriceTableEncoder = function() {
  LenEncoder.call(this); // superclass constructor
  this._prices = [];
  this._counters = [];
  this._tableSize = 0;
};
LenPriceTableEncoder.prototype = Object.create(LenEncoder.prototype);
LenPriceTableEncoder.prototype.setTableSize = function(tableSize) {
  this._tableSize = tableSize;
};
LenPriceTableEncoder.prototype.getPrice = function(symbol, posState) {
  return this._prices[posState * Base.kNumLenSymbols + symbol];
};
LenPriceTableEncoder.prototype.updateTable = function(posState) {
  this.setPrices(posState, this._tableSize, this._prices,
                 posState * Base.kNumLenSymbols);
  this._counters[posState] = this._tableSize;
};
LenPriceTableEncoder.prototype.updateTables = function(numPosStates) {
  var posState;
  for (posState = 0; posState < numPosStates; posState++) {
    this.updateTable(posState);
  }
};
LenPriceTableEncoder.prototype.encode = (function(superEncode) {
  return function(rangeEncoder, symbol, posState) {
    superEncode.call(this, rangeEncoder, symbol, posState);
    if (--this._counters[posState] === 0) {
      this.updateTable(posState);
    }
  };
})(LenPriceTableEncoder.prototype.encode);

var Optimal = Encoder.Optimal = function() {
  this.state = 0;

  this.prev1IsChar = false;
  this.prev2 = false;

  this.posPrev2 = 0;
  this.backPrev2 = 0;

  this.price = 0;
  this.posPrev = 0;
  this.backPrev = 0;

  this.backs0 = 0;
  this.backs1 = 0;
  this.backs2 = 0;
  this.backs3 = 0;
};
Optimal.prototype.makeAsChar = function() {
  this.backPrev = -1;
  this.prev1IsChar = false;
};
Optimal.prototype.makeAsShortRep = function() {
  this.backPrev = 0;
  this.prev1IsChar= false;
};
Optimal.prototype.isShortRep = function() {
  return this.backPrev === 0;
};

// back to the Encoder class!
Encoder.prototype.create = function() {
  var numHashBytes;
  if (!this._matchFinder) {
    var bt = new LZ.BinTree();
    numHashBytes = 4;
    if (this._matchFinderType === EMatchFinderTypeBT2) {
      numHashBytes = 2;
    }
    bt.setType(numHashBytes);
    this._matchFinder = bt;
  }
  this._literalEncoder.create(this._numLiteralPosStateBits,
                              this._numLiteralContextBits);

  if (this._dictionarySize === this._dictionarySizePrev &&
      this._numFastBytesPrev === this._numFastBytes) {
    return;
  }
  this._matchFinder.create(this._dictionarySize, kNumOpts, this._numFastBytes,
                           Base.kMatchMaxLen + 1);
  this._dictionarySizePrev = this._dictionarySize;
  this._numFastBytesPrev = this._numFastBytes;
};

Encoder.prototype.setWriteEndMarkerMode = function(writeEndMarker) {
  this._writeEndMark = writeEndMarker;
};

Encoder.prototype.init = function() {
  var i;
  this.baseInit();
  this._rangeEncoder.init();

  initBitModels(this._isMatch);
  initBitModels(this._isRep0Long);
  initBitModels(this._isRep);
  initBitModels(this._isRepG0);
  initBitModels(this._isRepG1);
  initBitModels(this._isRepG2);
  initBitModels(this._posEncoders);

  this._literalEncoder.init();
  for (i = 0; i < Base.kNumLenToPosStates; i++) {
    this._posSlotEncoder[i].init();
  }

  this._lenEncoder.init(1 << this._posStateBits);
  this._repMatchLenEncoder.init(1 << this._posStateBits);

  this._posAlignEncoder.init();

  this._longestMatchWasFound = false;
  this._optimumEndIndex = 0;
  this._optimumCurrentIndex = 0;
  this._additionalOffset = 0;
};

Encoder.prototype.readMatchDistances = function() {
  var lenRes = 0;
  this._numDistancePairs = this._matchFinder.getMatches(this._matchDistances);
  if (this._numDistancePairs > 0) {
    lenRes = this._matchDistances[this._numDistancePairs - 2];
    if (lenRes === this._numFastBytes) {
      lenRes += this._matchFinder.getMatchLen(lenRes - 1, this._matchDistances[this._numDistancePairs - 1], Base.kMatchMaxLen - lenRes);
    }
  }
  this._additionalOffset++;
  // [csa] Gary Linscott thinks that numDistancePairs should be a retval here.
  return lenRes;
};

Encoder.prototype.movePos = function(num) {
  if (num > 0) {
    this._matchFinder.skip(num);
    this._additionalOffset += num;
  }
};

Encoder.prototype.getRepLen1Price = function(state, posState) {
  return RangeCoder.Encoder.getPrice0(this._isRepG0[state]) +
    RangeCoder.Encoder.getPrice0(this._isRep0Long[(state << Base.kNumPosStatesBitsMax) + posState]);
};

Encoder.prototype.getPureRepPrice = function(repIndex, state, posState) {
  var price;
  if (repIndex === 0) {
    price = RangeCoder.Encoder.getPrice0(this._isRepG0[state]);
    price += RangeCoder.Encoder.getPrice1(this._isRep0Long[(state << Base.kNumPosStatesBitsMax) + posState]);
  } else {
    price = RangeCoder.Encoder.getPrice1(this._isRepG0[state]);
    if (repIndex === 1) {
      price += RangeCoder.Encoder.getPrice0(this._isRepG1[state]);
    } else {
      price += RangeCoder.Encoder.getPrice1(this._isRepG1[state]);
      price += RangeCoder.Encoder.getPrice(this._isRepG2[state], repIndex - 2);
    }
  }
  return price;
};

Encoder.prototype.getRepPrice = function(repIndex, len, state, posState) {
  var price = this._repMatchLenEncoder.getPrice(len - Base.kMatchMinLen, posState);
  return price + this.getPureRepPrice(repIndex, state, posState);
};

Encoder.prototype.getPosLenPrice = function(pos, len, posState) {
  var price;
  var lenToPosState = Base.getLenToPosState(len);
  if (pos < Base.kNumFullDistances) {
    price = this._distancesPrices[(lenToPosState * Base.kNumFullDistances) + pos];
  } else {
    price = this._posSlotPrices[(lenToPosState << Base.kNumPosSlotBits) + getPosSlot2(pos)] + this._alignPrices[pos & Base.kAlignMask];
  }
  return price + this._lenEncoder.getPrice(len - Base.kMatchMinLen, posState);
};

Encoder.prototype.backward = function(cur) {
  this._optimumEndIndex = cur;
  var posMem = this._optimum[cur].posPrev;
  var backMem = this._optimum[cur].backPrev;
  do {
    if (this._optimum[cur].prev1IsChar) {
      this._optimum[posMem].makeAsChar();
      this._optimum[posMem].posPrev = posMem - 1;
      if (this._optimum[cur].prev2) {
        this._optimum[posMem - 1].prev1IsChar = false;
        this._optimum[posMem - 1].posPrev = this._optimum[cur].posPrev2;
        this._optimum[posMem - 1].backPrev = this._optimum[cur].backPrev2;
      }
    }
    var posPrev = posMem;
    var backCur = backMem;

    backMem = this._optimum[posPrev].backPrev;
    posMem = this._optimum[posPrev].posPrev;

    this._optimum[posPrev].backPrev = backCur;
    this._optimum[posPrev].posPrev = cur;
    cur = posPrev;
  } while (cur > 0);

  this.backRes = this._optimum[0].backPrev;
  this._optimumCurrentIndex = this._optimum[0].posPrev;
  // [csa] Gary Linscott thinks that backRes should be a retval here.
  return this._optimumCurrentIndex;
};

Encoder.prototype.getOptimum = function(position) {

  if (this._optimumEndIndex !== this._optimumCurrentIndex) {
    var lenRes = this._optimum[this._optimumCurrentIndex].posPrev - this._optimumCurrentIndex;
    this.backRes = this._optimum[this._optimumCurrentIndex].backPrev;
    this._optimumCurrentIndex = this._optimum[this._optimumCurrentIndex].posPrev;
    // [csa] Gary Linscott thinks that backRes should be a retval here.
    return lenRes;
  }
  this._optimumCurrentIndex = this._optimumEndIndex = 0;

  var lenMain;
  if (!this._longestMatchWasFound) {
    lenMain = this.readMatchDistances();
  } else {
    lenMain = this._longestMatchLength;
    this._longestMatchWasFound = false;
  }
  var numDistancePairs = this._numDistancePairs;

  var numAvailableBytes = this._matchFinder.getNumAvailableBytes() + 1;
  if (numAvailableBytes < 2) {
    this.backRes = -1;
    // [csa] Gary Linscott thinks that backRes should be a retval here.
    return 1;
  }
  if (numAvailableBytes > Base.kMatchMaxLen) {
    numAvailableBytes = Base.kMatchMaxLen;
  }

  var repMaxIndex = 0, i;
  for (i = 0; i < Base.kNumRepDistances; i++) {
    this.reps[i] = this._repDistances[i];
    this.repLens[i] = this._matchFinder.getMatchLen(-1, this.reps[i], Base.kMatchMaxLen);
    if (this.repLens[i] > this.repLens[repMaxIndex]) {
      repMaxIndex = i;
    }
  }
  if (this.repLens[repMaxIndex] >= this._numFastBytes) {
    this.backRes = repMaxIndex;
    var lenRes2 = this.repLens[repMaxIndex];
    this.movePos(lenRes2 - 1);
    // [csa] Gary Linscott thinks that backRes should be a retval here.
    return lenRes2;
  }

  if (lenMain >= this._numFastBytes) {
    // [csa] Gary Linscott thinks that backRes should be a retval here.
    this.backRes = this._matchDistances[numDistancePairs - 1] + Base.kNumRepDistances;
    this.movePos(lenMain - 1);
    return lenMain;
  }

  var currentByte = this._matchFinder.getIndexByte(-1);
  var matchByte = this._matchFinder.getIndexByte(-this._repDistances[0] - 2);

  if (lenMain < 2 && currentByte !== matchByte && this.repLens[repMaxIndex] < 2) {
    // [csa] Gary Linscott thinks that backRes should be a retval here.
    this.backRes = -1;
    return 1;
  }

  this._optimum[0].state = this._state;

  var posState = position & this._posStateMask;

  this._optimum[1].price = RangeCoder.Encoder.getPrice0(this._isMatch[(this._state << Base.kNumPosStatesBitsMax) + posState]) +
    this._literalEncoder.getSubCoder(position, this._previousByte).getPrice(!Base.stateIsCharState(this._state), matchByte, currentByte);
  this._optimum[1].makeAsChar();

  var matchPrice = RangeCoder.Encoder.getPrice1(this._isMatch[(this._state << Base.kNumPosStatesBitsMax) + posState]);
  var repMatchPrice = matchPrice + RangeCoder.Encoder.getPrice1(this._isRep[this._state]);

  if (matchByte === currentByte) {
    var shortRepPrice = repMatchPrice + this.getRepLen1Price(this._state, posState);
    if (shortRepPrice < this._optimum[1].price) {
      this._optimum[1].price = shortRepPrice;
      this._optimum[1].makeAsShortRep();
    }
  }

  var lenEnd = (lenMain >= this.repLens[repMaxIndex]) ?
    lenMain : this.repLens[repMaxIndex];
  if (lenEnd < 2) {
    // [csa] Gary Linscott thinks that backRes should be a retval here.
    this.backRes = this._optimum[1].backPrev;
    return 1;
  }

  this._optimum[1].posPrev = 0;

  this._optimum[0].backs0 = this.reps[0];
  this._optimum[0].backs1 = this.reps[1];
  this._optimum[0].backs2 = this.reps[2];
  this._optimum[0].backs3 = this.reps[3];

  var len = lenEnd;
  do {
    this._optimum[len--].price = kInfinityPrice;
  } while (len >= 2);

  for (i = 0; i < Base.kNumRepDistances; i++) {
    var repLen = this.repLens[i];
    if (repLen < 2) {
      continue;
    }
    var price = repMatchPrice + this.getPureRepPrice(i, this._state, posState);
    do {
      var curAndLenPrice = price +
        this._repMatchLenEncoder.getPrice(repLen - 2, posState);
      var optimum = this._optimum[repLen];
      if (curAndLenPrice < optimum.price) {
        optimum.price = curAndLenPrice;
        optimum.posPrev = 0;
        optimum.backPrev = i;
        optimum.prev1IsChar = false;
      }
    } while (--repLen >= 2);
  }

  var normalMatchPrice = matchPrice +
    RangeCoder.Encoder.getPrice0(this._isRep[this._state]);

  len = this.repLens[0] >= 2 ? this.repLens[0] + 1 : 2;
  if (len <= lenMain) {
    var offs = 0;
    while (len > this._matchDistances[offs]) {
      offs += 2;
    }
    for (;; len++) {
      var distance = this._matchDistances[offs + 1];
      var curAndLenPrice2 = normalMatchPrice +
        this.getPosLenPrice(distance, len, posState);
      var optimum2 = this._optimum[len];
      if (curAndLenPrice2 < optimum2.price) {
        optimum2.price = curAndLenPrice2;
        optimum2.posPrev = 0;
        optimum2.backPrev = distance + Base.kNumRepDistances;
        optimum2.prev1IsChar = false;
      }
      if (len === this._matchDistances[offs]) {
        offs += 2;
        if (offs === numDistancePairs) {
          break;
        }
      }
    }
  }

  var cur = 0;
  while (true) {
    cur++;
    if (cur === lenEnd) {
      return this.backward(cur);
    }
    var newLen = this.readMatchDistances();
    numDistancePairs = this._numDistancePairs;
    if (newLen >= this._numFastBytes) {
      this._longestMatchLength = newLen;
      this._longestMatchWasFound = true;
      return this.backward(cur);
    }
    position++;
    var posPrev = this._optimum[cur].posPrev;
    var state;
    if (this._optimum[cur].prev1IsChar) {
      posPrev--;
      if (this._optimum[cur].prev2) {
        state = this._optimum[this._optimum[cur].posPrev2].state;
        if (this._optimum[cur].backPrev2 < Base.kNumRepDistances) {
          state = Base.stateUpdateRep(state);
        } else {
          state = Base.stateUpdateMatch(state);
        }
      } else {
        state = this._optimum[posPrev].state;
      }
      state = Base.stateUpdateChar(state);
    } else {
      state = this._optimum[posPrev].state;
    }
    if (posPrev === cur - 1) {
      if (this._optimum[cur].isShortRep()) {
        state = Base.stateUpdateShortRep(state);
      } else {
        state = Base.stateUpdateChar(state);
      }
    } else {
      var pos;
      if (this._optimum[cur].prev1IsChar && this._optimum[cur].prev2) {
        posPrev = this._optimum[cur].posPrev2;
        pos = this._optimum[cur].backPrev2;
        state = Base.stateUpdateRep(state);
      } else {
        pos = this._optimum[cur].backPrev;
        if (pos < Base.kNumRepDistances) {
          state = Base.stateUpdateRep(state);
        } else {
          state = Base.stateUpdateMatch(state);
        }
      }

      var opt = this._optimum[posPrev];
      if (pos < Base.kNumRepDistances) {
        if (pos === 0) {
          this.reps[0] = opt.backs0;
          this.reps[1] = opt.backs1;
          this.reps[2] = opt.backs2;
          this.reps[3] = opt.backs3;
        } else if (pos === 1) {
          this.reps[0] = opt.backs1;
          this.reps[1] = opt.backs0;
          this.reps[2] = opt.backs2;
          this.reps[3] = opt.backs3;
        } else if (pos === 2) {
          this.reps[0] = opt.backs2;
          this.reps[1] = opt.backs0;
          this.reps[2] = opt.backs1;
          this.reps[3] = opt.backs3;
        } else {
          this.reps[0] = opt.backs3;
          this.reps[1] = opt.backs0;
          this.reps[2] = opt.backs1;
          this.reps[3] = opt.backs2;
        }
      } else {
        this.reps[0] = pos - Base.kNumRepDistances;
        this.reps[1] = opt.backs0;
        this.reps[2] = opt.backs1;
        this.reps[3] = opt.backs2;
      }
    }
    this._optimum[cur].state = state;
    this._optimum[cur].backs0 = this.reps[0];
    this._optimum[cur].backs1 = this.reps[1];
    this._optimum[cur].backs2 = this.reps[2];
    this._optimum[cur].backs3 = this.reps[3];
    var curPrice = this._optimum[cur].price;

    currentByte = this._matchFinder.getIndexByte(-1);
    matchByte = this._matchFinder.getIndexByte(-this.reps[0] - 2);
    posState = position & this._posStateMask;

    var curAnd1Price = curPrice +
      RangeCoder.Encoder.getPrice0(this._isMatch[(state << Base.kNumPosStatesBitsMax) + posState]) +
      this._literalEncoder.getSubCoder(position, this._matchFinder.getIndexByte(-2)).
      getPrice(!Base.stateIsCharState(state), matchByte, currentByte);

    var nextOptimum = this._optimum[cur + 1];

    var nextIsChar = false;
    if (curAnd1Price < nextOptimum.price) {
      nextOptimum.price = curAnd1Price;
      nextOptimum.posPrev = cur;
      nextOptimum.makeAsChar();
      nextIsChar = true;
    }

    matchPrice = curPrice + RangeCoder.Encoder.getPrice1(this._isMatch[(state << Base.kNumPosStatesBitsMax) + posState]);
    repMatchPrice = matchPrice + RangeCoder.Encoder.getPrice1(this._isRep[state]);

    if (matchByte === currentByte &&
        !(nextOptimum.posPrev < cur && nextOptimum.backPrev === 0)) {
      var shortRepPrice2 =
        repMatchPrice + this.getRepLen1Price(state, posState);
      if (shortRepPrice2 <= nextOptimum.price) {
        nextOptimum.price = shortRepPrice2;
        nextOptimum.posPrev = cur;
        nextOptimum.makeAsShortRep();
        nextIsChar = true;
      }
    }

    var numAvailableBytesFull = this._matchFinder.getNumAvailableBytes() + 1;
    numAvailableBytesFull = Math.min(kNumOpts - 1 - cur, numAvailableBytesFull);
    numAvailableBytes = numAvailableBytesFull;

    if (numAvailableBytes < 2) {
      continue;
    }
    if (numAvailableBytes > this._numFastBytes) {
      numAvailableBytes = this._numFastBytes;
    }
    if (!nextIsChar && matchByte !== currentByte) {
      // Try Literal + rep0
      var t = Math.min(numAvailableBytesFull - 1, this._numFastBytes);
      var lenTest2 = this._matchFinder.getMatchLen(0, this.reps[0], t);
      if (lenTest2 >= 2) {
        var state2 = Base.stateUpdateChar(state);

        var posStateNext = (position + 1) & this._posStateMask;
        var nextRepMatchPrice = curAnd1Price +
          RangeCoder.Encoder.getPrice1(this._isMatch[(state2 << Base.kNumPosStatesBitsMax) + posStateNext]) +
          RangeCoder.Encoder.getPrice1(this._isRep[state2]);

        var offset = cur + 1 + lenTest2;
        while (lenEnd < offset) {
          this._optimum[++lenEnd].price = kInfinityPrice;
        }
        var curAndLenPrice3 = nextRepMatchPrice + this.getRepPrice(0, lenTest2, state2, posStateNext);
        var optimum3 = this._optimum[offset];
        if (curAndLenPrice3 < optimum3.price) {
          optimum3.price = curAndLenPrice3;
          optimum3.posPrev = cur + 1;
          optimum3.backPrev = 0;
          optimum3.prev1IsChar = true;
          optimum3.prev2 = false;
        }
      }
    }

    var startLen = 2;	// Speed optimization

    var repIndex;
    for (repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++) {
      var lenTest = this._matchFinder.getMatchLen(-1, this.reps[repIndex], numAvailableBytes);
      if (lenTest < 2) {
        continue;
      }
      var lenTestTemp = lenTest;
      do {
        while (lenEnd < cur + lenTest) {
          this._optimum[++lenEnd].price = kInfinityPrice;
        }
        var curAndLenPrice4 = repMatchPrice + this.getRepPrice(repIndex, lenTest, state, posState);
        var optimum4 = this._optimum[cur + lenTest];
        if (curAndLenPrice4 < optimum4.price) {
          optimum4.price = curAndLenPrice4;
          optimum4.posPrev = cur;
          optimum4.backPrev = repIndex;
          optimum4.prev1IsChar = false;
        }
      } while (--lenTest >= 2);
      lenTest = lenTestTemp;

      if (repIndex === 0) {
        startLen = lenTest + 1;
      }

      // if (_maxMode)
      if (lenTest < numAvailableBytesFull) {
        var t5 = Math.min(numAvailableBytesFull - 1 - lenTest, this._numFastBytes);
        var lenTest25 = this._matchFinder.getMatchLen(lenTest, this.reps[repIndex], t5);
        if (lenTest25 >= 2) {
          var state25 = Base.stateUpdateRep(state);
          var posStateNext5 = (position + lenTest) & this._posStateMask;
          var curAndLenCharPrice = repMatchPrice +
            this.getRepPrice(repIndex, lenTest, state, posState) +
            RangeCoder.Encoder.getPrice0(this._isMatch[(state25 << Base.kNumPosStatesBitsMax) + posStateNext5]) +
            this._literalEncoder.getSubCoder(position + lenTest,
                                             this._matchFinder.getIndexByte(lenTest - 2)).
            getPrice(true,
                     this._matchFinder.getIndexByte(lenTest - 1 - (this.reps[repIndex] + 1)),
                     this._matchFinder.getIndexByte(lenTest - 1));

          state25 = Base.stateUpdateChar(state25);
          posStateNext5 = (position + lenTest + 1) & this._posStateMask;
          var nextMatchPrice5 = curAndLenCharPrice +
            RangeCoder.Encoder.getPrice1(this._isMatch[(state25 << Base.kNumPosStatesBitsMax) + posStateNext5]);
          var nextRepMatchPrice5 = nextMatchPrice5 +
            RangeCoder.Encoder.getPrice1(this._isRep[state25]);

          // for(; lenTest2 >= 2; lenTest2--) {
          var offset5 = lenTest + 1 + lenTest25;
          while (lenEnd < cur + offset5) {
            this._optimum[++lenEnd].price = kInfinityPrice;
          }
          var curAndLenPrice5 = nextRepMatchPrice5 +
            this.getRepPrice(0, lenTest25, state25, posStateNext5);
          var optimum5 = this._optimum[cur + offset5];
          if (curAndLenPrice5 < optimum5.price) {
            optimum5.price = curAndLenPrice5;
            optimum5.posPrev = cur + lenTest + 1;
            optimum5.backPrev = 0;
            optimum5.prev1IsChar = true;
            optimum5.prev2 = true;
            optimum5.posPrev2 = cur;
            optimum5.backPrev2 = repIndex;
          }
        }
      }
    }

    if (newLen > numAvailableBytes) {
      newLen = numAvailableBytes;
      numDistancePairs = 0;
      while(newLen > this._matchDistances[numDistancePairs]) {
        numDistancePairs += 2;
      }
      this._matchDistances[numDistancePairs] = newLen;
      numDistancePairs += 2;
    }
    if (newLen >= startLen) {
      normalMatchPrice = matchPrice +
        RangeCoder.Encoder.getPrice0(this._isRep[state]);
      while (lenEnd < cur + newLen) {
        this._optimum[++lenEnd].price = kInfinityPrice;
      }

      var offs6 = 0;
      while (startLen > this._matchDistances[offs6]) {
        offs6 += 2;
      }

      var lenTest6;
      for (lenTest6 = startLen; ; lenTest6++) {
        var curBack = this._matchDistances[offs6 + 1];
        var curAndLenPrice6 = normalMatchPrice +
          this.getPosLenPrice(curBack, lenTest6, posState);
        var optimum6 = this._optimum[cur + lenTest6];
        if (curAndLenPrice6 < optimum6.price) {
          optimum6.price = curAndLenPrice6;
          optimum6.posPrev = cur;
          optimum6.backPrev = curBack + Base.kNumRepDistances;
          optimum6.prev1IsChar = false;
        }

        if (lenTest6 === this._matchDistances[offs6]) {
          if (lenTest6 < numAvailableBytesFull) {
            var t7 = Math.min(numAvailableBytesFull - 1 - lenTest6,
                              this._numFastBytes);
            var lenTest27 = this._matchFinder.getMatchLen(lenTest6, curBack, t7);
            if (lenTest27 >= 2) {
              var state27 = Base.stateUpdateMatch(state);

              var posStateNext7 = (position + lenTest6) & this._posStateMask;
              var curAndLenCharPrice7 = curAndLenPrice6 +
                RangeCoder.Encoder.getPrice0(this._isMatch[(state27 << Base.kNumPosStatesBitsMax) + posStateNext7]) +
                this._literalEncoder.getSubCoder(position + lenTest6,
                                                 this._matchFinder.getIndexByte(lenTest6 - 2)).
                getPrice(true,
                         this._matchFinder.getIndexByte(lenTest6 - (curBack + 1) -1),
                         this._matchFinder.getIndexByte(lenTest6 - 1));
              state27 = Base.stateUpdateChar(state27);
              posStateNext7 = (position + lenTest6 + 1) & this._posStateMask;
              var nextMatchPrice7 = curAndLenCharPrice7 +
                RangeCoder.Encoder.getPrice1(this._isMatch[(state27 << Base.kNumPosStatesBitsMax) + posStateNext7]);
              var nextRepMatchPrice7 = nextMatchPrice7 +
                RangeCoder.Encoder.getPrice1(this._isRep[state27]);

              var offset7 = lenTest6 + 1 + lenTest27;
              while (lenEnd < cur + offset7) {
                this._optimum[++lenEnd].price = kInfinityPrice;
              }
              var curAndLenPrice7 = nextRepMatchPrice7 +
                this.getRepPrice(0, lenTest27, state27, posStateNext7);
              var optimum7 = this._optimum[cur + offset7];
              if (curAndLenPrice7 < optimum7.price) {
                optimum7.price = curAndLenPrice7;
                optimum7.posPrev = cur + lenTest6 + 1;
                optimum7.backPrev = 0;
                optimum7.prev1IsChar = true;
                optimum7.prev2 = true;
                optimum7.posPrev2 = cur;
                optimum7.backPrev2 = curBack + Base.kNumRepDistances;
              }
            }
          }
          offs6 += 2;
          if (offs6 === numDistancePairs) {
            break;
          }
        }
      }
    }
  }
};

Encoder.prototype.changePair = function(smallDist, bigDist) {
  var kDif = 7;
  return (smallDist < (1 << (32 - kDif)) && bigDist >= (smallDist << kDif));
};

Encoder.prototype.writeEndMarker = function(posState) {
  if (!this._writeEndMark) {
    return;
  }

  this._rangeEncoder.encode(this._isMatch, (this._state << Base.kNumPosStatesBitsMax) + posState, 1);
  this._rangeEncoder.encode(this._isRep, this._state, 0);
  this._state = Base.stateUpdateMatch(this._state);
  var len = Base.kMatchMinLen;
  this._lenEncoder.encode(this._rangeEncoder, len - Base.kMatchMinLen, posState);
  var posSlot = (1 << Base.kNumPosSlotBits) - 1;
  var lenToPosState = Base.getLenToPosState(len);
  this._posSlotEncoder[lenToPosState].encode(this._rangeEncoder, posSlot);
  var footerBits = 30;
  var posReduced = (1 << footerBits) - 1;
  this._rangeEncoder.encodeDirectBits(posReduced >> Base.kNumAlignBits,
                                      footerBits - Base.kNumAlignBits);
  this._posAlignEncoder.reverseEncode(this._rangeEncoder,
                                      posReduced & Base.kAlignMask);
};

Encoder.prototype.flush = function(nowPos) {
  this.releaseMFStream();
  this.writeEndMarker(nowPos & this._posStateMask);
  this._rangeEncoder.flushData();
  this._rangeEncoder.flushStream();
};

Encoder.prototype.codeOneBlock = function(inSize, outSize, finished) {
  inSize[0] = 0;
  outSize[0] = 0;
  finished[0] = true;

  if (this._inStream) {
    this._matchFinder.setStream(this._inStream);
    this._matchFinder.init();
    this._needReleaseMFStream = true;
    this._inStream = null;
  }

  if (this._finished) {
    return;
  }
  this._finished = true;

  var progressPosValuePrev = this.nowPos64;
  var posState, curByte, i;

  if (this.nowPos64 === 0) {
    if (this._matchFinder.getNumAvailableBytes() === 0) {
      this.flush(this.nowPos64);
      return;
    }

    this.readMatchDistances();
    posState = this.nowPos64 & this._posStateMask;
    this._rangeEncoder.encode(this._isMatch, (this._state << Base.kNumPosStatesBitsMax) + posState, 0);
    this._state = Base.stateUpdateChar(this._state);
    curByte = this._matchFinder.getIndexByte(0 - this._additionalOffset);
    this._literalEncoder.getSubCoder(this.nowPos64, this._previousByte).
      encode(this._rangeEncoder, curByte);
    this._previousByte = curByte;
    this._additionalOffset--;
    this.nowPos64++;
  }
  if (this._matchFinder.getNumAvailableBytes() === 0) {
    this.flush(this.nowPos64);
    return;
  }
  while (true) {
    var len = this.getOptimum(this.nowPos64);
    var pos = this.backRes;
    posState = this.nowPos64 & this._posStateMask;
    var complexState = (this._state << Base.kNumPosStatesBitsMax) + posState;
    if (len === 1 && pos === -1) {
      this._rangeEncoder.encode(this._isMatch, complexState, 0);
      curByte = this._matchFinder.getIndexByte(- this._additionalOffset);
      var subCoder = this._literalEncoder.getSubCoder(this.nowPos64,
                                                      this._previousByte);
      if (!Base.stateIsCharState(this._state)) {
        var matchByte = this._matchFinder.getIndexByte(- this._repDistances[0] - 1 - this._additionalOffset);
        subCoder.encodeMatched(this._rangeEncoder, matchByte, curByte);
      } else {
        subCoder.encode(this._rangeEncoder, curByte);
      }
      this._previousByte = curByte;
      this._state = Base.stateUpdateChar(this._state);
    } else {
      this._rangeEncoder.encode(this._isMatch, complexState, 1);
      if (pos < Base.kNumRepDistances) {
        this._rangeEncoder.encode(this._isRep, this._state, 1);
        if (pos === 0) {
          this._rangeEncoder.encode(this._isRepG0, this._state, 0);
          if (len === 1) {
            this._rangeEncoder.encode(this._isRep0Long, complexState, 0);
          } else {
            this._rangeEncoder.encode(this._isRep0Long, complexState, 1);
          }
        } else {
          this._rangeEncoder.encode(this._isRepG0, this._state, 1);
          if (pos === 1) {
            this._rangeEncoder.encode(this._isRepG1, this._state, 0);
          } else {
            this._rangeEncoder.encode(this._isRepG1, this._state, 1);
            this._rangeEncoder.encode(this._isRepG2, this._state, pos - 2);
          }
        }
        if (len === 1) {
          this._state = Base.stateUpdateShortRep(this._state);
        } else {
          this._repMatchLenEncoder.encode(this._rangeEncoder,
                                          len - Base.kMatchMinLen, posState);
          this._state = Base.stateUpdateRep(this._state);
        }
        var distance = this._repDistances[pos];
        if (pos !== 0) {
          for (i = pos; i >= 1; i--) {
            this._repDistances[i] = this._repDistances[i - 1];
          }
          this._repDistances[0] = distance;
        }
      } else {
        this._rangeEncoder.encode(this._isRep, this._state, 0);
        this._state = Base.stateUpdateMatch(this._state);
        this._lenEncoder.encode(this._rangeEncoder, len - Base.kMatchMinLen,
                                posState);
        pos -= Base.kNumRepDistances;
        var posSlot = getPosSlot(pos);
        var lenToPosState = Base.getLenToPosState(len);
        this._posSlotEncoder[lenToPosState].encode(this._rangeEncoder, posSlot);

        if (posSlot >= Base.kStartPosModelIndex) {
          var footerBits = ((posSlot >>> 1) - 1);
          var baseVal = ((2 | (posSlot & 1)) << footerBits);
          var posReduced = pos - baseVal;

          if (posSlot < Base.kEndPosModelIndex) {
            RangeCoder.BitTreeEncoder.reverseEncode(this._posEncoders,
                                                    baseVal - posSlot - 1,
                                                    this._rangeEncoder,
                                                    footerBits, posReduced);
          } else {
            this._rangeEncoder.encodeDirectBits(posReduced >> Base.kNumAlignBits, footerBits - Base.kNumAlignBits);
            this._posAlignEncoder.reverseEncode(this._rangeEncoder,
                                                posReduced & Base.kAlignMask);
            this._alignPriceCount++;
          }
        }
        var distance2 = pos;
        for (i = Base.kNumRepDistances - 1; i >= 1; i--) {
          this._repDistances[i] = this._repDistances[i - 1];
        }
        this._repDistances[0] = distance2;
        this._matchPriceCount++;
      }
      this._previousByte =
        this._matchFinder.getIndexByte(len - 1 - this._additionalOffset);
    }
    this._additionalOffset -= len;
    this.nowPos64 += len;
    if (this._additionalOffset === 0) {
      // if (!_fastMode)
      if (this._matchPriceCount >= (1 << 7)) {
        this.fillDistancesPrices();
      }
      if (this._alignPriceCount >= Base.kAlignTableSize) {
        this.fillAlignPrices();
      }
      inSize[0] = this.nowPos64;
      outSize[0] = this._rangeEncoder.getProcessedSizeAdd();

      if (this._matchFinder.getNumAvailableBytes() === 0) {
        this.flush(this.nowPos64);
        return;
      }

      if (this.nowPos64 - progressPosValuePrev >= (1 << 12)) {
        this._finished = false;
        finished[0] = false;
        return;
      }
    }
  }
};

Encoder.prototype.releaseMFStream = function() {
  if (this._matchFinder && this._needReleaseMFStream) {
    this._matchFinder.releaseStream();
    this._needReleaseMFStream = false;
  }
};

Encoder.prototype.setOutStream = function(outStream) {
  this._rangeEncoder.setStream(outStream);
};
Encoder.prototype.releaseOutStream = function() {
  this._rangeEncoder.releaseStream();
};

Encoder.prototype.releaseStreams = function() {
  this.releaseMFStream();
  this.releaseOutStream();
};

Encoder.prototype.setStreams = function(inStream, outStream, inSize, outSize) {
  this._inStream = inStream;
  this._finished = false;
  this.create();
  this.setOutStream(outStream);
  this.init();

  // if (!_fastMode)
  if (true) {
    this.fillDistancesPrices();
    this.fillAlignPrices();
  }

  this._lenEncoder.setTableSize(this._numFastBytes + 1 - Base.kMatchMinLen);
  this._lenEncoder.updateTables(1 << this._posStateBits);
  this._repMatchLenEncoder.setTableSize(this._numFastBytes +
                                        1 - Base.kMatchMinLen);
  this._repMatchLenEncoder.updateTables(1 << this._posStateBits);

  this.nowPos64 = 0;
};

Encoder.prototype.code = function(inStream, outStream, inSize, outSize, progress) {
  this._needReleaseMFStream = false;
  try {
    this.setStreams(inStream, outStream, inSize, outSize);
    while (true) {

      this.codeOneBlock(this.processedInSize, this.processedOutSize,
                        this.finished);
      if (this.finished[0]) {
        return;
      }
      if (progress) {
        progress.setProgress(this.processedInSize[0], this.processedOutSize[0]);
      }
    }
  } finally {
    this.releaseStreams();
  }
};

Encoder.prototype.writeCoderProperties = function(outStream) {
  var properties = makeBuffer(kPropSize), i;
  properties[0] = ((this._posStateBits * 5 + this._numLiteralPosStateBits) * 9+
                   this._numLiteralContextBits);
  for (i = 0; i < 4; i++) {
    properties[1 + i] = (this._dictionarySize >>> (8 * i));
  }
  for (i = 0; i< kPropSize; i++) {
    outStream.writeByte(properties[i]);
  }
};

Encoder.prototype.fillDistancesPrices = function() {
  var tempPrices = [];
  tempPrices.length = Base.kNumFullDistances;
  var i, posSlot;
  for (i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++) {
    posSlot = getPosSlot(i);
    var footerBits = ((posSlot >>> 1) - 1);
    var baseVal = ((2 | (posSlot & 1)) << footerBits);
    tempPrices[i] =
      RangeCoder.BitTreeEncoder.reverseGetPrice(this._posEncoders,
                                                baseVal - posSlot - 1,
                                                footerBits, i - baseVal);
  }

  var lenToPosState = 0;
  for ( ; lenToPosState < Base.kNumLenToPosStates; lenToPosState++) {
    var encoder = this._posSlotEncoder[lenToPosState];

    var st = (lenToPosState << Base.kNumPosSlotBits);
    for (posSlot = 0; posSlot < this._distTableSize; posSlot++) {
      this._posSlotPrices[st + posSlot] = encoder.getPrice(posSlot);
    }
    for (posSlot = Base.kEndPosModelIndex; posSlot < this._distTableSize; posSlot++) {
      this._posSlotPrices[st + posSlot] += ((((posSlot >>> 1) - 1) - Base.kNumAlignBits) << RangeCoder.Encoder.kNumBitPriceShiftBits);
    }

    var st2 = lenToPosState * Base.kNumFullDistances;
    for (i = 0; i < Base.kStartPosModelIndex; i++) {
      this._distancesPrices[st2 + i] = this._posSlotPrices[st + i];
    }
    for (; i < Base.kNumFullDistances; i++) {
      this._distancesPrices[st2 + i] =
        this._posSlotPrices[st + getPosSlot(i)] + tempPrices[i];
    }
  }
  this._matchPriceCount = 0;
};

Encoder.prototype.fillAlignPrices = function() {
  var i;
  for (i = 0; i < Base.kAlignTableSize; i++) {
    this._alignPrices[i] = this._posAlignEncoder.reverseGetPrice(i);
  }
  this._alignPriceCount = 0;
};

Encoder.prototype.setAlgorithm = function(algorithm) {
  /*
    _fastMode = (algorithm == 0);
    _maxMode = (algorithm >= 2);
  */
  return true;
};

Encoder.prototype.setDictionarySize = function(dictionarySize) {
  var kDicLogSizeMaxCompress = 29;
  if (dictionarySize < (1 << Base.kDicLogSizeMin) ||
      dictionarySize > (1 << kDicLogSizeMaxCompress)) {
    return false;
  }
  this._dictionarySize = dictionarySize;
  var dicLogSize = 0;
  while (dictionarySize > (1 << dicLogSize)) {
    dicLogSize++;
  }
  this._distTableSize = dicLogSize * 2;
  return true;
};

Encoder.prototype.setNumFastBytes = function(numFastBytes) {
  if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen) {
    return false;
  }
  this._numFastBytes = numFastBytes;
  return true;
};

Encoder.prototype.setMatchFinder = function(matchFinderIndex) {
  if (matchFinderIndex < 0 || matchFinderIndex > 2) {
    return false;
  }
  var matchFinderIndexPrev = this._matchFinderType;
  this._matchFinderType = matchFinderIndex;
  if (this._matchFinder && matchFinderIndexPrev != this._matchFinderType) {
    this._dictionarySizePrev = -1;
    this._matchFinder = null;
  }
  return true;
};

Encoder.prototype.setLcLpPb = function(lc, lp, pb) {
  if (lp < 0 || lp > Base.kNumLitPosStatesBitsEncodingMax ||
      lc < 0 || lc > Base.kNumLitContextBitsMax ||
      pb < 0 || pb > Base.kNumPosStatesBitsEncodingMax) {
    return false;
  }
  this._numLiteralPosStateBits = lp;
  this._numLiteralContextBits = lc;
  this._posStateBits = pb;
  this._posStateMask = ((1) << this._posStateBits) - 1;
  return true;
};

Encoder.prototype.setEndMarkerMode = function(endMarkerMode) {
  this._writeEndMark = endMarkerMode;
};

Encoder.EMatchFinderTypeBT2 = EMatchFinderTypeBT2;
Encoder.EMatchFinderTypeBT4 = EMatchFinderTypeBT4;

LZMA.Encoder = Encoder;
/*
Copyright (c) 2011 Juan Mellado

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/*
References:
- "LZMA SDK" by Igor Pavlov
  http://www.7-zip.org/sdk.html
*/
/* Original source found at: http://code.google.com/p/js-lzma/ */

// shortcuts
var initBitModels = RangeCoder.Encoder.initBitModels;

var LenDecoder = function(){
  this._choice = initBitModels(null, 2);
  this._lowCoder = [];
  this._midCoder = [];
  this._highCoder = new RangeCoder.BitTreeDecoder(8);
  this._numPosStates = 0;
};

LenDecoder.prototype.create = function(numPosStates){
  for (; this._numPosStates < numPosStates; ++ this._numPosStates){
    this._lowCoder[this._numPosStates] = new RangeCoder.BitTreeDecoder(3);
    this._midCoder[this._numPosStates] = new RangeCoder.BitTreeDecoder(3);
  }
};

LenDecoder.prototype.init = function(){
  var i = this._numPosStates;
  initBitModels(this._choice);
  while(i --){
    this._lowCoder[i].init();
    this._midCoder[i].init();
  }
  this._highCoder.init();
};

LenDecoder.prototype.decode = function(rangeDecoder, posState){
  if (rangeDecoder.decodeBit(this._choice, 0) === 0){
    return this._lowCoder[posState].decode(rangeDecoder);
  }
  if (rangeDecoder.decodeBit(this._choice, 1) === 0){
    return 8 + this._midCoder[posState].decode(rangeDecoder);
  }
  return 16 + this._highCoder.decode(rangeDecoder);
};

var LiteralDecoder = function(){
};

LiteralDecoder.Decoder2 = function(){
  this._decoders = initBitModels(null, 0x300);
};

LiteralDecoder.Decoder2.prototype.init = function(){
  initBitModels(this._decoders);
};

LiteralDecoder.Decoder2.prototype.decodeNormal = function(rangeDecoder){
  var symbol = 1;

  do{
    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
  }while(symbol < 0x100);

  return symbol & 0xff;
};

LiteralDecoder.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){
  var symbol = 1, matchBit, bit;

  do{
    matchBit = (matchByte >> 7) & 1;
    matchByte <<= 1;
    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);
    symbol = (symbol << 1) | bit;
    if (matchBit !== bit){
      while(symbol < 0x100){
        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
      }
      break;
    }
  }while(symbol < 0x100);

  return symbol & 0xff;
};

LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){
  var i;

  if (this._coders &&
      (this._numPrevBits === numPrevBits) &&
      (this._numPosBits === numPosBits) ){
    return;
  }
  this._numPosBits = numPosBits;
  this._posMask = (1 << numPosBits) - 1;
  this._numPrevBits = numPrevBits;

  this._coders = [];

  i = 1 << (this._numPrevBits + this._numPosBits);
  while(i --){
    this._coders[i] = new LiteralDecoder.Decoder2();
  }
};

LiteralDecoder.prototype.init = function(){
  var i = 1 << (this._numPrevBits + this._numPosBits);
  while(i --){
    this._coders[i].init();
  }
};

LiteralDecoder.prototype.getDecoder = function(pos, prevByte){
  return this._coders[( (pos & this._posMask) << this._numPrevBits) +
                      ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];
};

var Decoder = function(){
  var i;
  this._outWindow = new LZ.OutWindow();
  this._rangeDecoder = new RangeCoder.Decoder();

  this._isMatchDecoders =
    initBitModels(null, Base.kNumStates << Base.kNumPosStatesBitsMax);
  this._isRepDecoders = initBitModels(null, Base.kNumStates);
  this._isRepG0Decoders = initBitModels(null, Base.kNumStates);
  this._isRepG1Decoders = initBitModels(null, Base.kNumStates);
  this._isRepG2Decoders = initBitModels(null, Base.kNumStates);
  this._isRep0LongDecoders =
    initBitModels(null, Base.kNumStates << Base.kNumPosStatesBitsMax);
  this._posSlotDecoder = [];
  this._posDecoders = initBitModels(null, Base.kNumFullDistances - Base.kEndPosModelIndex);
  this._posAlignDecoder = new RangeCoder.BitTreeDecoder(Base.kNumAlignBits);
  this._lenDecoder = new LenDecoder();
  this._repLenDecoder = new LenDecoder();
  this._literalDecoder = new LiteralDecoder();
  this._dictionarySize = -1;
  this._dictionarySizeCheck = -1;
  this._posStateMask = 0;

  for (i=0; i<Base.kNumLenToPosStates; i++) {
    this._posSlotDecoder[i] = new RangeCoder.BitTreeDecoder(Base.kNumPosSlotBits);
  }
};

Decoder.prototype.setDictionarySize = function(dictionarySize){
  if (dictionarySize < 0){
    return false;
  }
  if (this._dictionarySize !== dictionarySize){
    this._dictionarySize = dictionarySize;
    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);
    this._outWindow.create( Math.max(this._dictionarySizeCheck, (1 << 12)) );
  }
  return true;
};

Decoder.prototype.setLcLpPb = function(lc, lp, pb){
  var numPosStates = 1 << pb;

  if (lc > Base.kNumLitContextBitsMax || lp > 4 || pb > Base.kNumPosStatesBitsMax){
    return false;
  }

  this._literalDecoder.create(lp, lc);

  this._lenDecoder.create(numPosStates);
  this._repLenDecoder.create(numPosStates);
  this._posStateMask = numPosStates - 1;

  return true;
};

Decoder.prototype.init = function(){
  var i = Base.kNumLenToPosStates;

  this._outWindow.init(false);

  initBitModels(this._isMatchDecoders);
  initBitModels(this._isRepDecoders);
  initBitModels(this._isRepG0Decoders);
  initBitModels(this._isRepG1Decoders);
  initBitModels(this._isRepG2Decoders);
  initBitModels(this._isRep0LongDecoders);
  initBitModels(this._posDecoders);

  this._literalDecoder.init();

  while(i --){
    this._posSlotDecoder[i].init();
  }

  this._lenDecoder.init();
  this._repLenDecoder.init();
  this._posAlignDecoder.init();
  this._rangeDecoder.init();
};

Decoder.prototype.code = function(inStream, outStream, outSize){
  // note that nowPos64 is actually only 53 bits long; that sets a limit
  // on the amount of data we can decode
  var state, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,
      posState, decoder2, len, distance, posSlot, numDirectBits;

  this._rangeDecoder.setStream(inStream);
  this._outWindow.setStream(outStream);

  this.init();

  state = Base.stateInit();
  while(outSize < 0 || nowPos64 < outSize){
    posState = nowPos64 & this._posStateMask;

    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << Base.kNumPosStatesBitsMax) + posState) === 0){
      decoder2 = this._literalDecoder.getDecoder(nowPos64, prevByte);

      if (!Base.stateIsCharState(state)){
        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );
      }else{
        prevByte = decoder2.decodeNormal(this._rangeDecoder);
      }
      this._outWindow.putByte(prevByte);
      state = Base.stateUpdateChar(state);
      nowPos64++;

    }else{

      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){
        len = 0;
        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){
          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << Base.kNumPosStatesBitsMax) + posState) === 0){
            state = Base.stateUpdateShortRep(state);
            len = 1;
          }
        }else{
          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){
            distance = rep1;
          }else{
            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){
              distance = rep2;
            }else{
              distance = rep3;
              rep3 = rep2;
            }
            rep2 = rep1;
          }
          rep1 = rep0;
          rep0 = distance;
        }
        if (len === 0){
          len = Base.kMatchMinLen + this._repLenDecoder.decode(this._rangeDecoder, posState);
          state = Base.stateUpdateRep(state);
        }
      }else{
        rep3 = rep2;
        rep2 = rep1;
        rep1 = rep0;

        len = Base.kMatchMinLen + this._lenDecoder.decode(this._rangeDecoder, posState);
        state = Base.stateUpdateMatch(state);

        posSlot = this._posSlotDecoder[Base.getLenToPosState(len)].decode(this._rangeDecoder);
        if (posSlot >= Base.kStartPosModelIndex){

          numDirectBits = (posSlot >> 1) - 1;
          rep0 = (2 | (posSlot & 1) ) << numDirectBits;

          if (posSlot < Base.kEndPosModelIndex){
            rep0 += RangeCoder.BitTreeDecoder.reverseDecode(this._posDecoders,
                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);
          }else{
            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits;
            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);
            if (rep0 < 0){
              if (rep0 === -1){
                break;
              }
              return false;
            }
          }
        }else{
          rep0 = posSlot;
        }
      }

      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){
        return false;
      }

      this._outWindow.copyBlock(rep0, len);
      nowPos64 += len;
      prevByte = this._outWindow.getByte(0);
    }
  }

  this._outWindow.flush();
  this._outWindow.releaseStream();
  this._rangeDecoder.releaseStream();

  return true;
};

Decoder.prototype.setDecoderProperties = function(properties){
  var value, lc, lp, pb, dictionarySize, i, shift;

  if (properties.length < 5){
    return false;
  }

  value = properties[0] & 0xFF;
  lc = value % 9;
  value = ~~(value / 9);
  lp = value % 5;
  pb = ~~(value / 5);

  if ( !this.setLcLpPb(lc, lp, pb) ){
    return false;
  }

  dictionarySize = 0;
  for (i=0, shift=1; i<4; i++, shift*=256)
    dictionarySize += (properties[1+i] & 0xFF) * shift;

  return this.setDictionarySize(dictionarySize);
};
Decoder.prototype.setDecoderPropertiesFromStream = function(stream) {
  var buffer = [], i;
  for (i=0; i<5; i++) {
    buffer[i] = stream.readByte();
  }
  return this.setDecoderProperties(buffer);
};

LZMA.Decoder = Decoder;
}).call(this);
/*
Copyright (c) 2011 Juan Mellado

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/*
References:
- "LZMA SDK" by Igor Pavlov
  http://www.7-zip.org/sdk.html
*/
/* Original source found at: http://code.google.com/p/js-lzma/ */

var Util = Object.create(null);

Util.decompress = function(properties, inStream, outStream, outSize){
  var decoder = new LZMA.Decoder();

  if ( !decoder.setDecoderProperties(properties) ){
    throw "Incorrect stream properties";
  }

  if ( !decoder.code(inStream, outStream, outSize) ){
    throw "Error in data stream";
  }

  return true;
};

/* Also accepts a Uint8Array/Buffer/array as first argument, in which case
 * returns the decompressed file as a Uint8Array/Buffer/array. */
Util.decompressFile = function(inStream, outStream){
  var decoder = new LZMA.Decoder(), i, mult;
  var retval = true;

  if (!('readByte' in inStream)) {
    var inBuffer = inStream;
    inStream = {
      size: inBuffer.length,
      pos: 0,
      readByte: function() { return inBuffer[this.pos++]; }
    };
  }

  if ( !decoder.setDecoderPropertiesFromStream(inStream) ){
    throw "Incorrect stream properties";
  }

  // largest integer in javascript is 2^53 (unless we use typed arrays)
  // but we don't explicitly check for overflow here.  caveat user.
  var outSizeLo = 0;
  for (i=0, mult=1; i<4; i++, mult*=256) {
    outSizeLo += (inStream.readByte() * mult);
  }
  var outSizeHi = 0;
  for (i=0, mult=1; i<4; i++, mult*=256) {
    outSizeHi += (inStream.readByte() * mult);
  }
  var outSize = outSizeLo + (outSizeHi * 0x100000000);
  if (outSizeLo === 0xFFFFFFFF && outSizeHi === 0xFFFFFFFF) {
    outSize = -1;
  } else if (outSizeHi >= 0x200000) {
    outSize = -1; // force streaming
  }

  if (!(outStream && 'writeByte' in outStream)) {
    outStream = {
      buffer: (outSize>=0) ? makeBuffer(outSize) : [],
      pos: 0,
      writeByte: function(b) { this.buffer[this.pos++] = b; }
    };
    retval = outStream.buffer;
  }

  if ( !decoder.code(inStream, outStream, outSize) ){
    throw "Error in data stream";
  }

  return retval;
};

/* The following is a mapping from gzip/bzip2 style -1 .. -9 compression modes
 * to the corresponding LZMA compression modes. Thanks, Larhzu, for coining
 * these. */ /* [csa] lifted from lzmp.cpp in the LZMA SDK. */
var option_mapping = [
  { a:0, d: 0, fb: 0,  mf: null, lc:0, lp:0, pb:0 },// -0 (needed for indexing)
  { a:0, d:16, fb:64,  mf:"hc4", lc:3, lp:0, pb:2 },// -1
  { a:0, d:20, fb:64,  mf:"hc4", lc:3, lp:0, pb:2 },// -2
  { a:1, d:19, fb:64,  mf:"bt4", lc:3, lp:0, pb:2 },// -3
  { a:2, d:20, fb:64,  mf:"bt4", lc:3, lp:0, pb:2 },// -4
  { a:2, d:21, fb:128, mf:"bt4", lc:3, lp:0, pb:2 },// -5
  { a:2, d:22, fb:128, mf:"bt4", lc:3, lp:0, pb:2 },// -6
  { a:2, d:23, fb:128, mf:"bt4", lc:3, lp:0, pb:2 },// -7
  { a:2, d:24, fb:255, mf:"bt4", lc:3, lp:0, pb:2 },// -8
  { a:2, d:25, fb:255, mf:"bt4", lc:3, lp:0, pb:2 } // -9
];

/** Create and configure an Encoder, based on the given properties (which
 *  make be a simple number, for a compression level between 1 and 9. */
var makeEncoder = function(props) {
  var encoder = new LZMA.Encoder();
  var params = { // defaults!
    a: 1, /* algorithm */
    d: 23, /* dictionary */
    fb: 128, /* fast bytes */
    lc: 3, /* literal context */
    lp: 0, /* literal position */
    pb: 2, /* position bits */
    mf: "bt4", /* match finder (bt2/bt4) */
    eos: false /* write end of stream */
  };
  // override default params with props
  if (props) {
    if (typeof(props)==='number') { // -1 through -9 options
      props = option_mapping[props];
    }
    var p;
    for (p in props) {
      if (Object.prototype.hasOwnProperty.call(props, p)) {
        params[p] = props[p];
      }
    }
  }
  encoder.setAlgorithm(params.a);
  encoder.setDictionarySize( 1<< (+params.d));
  encoder.setNumFastBytes(+params.fb);
  encoder.setMatchFinder((params.mf === 'bt4') ?
                         LZMA.Encoder.EMatchFinderTypeBT4 :
                         LZMA.Encoder.EMatchFinderTypeBT2);
  encoder.setLcLpPb(+params.lc, +params.lp, +params.pb);
  encoder.setEndMarkerMode(!!params.eos);
  return encoder;
};

Util.compress = function(inStream, outStream, props, progress){
  var encoder = makeEncoder(props);

  encoder.writeCoderProperties(outStream);

  encoder.code(inStream, outStream, -1, -1, {
    setProgress: function(inSize, outSize) {
      if (progress) { progress(inSize, outSize); }
    }
  });

  return true;
};

/* Also accepts a Uint8Array/Buffer/array as first argument, in which case
 * returns the compressed file as a Uint8Array/Buffer/array. */
Util.compressFile = function(inStream, outStream, props, progress) {
  var encoder = makeEncoder(props);
  var retval = true, i;

  if (!('readByte' in inStream)) {
    var inBuffer = inStream;
    inStream = {
      size: inBuffer.length,
      pos: 0,
      readByte: function() { return inBuffer[this.pos++]; },
      read: function(buffer, bufOffset, length) {
        var bytesRead = 0;
        while (bytesRead < length && this.pos < inBuffer.length) {
          buffer[bufOffset++] = inBuffer[this.pos++];
          bytesRead++;
        }
        return bytesRead;
      }
    };
  }
  // if we know the size, write it; otherwise we need to use the 'eos' property
  var fileSize;
  if ('size' in inStream && inStream.size >= 0) {
    fileSize = inStream.size;
  } else {
    fileSize = -1;
    encoder.setEndMarkerMode(true);
  }

  if (!(outStream && 'writeByte' in outStream)) {
    outStream = {
      buffer: [],
      pos: 0,
      writeByte: function(b) { this.buffer[this.pos++] = b; },
      flush: function() { /* do nothing */ }
    };
    retval = outStream.buffer;
  }

  encoder.writeCoderProperties(outStream);

  var out64 = function(s) {
    // supports up to 53-bit integers
    var i;
    for (i=0;i<8;i++) {
      outStream.writeByte(s & 0xFF);
      s = Math.floor(s/256);
    }
  };
  out64(fileSize);

  encoder.code(inStream, outStream, fileSize, -1, {
    setProgress: function(inSize, outSize) {
      if (progress) { progress(inSize, outSize); }
    }
  });

  return retval;
};

	global["LWF"].LZMA = Util;

}).call(this);
